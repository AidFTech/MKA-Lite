// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protos.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:VersionRequestOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VersionRequestOptions {
    // message fields
    // @@protoc_insertion_point(field:VersionRequestOptions.snapshot_version)
    pub snapshot_version: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:VersionRequestOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VersionRequestOptions {
    fn default() -> &'a VersionRequestOptions {
        <VersionRequestOptions as ::protobuf::Message>::default_instance()
    }
}

impl VersionRequestOptions {
    pub fn new() -> VersionRequestOptions {
        ::std::default::Default::default()
    }

    // optional int64 snapshot_version = 1;

    pub fn snapshot_version(&self) -> i64 {
        self.snapshot_version.unwrap_or(0)
    }

    pub fn clear_snapshot_version(&mut self) {
        self.snapshot_version = ::std::option::Option::None;
    }

    pub fn has_snapshot_version(&self) -> bool {
        self.snapshot_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_version(&mut self, v: i64) {
        self.snapshot_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snapshot_version",
            |m: &VersionRequestOptions| { &m.snapshot_version },
            |m: &mut VersionRequestOptions| { &mut m.snapshot_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionRequestOptions>(
            "VersionRequestOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VersionRequestOptions {
    const NAME: &'static str = "VersionRequestOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.snapshot_version = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.snapshot_version {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.snapshot_version {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VersionRequestOptions {
        VersionRequestOptions::new()
    }

    fn clear(&mut self) {
        self.snapshot_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VersionRequestOptions {
        static instance: VersionRequestOptions = VersionRequestOptions {
            snapshot_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VersionRequestOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VersionRequestOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VersionRequestOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionRequestOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VersionResponseOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VersionResponseOptions {
    // message fields
    // @@protoc_insertion_point(field:VersionResponseOptions.connection_configuration)
    pub connection_configuration: ::protobuf::MessageField<ConnectionConfiguration>,
    // special fields
    // @@protoc_insertion_point(special_field:VersionResponseOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VersionResponseOptions {
    fn default() -> &'a VersionResponseOptions {
        <VersionResponseOptions as ::protobuf::Message>::default_instance()
    }
}

impl VersionResponseOptions {
    pub fn new() -> VersionResponseOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectionConfiguration>(
            "connection_configuration",
            |m: &VersionResponseOptions| { &m.connection_configuration },
            |m: &mut VersionResponseOptions| { &mut m.connection_configuration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionResponseOptions>(
            "VersionResponseOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VersionResponseOptions {
    const NAME: &'static str = "VersionResponseOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connection_configuration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VersionResponseOptions {
        VersionResponseOptions::new()
    }

    fn clear(&mut self) {
        self.connection_configuration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VersionResponseOptions {
        static instance: VersionResponseOptions = VersionResponseOptions {
            connection_configuration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VersionResponseOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VersionResponseOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VersionResponseOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionResponseOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AuthResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthResponse {
    // message fields
    // @@protoc_insertion_point(field:AuthResponse.status)
    pub status: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:AuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthResponse {
    fn default() -> &'a AuthResponse {
        <AuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthResponse {
    pub fn new() -> AuthResponse {
        ::std::default::Default::default()
    }

    // required int32 status = 1;

    pub fn status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &AuthResponse| { &m.status },
            |m: &mut AuthResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthResponse>(
            "AuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthResponse {
    const NAME: &'static str = "AuthResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthResponse {
        AuthResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthResponse {
        static instance: AuthResponse = AuthResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ServiceDiscoveryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceDiscoveryRequest {
    // message fields
    // @@protoc_insertion_point(field:ServiceDiscoveryRequest.small_icon)
    pub small_icon: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ServiceDiscoveryRequest.medium_icon)
    pub medium_icon: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ServiceDiscoveryRequest.large_icon)
    pub large_icon: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ServiceDiscoveryRequest.label_text)
    pub label_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryRequest.device_name)
    pub device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryRequest.phone_info)
    pub phone_info: ::protobuf::MessageField<super::common::PhoneInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ServiceDiscoveryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDiscoveryRequest {
    fn default() -> &'a ServiceDiscoveryRequest {
        <ServiceDiscoveryRequest as ::protobuf::Message>::default_instance()
    }
}

impl ServiceDiscoveryRequest {
    pub fn new() -> ServiceDiscoveryRequest {
        ::std::default::Default::default()
    }

    // optional bytes small_icon = 1;

    pub fn small_icon(&self) -> &[u8] {
        match self.small_icon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_small_icon(&mut self) {
        self.small_icon = ::std::option::Option::None;
    }

    pub fn has_small_icon(&self) -> bool {
        self.small_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_icon(&mut self, v: ::std::vec::Vec<u8>) {
        self.small_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_small_icon(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.small_icon.is_none() {
            self.small_icon = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.small_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_small_icon(&mut self) -> ::std::vec::Vec<u8> {
        self.small_icon.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes medium_icon = 2;

    pub fn medium_icon(&self) -> &[u8] {
        match self.medium_icon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_medium_icon(&mut self) {
        self.medium_icon = ::std::option::Option::None;
    }

    pub fn has_medium_icon(&self) -> bool {
        self.medium_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medium_icon(&mut self, v: ::std::vec::Vec<u8>) {
        self.medium_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medium_icon(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.medium_icon.is_none() {
            self.medium_icon = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.medium_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_medium_icon(&mut self) -> ::std::vec::Vec<u8> {
        self.medium_icon.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes large_icon = 3;

    pub fn large_icon(&self) -> &[u8] {
        match self.large_icon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_large_icon(&mut self) {
        self.large_icon = ::std::option::Option::None;
    }

    pub fn has_large_icon(&self) -> bool {
        self.large_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large_icon(&mut self, v: ::std::vec::Vec<u8>) {
        self.large_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_large_icon(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.large_icon.is_none() {
            self.large_icon = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.large_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_large_icon(&mut self) -> ::std::vec::Vec<u8> {
        self.large_icon.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string label_text = 4;

    pub fn label_text(&self) -> &str {
        match self.label_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label_text(&mut self) {
        self.label_text = ::std::option::Option::None;
    }

    pub fn has_label_text(&self) -> bool {
        self.label_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label_text(&mut self, v: ::std::string::String) {
        self.label_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_text(&mut self) -> &mut ::std::string::String {
        if self.label_text.is_none() {
            self.label_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_label_text(&mut self) -> ::std::string::String {
        self.label_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_name = 5;

    pub fn device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self.device_name = ::std::option::Option::None;
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "small_icon",
            |m: &ServiceDiscoveryRequest| { &m.small_icon },
            |m: &mut ServiceDiscoveryRequest| { &mut m.small_icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medium_icon",
            |m: &ServiceDiscoveryRequest| { &m.medium_icon },
            |m: &mut ServiceDiscoveryRequest| { &mut m.medium_icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "large_icon",
            |m: &ServiceDiscoveryRequest| { &m.large_icon },
            |m: &mut ServiceDiscoveryRequest| { &mut m.large_icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label_text",
            |m: &ServiceDiscoveryRequest| { &m.label_text },
            |m: &mut ServiceDiscoveryRequest| { &mut m.label_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_name",
            |m: &ServiceDiscoveryRequest| { &m.device_name },
            |m: &mut ServiceDiscoveryRequest| { &mut m.device_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::PhoneInfo>(
            "phone_info",
            |m: &ServiceDiscoveryRequest| { &m.phone_info },
            |m: &mut ServiceDiscoveryRequest| { &mut m.phone_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDiscoveryRequest>(
            "ServiceDiscoveryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceDiscoveryRequest {
    const NAME: &'static str = "ServiceDiscoveryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.small_icon = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.medium_icon = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.large_icon = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.label_text = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.device_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.phone_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.small_icon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.medium_icon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.large_icon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.label_text.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.phone_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.small_icon.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.medium_icon.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.large_icon.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.label_text.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.phone_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDiscoveryRequest {
        ServiceDiscoveryRequest::new()
    }

    fn clear(&mut self) {
        self.small_icon = ::std::option::Option::None;
        self.medium_icon = ::std::option::Option::None;
        self.large_icon = ::std::option::Option::None;
        self.label_text = ::std::option::Option::None;
        self.device_name = ::std::option::Option::None;
        self.phone_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDiscoveryRequest {
        static instance: ServiceDiscoveryRequest = ServiceDiscoveryRequest {
            small_icon: ::std::option::Option::None,
            medium_icon: ::std::option::Option::None,
            large_icon: ::std::option::Option::None,
            label_text: ::std::option::Option::None,
            device_name: ::std::option::Option::None,
            phone_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceDiscoveryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceDiscoveryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceDiscoveryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceDiscoveryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ServiceDiscoveryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceDiscoveryResponse {
    // message fields
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.services)
    pub services: ::std::vec::Vec<Service>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.make)
    pub make: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.model)
    pub model: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.year)
    pub year: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.vehicle_id)
    pub vehicle_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.driver_position)
    pub driver_position: ::std::option::Option<::protobuf::EnumOrUnknown<DriverPosition>>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.head_unit_make)
    pub head_unit_make: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.head_unit_model)
    pub head_unit_model: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.head_unit_software_build)
    pub head_unit_software_build: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.head_unit_software_version)
    pub head_unit_software_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.can_play_native_media_during_vr)
    pub can_play_native_media_during_vr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.session_configuration)
    pub session_configuration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.probe_for_support)
    pub probe_for_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.connection_configuration)
    pub connection_configuration: ::protobuf::MessageField<ConnectionConfiguration>,
    // @@protoc_insertion_point(field:ServiceDiscoveryResponse.headunit_info)
    pub headunit_info: ::protobuf::MessageField<super::common::HeadUnitInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ServiceDiscoveryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDiscoveryResponse {
    fn default() -> &'a ServiceDiscoveryResponse {
        <ServiceDiscoveryResponse as ::protobuf::Message>::default_instance()
    }
}

impl ServiceDiscoveryResponse {
    pub fn new() -> ServiceDiscoveryResponse {
        ::std::default::Default::default()
    }

    // optional string make = 2;

    pub fn make(&self) -> &str {
        match self.make.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_make(&mut self) {
        self.make = ::std::option::Option::None;
    }

    pub fn has_make(&self) -> bool {
        self.make.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make(&mut self, v: ::std::string::String) {
        self.make = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_make(&mut self) -> &mut ::std::string::String {
        if self.make.is_none() {
            self.make = ::std::option::Option::Some(::std::string::String::new());
        }
        self.make.as_mut().unwrap()
    }

    // Take field
    pub fn take_make(&mut self) -> ::std::string::String {
        self.make.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string model = 3;

    pub fn model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_model(&mut self) {
        self.model = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        if self.model.is_none() {
            self.model = ::std::option::Option::Some(::std::string::String::new());
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        self.model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string year = 4;

    pub fn year(&self) -> &str {
        match self.year.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: ::std::string::String) {
        self.year = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_year(&mut self) -> &mut ::std::string::String {
        if self.year.is_none() {
            self.year = ::std::option::Option::Some(::std::string::String::new());
        }
        self.year.as_mut().unwrap()
    }

    // Take field
    pub fn take_year(&mut self) -> ::std::string::String {
        self.year.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vehicle_id = 5;

    pub fn vehicle_id(&self) -> &str {
        match self.vehicle_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vehicle_id(&mut self) {
        self.vehicle_id = ::std::option::Option::None;
    }

    pub fn has_vehicle_id(&self) -> bool {
        self.vehicle_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vehicle_id(&mut self, v: ::std::string::String) {
        self.vehicle_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vehicle_id(&mut self) -> &mut ::std::string::String {
        if self.vehicle_id.is_none() {
            self.vehicle_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vehicle_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_vehicle_id(&mut self) -> ::std::string::String {
        self.vehicle_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .DriverPosition driver_position = 6;

    pub fn driver_position(&self) -> DriverPosition {
        match self.driver_position {
            Some(e) => e.enum_value_or(DriverPosition::DRIVER_POSITION_LEFT),
            None => DriverPosition::DRIVER_POSITION_LEFT,
        }
    }

    pub fn clear_driver_position(&mut self) {
        self.driver_position = ::std::option::Option::None;
    }

    pub fn has_driver_position(&self) -> bool {
        self.driver_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver_position(&mut self, v: DriverPosition) {
        self.driver_position = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string head_unit_make = 7;

    pub fn head_unit_make(&self) -> &str {
        match self.head_unit_make.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_head_unit_make(&mut self) {
        self.head_unit_make = ::std::option::Option::None;
    }

    pub fn has_head_unit_make(&self) -> bool {
        self.head_unit_make.is_some()
    }

    // Param is passed by value, moved
    pub fn set_head_unit_make(&mut self, v: ::std::string::String) {
        self.head_unit_make = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_head_unit_make(&mut self) -> &mut ::std::string::String {
        if self.head_unit_make.is_none() {
            self.head_unit_make = ::std::option::Option::Some(::std::string::String::new());
        }
        self.head_unit_make.as_mut().unwrap()
    }

    // Take field
    pub fn take_head_unit_make(&mut self) -> ::std::string::String {
        self.head_unit_make.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string head_unit_model = 8;

    pub fn head_unit_model(&self) -> &str {
        match self.head_unit_model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_head_unit_model(&mut self) {
        self.head_unit_model = ::std::option::Option::None;
    }

    pub fn has_head_unit_model(&self) -> bool {
        self.head_unit_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_head_unit_model(&mut self, v: ::std::string::String) {
        self.head_unit_model = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_head_unit_model(&mut self) -> &mut ::std::string::String {
        if self.head_unit_model.is_none() {
            self.head_unit_model = ::std::option::Option::Some(::std::string::String::new());
        }
        self.head_unit_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_head_unit_model(&mut self) -> ::std::string::String {
        self.head_unit_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string head_unit_software_build = 9;

    pub fn head_unit_software_build(&self) -> &str {
        match self.head_unit_software_build.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_head_unit_software_build(&mut self) {
        self.head_unit_software_build = ::std::option::Option::None;
    }

    pub fn has_head_unit_software_build(&self) -> bool {
        self.head_unit_software_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_head_unit_software_build(&mut self, v: ::std::string::String) {
        self.head_unit_software_build = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_head_unit_software_build(&mut self) -> &mut ::std::string::String {
        if self.head_unit_software_build.is_none() {
            self.head_unit_software_build = ::std::option::Option::Some(::std::string::String::new());
        }
        self.head_unit_software_build.as_mut().unwrap()
    }

    // Take field
    pub fn take_head_unit_software_build(&mut self) -> ::std::string::String {
        self.head_unit_software_build.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string head_unit_software_version = 10;

    pub fn head_unit_software_version(&self) -> &str {
        match self.head_unit_software_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_head_unit_software_version(&mut self) {
        self.head_unit_software_version = ::std::option::Option::None;
    }

    pub fn has_head_unit_software_version(&self) -> bool {
        self.head_unit_software_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_head_unit_software_version(&mut self, v: ::std::string::String) {
        self.head_unit_software_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_head_unit_software_version(&mut self) -> &mut ::std::string::String {
        if self.head_unit_software_version.is_none() {
            self.head_unit_software_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.head_unit_software_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_head_unit_software_version(&mut self) -> ::std::string::String {
        self.head_unit_software_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool can_play_native_media_during_vr = 11;

    pub fn can_play_native_media_during_vr(&self) -> bool {
        self.can_play_native_media_during_vr.unwrap_or(false)
    }

    pub fn clear_can_play_native_media_during_vr(&mut self) {
        self.can_play_native_media_during_vr = ::std::option::Option::None;
    }

    pub fn has_can_play_native_media_during_vr(&self) -> bool {
        self.can_play_native_media_during_vr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_play_native_media_during_vr(&mut self, v: bool) {
        self.can_play_native_media_during_vr = ::std::option::Option::Some(v);
    }

    // optional int32 session_configuration = 13;

    pub fn session_configuration(&self) -> i32 {
        self.session_configuration.unwrap_or(0)
    }

    pub fn clear_session_configuration(&mut self) {
        self.session_configuration = ::std::option::Option::None;
    }

    pub fn has_session_configuration(&self) -> bool {
        self.session_configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_configuration(&mut self, v: i32) {
        self.session_configuration = ::std::option::Option::Some(v);
    }

    // optional string display_name = 14;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool probe_for_support = 15;

    pub fn probe_for_support(&self) -> bool {
        self.probe_for_support.unwrap_or(false)
    }

    pub fn clear_probe_for_support(&mut self) {
        self.probe_for_support = ::std::option::Option::None;
    }

    pub fn has_probe_for_support(&self) -> bool {
        self.probe_for_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_probe_for_support(&mut self, v: bool) {
        self.probe_for_support = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services",
            |m: &ServiceDiscoveryResponse| { &m.services },
            |m: &mut ServiceDiscoveryResponse| { &mut m.services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "make",
            |m: &ServiceDiscoveryResponse| { &m.make },
            |m: &mut ServiceDiscoveryResponse| { &mut m.make },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "model",
            |m: &ServiceDiscoveryResponse| { &m.model },
            |m: &mut ServiceDiscoveryResponse| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "year",
            |m: &ServiceDiscoveryResponse| { &m.year },
            |m: &mut ServiceDiscoveryResponse| { &mut m.year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vehicle_id",
            |m: &ServiceDiscoveryResponse| { &m.vehicle_id },
            |m: &mut ServiceDiscoveryResponse| { &mut m.vehicle_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver_position",
            |m: &ServiceDiscoveryResponse| { &m.driver_position },
            |m: &mut ServiceDiscoveryResponse| { &mut m.driver_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "head_unit_make",
            |m: &ServiceDiscoveryResponse| { &m.head_unit_make },
            |m: &mut ServiceDiscoveryResponse| { &mut m.head_unit_make },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "head_unit_model",
            |m: &ServiceDiscoveryResponse| { &m.head_unit_model },
            |m: &mut ServiceDiscoveryResponse| { &mut m.head_unit_model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "head_unit_software_build",
            |m: &ServiceDiscoveryResponse| { &m.head_unit_software_build },
            |m: &mut ServiceDiscoveryResponse| { &mut m.head_unit_software_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "head_unit_software_version",
            |m: &ServiceDiscoveryResponse| { &m.head_unit_software_version },
            |m: &mut ServiceDiscoveryResponse| { &mut m.head_unit_software_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_play_native_media_during_vr",
            |m: &ServiceDiscoveryResponse| { &m.can_play_native_media_during_vr },
            |m: &mut ServiceDiscoveryResponse| { &mut m.can_play_native_media_during_vr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_configuration",
            |m: &ServiceDiscoveryResponse| { &m.session_configuration },
            |m: &mut ServiceDiscoveryResponse| { &mut m.session_configuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &ServiceDiscoveryResponse| { &m.display_name },
            |m: &mut ServiceDiscoveryResponse| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "probe_for_support",
            |m: &ServiceDiscoveryResponse| { &m.probe_for_support },
            |m: &mut ServiceDiscoveryResponse| { &mut m.probe_for_support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectionConfiguration>(
            "connection_configuration",
            |m: &ServiceDiscoveryResponse| { &m.connection_configuration },
            |m: &mut ServiceDiscoveryResponse| { &mut m.connection_configuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::HeadUnitInfo>(
            "headunit_info",
            |m: &ServiceDiscoveryResponse| { &m.headunit_info },
            |m: &mut ServiceDiscoveryResponse| { &mut m.headunit_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDiscoveryResponse>(
            "ServiceDiscoveryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceDiscoveryResponse {
    const NAME: &'static str = "ServiceDiscoveryResponse";

    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connection_configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headunit_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.services.push(is.read_message()?);
                },
                18 => {
                    self.make = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.model = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.year = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.vehicle_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.driver_position = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.head_unit_make = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.head_unit_model = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.head_unit_software_build = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.head_unit_software_version = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.can_play_native_media_during_vr = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.session_configuration = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                120 => {
                    self.probe_for_support = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connection_configuration)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.headunit_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.make.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.year.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.vehicle_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.driver_position {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.head_unit_make.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.head_unit_model.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.head_unit_software_build.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.head_unit_software_version.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.can_play_native_media_during_vr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.session_configuration {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.probe_for_support {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connection_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.headunit_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.services {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.make.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.model.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.year.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.vehicle_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.driver_position {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.head_unit_make.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.head_unit_model.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.head_unit_software_build.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.head_unit_software_version.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.can_play_native_media_during_vr {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.session_configuration {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.probe_for_support {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.connection_configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.headunit_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDiscoveryResponse {
        ServiceDiscoveryResponse::new()
    }

    fn clear(&mut self) {
        self.services.clear();
        self.make = ::std::option::Option::None;
        self.model = ::std::option::Option::None;
        self.year = ::std::option::Option::None;
        self.vehicle_id = ::std::option::Option::None;
        self.driver_position = ::std::option::Option::None;
        self.head_unit_make = ::std::option::Option::None;
        self.head_unit_model = ::std::option::Option::None;
        self.head_unit_software_build = ::std::option::Option::None;
        self.head_unit_software_version = ::std::option::Option::None;
        self.can_play_native_media_during_vr = ::std::option::Option::None;
        self.session_configuration = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.probe_for_support = ::std::option::Option::None;
        self.connection_configuration.clear();
        self.headunit_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDiscoveryResponse {
        static instance: ServiceDiscoveryResponse = ServiceDiscoveryResponse {
            services: ::std::vec::Vec::new(),
            make: ::std::option::Option::None,
            model: ::std::option::Option::None,
            year: ::std::option::Option::None,
            vehicle_id: ::std::option::Option::None,
            driver_position: ::std::option::Option::None,
            head_unit_make: ::std::option::Option::None,
            head_unit_model: ::std::option::Option::None,
            head_unit_software_build: ::std::option::Option::None,
            head_unit_software_version: ::std::option::Option::None,
            can_play_native_media_during_vr: ::std::option::Option::None,
            session_configuration: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            probe_for_support: ::std::option::Option::None,
            connection_configuration: ::protobuf::MessageField::none(),
            headunit_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceDiscoveryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceDiscoveryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceDiscoveryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceDiscoveryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ServiceDiscoveryUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceDiscoveryUpdate {
    // message fields
    // @@protoc_insertion_point(field:ServiceDiscoveryUpdate.service)
    pub service: ::protobuf::MessageField<Service>,
    // special fields
    // @@protoc_insertion_point(special_field:ServiceDiscoveryUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDiscoveryUpdate {
    fn default() -> &'a ServiceDiscoveryUpdate {
        <ServiceDiscoveryUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ServiceDiscoveryUpdate {
    pub fn new() -> ServiceDiscoveryUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Service>(
            "service",
            |m: &ServiceDiscoveryUpdate| { &m.service },
            |m: &mut ServiceDiscoveryUpdate| { &mut m.service },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDiscoveryUpdate>(
            "ServiceDiscoveryUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceDiscoveryUpdate {
    const NAME: &'static str = "ServiceDiscoveryUpdate";

    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.service)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDiscoveryUpdate {
        ServiceDiscoveryUpdate::new()
    }

    fn clear(&mut self) {
        self.service.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDiscoveryUpdate {
        static instance: ServiceDiscoveryUpdate = ServiceDiscoveryUpdate {
            service: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceDiscoveryUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceDiscoveryUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceDiscoveryUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceDiscoveryUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Service)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Service {
    // message fields
    // @@protoc_insertion_point(field:Service.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Service.sensor_source_service)
    pub sensor_source_service: ::protobuf::MessageField<SensorSourceService>,
    // @@protoc_insertion_point(field:Service.media_sink_service)
    pub media_sink_service: ::protobuf::MessageField<MediaSinkService>,
    // @@protoc_insertion_point(field:Service.input_source_service)
    pub input_source_service: ::protobuf::MessageField<InputSourceService>,
    // @@protoc_insertion_point(field:Service.media_source_service)
    pub media_source_service: ::protobuf::MessageField<MediaSourceService>,
    // @@protoc_insertion_point(field:Service.bluetooth_service)
    pub bluetooth_service: ::protobuf::MessageField<BluetoothService>,
    // @@protoc_insertion_point(field:Service.radio_service)
    pub radio_service: ::protobuf::MessageField<RadioService>,
    // @@protoc_insertion_point(field:Service.navigation_status_service)
    pub navigation_status_service: ::protobuf::MessageField<NavigationStatusService>,
    // @@protoc_insertion_point(field:Service.media_playback_service)
    pub media_playback_service: ::protobuf::MessageField<MediaPlaybackStatusService>,
    // @@protoc_insertion_point(field:Service.phone_status_service)
    pub phone_status_service: ::protobuf::MessageField<PhoneStatusService>,
    // @@protoc_insertion_point(field:Service.media_browser_service)
    pub media_browser_service: ::protobuf::MessageField<MediaBrowserService>,
    // @@protoc_insertion_point(field:Service.vendor_extension_service)
    pub vendor_extension_service: ::protobuf::MessageField<VendorExtensionService>,
    // @@protoc_insertion_point(field:Service.generic_notification_service)
    pub generic_notification_service: ::protobuf::MessageField<GenericNotificationService>,
    // @@protoc_insertion_point(field:Service.wifi_projection_service)
    pub wifi_projection_service: ::protobuf::MessageField<WifiProjectionService>,
    // special fields
    // @@protoc_insertion_point(special_field:Service.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // required int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Service| { &m.id },
            |m: &mut Service| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SensorSourceService>(
            "sensor_source_service",
            |m: &Service| { &m.sensor_source_service },
            |m: &mut Service| { &mut m.sensor_source_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaSinkService>(
            "media_sink_service",
            |m: &Service| { &m.media_sink_service },
            |m: &mut Service| { &mut m.media_sink_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InputSourceService>(
            "input_source_service",
            |m: &Service| { &m.input_source_service },
            |m: &mut Service| { &mut m.input_source_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaSourceService>(
            "media_source_service",
            |m: &Service| { &m.media_source_service },
            |m: &mut Service| { &mut m.media_source_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BluetoothService>(
            "bluetooth_service",
            |m: &Service| { &m.bluetooth_service },
            |m: &mut Service| { &mut m.bluetooth_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RadioService>(
            "radio_service",
            |m: &Service| { &m.radio_service },
            |m: &mut Service| { &mut m.radio_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationStatusService>(
            "navigation_status_service",
            |m: &Service| { &m.navigation_status_service },
            |m: &mut Service| { &mut m.navigation_status_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaPlaybackStatusService>(
            "media_playback_service",
            |m: &Service| { &m.media_playback_service },
            |m: &mut Service| { &mut m.media_playback_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhoneStatusService>(
            "phone_status_service",
            |m: &Service| { &m.phone_status_service },
            |m: &mut Service| { &mut m.phone_status_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaBrowserService>(
            "media_browser_service",
            |m: &Service| { &m.media_browser_service },
            |m: &mut Service| { &mut m.media_browser_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VendorExtensionService>(
            "vendor_extension_service",
            |m: &Service| { &m.vendor_extension_service },
            |m: &mut Service| { &mut m.vendor_extension_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GenericNotificationService>(
            "generic_notification_service",
            |m: &Service| { &m.generic_notification_service },
            |m: &mut Service| { &mut m.generic_notification_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WifiProjectionService>(
            "wifi_projection_service",
            |m: &Service| { &m.wifi_projection_service },
            |m: &mut Service| { &mut m.wifi_projection_service },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Service>(
            "Service",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Service {
    const NAME: &'static str = "Service";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.sensor_source_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media_sink_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_source_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media_source_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bluetooth_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.radio_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.navigation_status_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media_playback_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phone_status_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media_browser_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vendor_extension_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generic_notification_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wifi_projection_service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sensor_source_service)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.media_sink_service)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_source_service)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.media_source_service)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bluetooth_service)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.radio_service)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.navigation_status_service)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.media_playback_service)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.phone_status_service)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.media_browser_service)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vendor_extension_service)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.generic_notification_service)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wifi_projection_service)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sensor_source_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.media_sink_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input_source_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.media_source_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bluetooth_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radio_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.navigation_status_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.media_playback_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phone_status_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.media_browser_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vendor_extension_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.generic_notification_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wifi_projection_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sensor_source_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.media_sink_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.input_source_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.media_source_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.bluetooth_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.radio_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.navigation_status_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.media_playback_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.phone_status_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.media_browser_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.vendor_extension_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.generic_notification_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.wifi_projection_service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Service {
        Service::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.sensor_source_service.clear();
        self.media_sink_service.clear();
        self.input_source_service.clear();
        self.media_source_service.clear();
        self.bluetooth_service.clear();
        self.radio_service.clear();
        self.navigation_status_service.clear();
        self.media_playback_service.clear();
        self.phone_status_service.clear();
        self.media_browser_service.clear();
        self.vendor_extension_service.clear();
        self.generic_notification_service.clear();
        self.wifi_projection_service.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Service {
        static instance: Service = Service {
            id: ::std::option::Option::None,
            sensor_source_service: ::protobuf::MessageField::none(),
            media_sink_service: ::protobuf::MessageField::none(),
            input_source_service: ::protobuf::MessageField::none(),
            media_source_service: ::protobuf::MessageField::none(),
            bluetooth_service: ::protobuf::MessageField::none(),
            radio_service: ::protobuf::MessageField::none(),
            navigation_status_service: ::protobuf::MessageField::none(),
            media_playback_service: ::protobuf::MessageField::none(),
            phone_status_service: ::protobuf::MessageField::none(),
            media_browser_service: ::protobuf::MessageField::none(),
            vendor_extension_service: ::protobuf::MessageField::none(),
            generic_notification_service: ::protobuf::MessageField::none(),
            wifi_projection_service: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Service {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Service").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ConnectionConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectionConfiguration {
    // message fields
    // @@protoc_insertion_point(field:ConnectionConfiguration.ping_configuration)
    pub ping_configuration: ::protobuf::MessageField<PingConfiguration>,
    // @@protoc_insertion_point(field:ConnectionConfiguration.wireless_tcp_configuration)
    pub wireless_tcp_configuration: ::protobuf::MessageField<WirelessTcpConfiguration>,
    // special fields
    // @@protoc_insertion_point(special_field:ConnectionConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectionConfiguration {
    fn default() -> &'a ConnectionConfiguration {
        <ConnectionConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionConfiguration {
    pub fn new() -> ConnectionConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PingConfiguration>(
            "ping_configuration",
            |m: &ConnectionConfiguration| { &m.ping_configuration },
            |m: &mut ConnectionConfiguration| { &mut m.ping_configuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WirelessTcpConfiguration>(
            "wireless_tcp_configuration",
            |m: &ConnectionConfiguration| { &m.wireless_tcp_configuration },
            |m: &mut ConnectionConfiguration| { &mut m.wireless_tcp_configuration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectionConfiguration>(
            "ConnectionConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectionConfiguration {
    const NAME: &'static str = "ConnectionConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_configuration)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wireless_tcp_configuration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ping_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wireless_tcp_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ping_configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.wireless_tcp_configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectionConfiguration {
        ConnectionConfiguration::new()
    }

    fn clear(&mut self) {
        self.ping_configuration.clear();
        self.wireless_tcp_configuration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectionConfiguration {
        static instance: ConnectionConfiguration = ConnectionConfiguration {
            ping_configuration: ::protobuf::MessageField::none(),
            wireless_tcp_configuration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectionConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectionConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectionConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PingConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingConfiguration {
    // message fields
    // @@protoc_insertion_point(field:PingConfiguration.timeout_ms)
    pub timeout_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PingConfiguration.interval_ms)
    pub interval_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PingConfiguration.high_latency_threshold_ms)
    pub high_latency_threshold_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PingConfiguration.tracked_ping_count)
    pub tracked_ping_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PingConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingConfiguration {
    fn default() -> &'a PingConfiguration {
        <PingConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl PingConfiguration {
    pub fn new() -> PingConfiguration {
        ::std::default::Default::default()
    }

    // optional uint32 timeout_ms = 1;

    pub fn timeout_ms(&self) -> u32 {
        self.timeout_ms.unwrap_or(0)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: u32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 interval_ms = 2;

    pub fn interval_ms(&self) -> u32 {
        self.interval_ms.unwrap_or(0)
    }

    pub fn clear_interval_ms(&mut self) {
        self.interval_ms = ::std::option::Option::None;
    }

    pub fn has_interval_ms(&self) -> bool {
        self.interval_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_ms(&mut self, v: u32) {
        self.interval_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 high_latency_threshold_ms = 3;

    pub fn high_latency_threshold_ms(&self) -> u32 {
        self.high_latency_threshold_ms.unwrap_or(0)
    }

    pub fn clear_high_latency_threshold_ms(&mut self) {
        self.high_latency_threshold_ms = ::std::option::Option::None;
    }

    pub fn has_high_latency_threshold_ms(&self) -> bool {
        self.high_latency_threshold_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_latency_threshold_ms(&mut self, v: u32) {
        self.high_latency_threshold_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 tracked_ping_count = 4;

    pub fn tracked_ping_count(&self) -> u32 {
        self.tracked_ping_count.unwrap_or(0)
    }

    pub fn clear_tracked_ping_count(&mut self) {
        self.tracked_ping_count = ::std::option::Option::None;
    }

    pub fn has_tracked_ping_count(&self) -> bool {
        self.tracked_ping_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracked_ping_count(&mut self, v: u32) {
        self.tracked_ping_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout_ms",
            |m: &PingConfiguration| { &m.timeout_ms },
            |m: &mut PingConfiguration| { &mut m.timeout_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "interval_ms",
            |m: &PingConfiguration| { &m.interval_ms },
            |m: &mut PingConfiguration| { &mut m.interval_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_latency_threshold_ms",
            |m: &PingConfiguration| { &m.high_latency_threshold_ms },
            |m: &mut PingConfiguration| { &mut m.high_latency_threshold_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tracked_ping_count",
            |m: &PingConfiguration| { &m.tracked_ping_count },
            |m: &mut PingConfiguration| { &mut m.tracked_ping_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingConfiguration>(
            "PingConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingConfiguration {
    const NAME: &'static str = "PingConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timeout_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.interval_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.high_latency_threshold_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tracked_ping_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeout_ms {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.interval_ms {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.high_latency_threshold_ms {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tracked_ping_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timeout_ms {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.interval_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.high_latency_threshold_ms {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tracked_ping_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingConfiguration {
        PingConfiguration::new()
    }

    fn clear(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
        self.interval_ms = ::std::option::Option::None;
        self.high_latency_threshold_ms = ::std::option::Option::None;
        self.tracked_ping_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingConfiguration {
        static instance: PingConfiguration = PingConfiguration {
            timeout_ms: ::std::option::Option::None,
            interval_ms: ::std::option::Option::None,
            high_latency_threshold_ms: ::std::option::Option::None,
            tracked_ping_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:WirelessTcpConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WirelessTcpConfiguration {
    // message fields
    // @@protoc_insertion_point(field:WirelessTcpConfiguration.socket_receive_buffer_size_kb)
    pub socket_receive_buffer_size_kb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WirelessTcpConfiguration.socket_send_buffer_size_kb)
    pub socket_send_buffer_size_kb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WirelessTcpConfiguration.socket_read_timeout_ms)
    pub socket_read_timeout_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:WirelessTcpConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WirelessTcpConfiguration {
    fn default() -> &'a WirelessTcpConfiguration {
        <WirelessTcpConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl WirelessTcpConfiguration {
    pub fn new() -> WirelessTcpConfiguration {
        ::std::default::Default::default()
    }

    // optional uint32 socket_receive_buffer_size_kb = 1;

    pub fn socket_receive_buffer_size_kb(&self) -> u32 {
        self.socket_receive_buffer_size_kb.unwrap_or(0)
    }

    pub fn clear_socket_receive_buffer_size_kb(&mut self) {
        self.socket_receive_buffer_size_kb = ::std::option::Option::None;
    }

    pub fn has_socket_receive_buffer_size_kb(&self) -> bool {
        self.socket_receive_buffer_size_kb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_receive_buffer_size_kb(&mut self, v: u32) {
        self.socket_receive_buffer_size_kb = ::std::option::Option::Some(v);
    }

    // optional uint32 socket_send_buffer_size_kb = 2;

    pub fn socket_send_buffer_size_kb(&self) -> u32 {
        self.socket_send_buffer_size_kb.unwrap_or(0)
    }

    pub fn clear_socket_send_buffer_size_kb(&mut self) {
        self.socket_send_buffer_size_kb = ::std::option::Option::None;
    }

    pub fn has_socket_send_buffer_size_kb(&self) -> bool {
        self.socket_send_buffer_size_kb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_send_buffer_size_kb(&mut self, v: u32) {
        self.socket_send_buffer_size_kb = ::std::option::Option::Some(v);
    }

    // optional uint32 socket_read_timeout_ms = 3;

    pub fn socket_read_timeout_ms(&self) -> u32 {
        self.socket_read_timeout_ms.unwrap_or(0)
    }

    pub fn clear_socket_read_timeout_ms(&mut self) {
        self.socket_read_timeout_ms = ::std::option::Option::None;
    }

    pub fn has_socket_read_timeout_ms(&self) -> bool {
        self.socket_read_timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_read_timeout_ms(&mut self, v: u32) {
        self.socket_read_timeout_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "socket_receive_buffer_size_kb",
            |m: &WirelessTcpConfiguration| { &m.socket_receive_buffer_size_kb },
            |m: &mut WirelessTcpConfiguration| { &mut m.socket_receive_buffer_size_kb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "socket_send_buffer_size_kb",
            |m: &WirelessTcpConfiguration| { &m.socket_send_buffer_size_kb },
            |m: &mut WirelessTcpConfiguration| { &mut m.socket_send_buffer_size_kb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "socket_read_timeout_ms",
            |m: &WirelessTcpConfiguration| { &m.socket_read_timeout_ms },
            |m: &mut WirelessTcpConfiguration| { &mut m.socket_read_timeout_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WirelessTcpConfiguration>(
            "WirelessTcpConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WirelessTcpConfiguration {
    const NAME: &'static str = "WirelessTcpConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.socket_receive_buffer_size_kb = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.socket_send_buffer_size_kb = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.socket_read_timeout_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket_receive_buffer_size_kb {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.socket_send_buffer_size_kb {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.socket_read_timeout_ms {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.socket_receive_buffer_size_kb {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.socket_send_buffer_size_kb {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.socket_read_timeout_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WirelessTcpConfiguration {
        WirelessTcpConfiguration::new()
    }

    fn clear(&mut self) {
        self.socket_receive_buffer_size_kb = ::std::option::Option::None;
        self.socket_send_buffer_size_kb = ::std::option::Option::None;
        self.socket_read_timeout_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WirelessTcpConfiguration {
        static instance: WirelessTcpConfiguration = WirelessTcpConfiguration {
            socket_receive_buffer_size_kb: ::std::option::Option::None,
            socket_send_buffer_size_kb: ::std::option::Option::None,
            socket_read_timeout_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WirelessTcpConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WirelessTcpConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WirelessTcpConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WirelessTcpConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SensorSourceService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SensorSourceService {
    // message fields
    // @@protoc_insertion_point(field:SensorSourceService.sensors)
    pub sensors: ::std::vec::Vec<sensor_source_service::Sensor>,
    // @@protoc_insertion_point(field:SensorSourceService.location_characterization)
    pub location_characterization: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SensorSourceService.supported_fuel_types)
    pub supported_fuel_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<FuelType>>,
    // @@protoc_insertion_point(field:SensorSourceService.supported_ev_connector_types)
    pub supported_ev_connector_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<EvConnectorType>>,
    // special fields
    // @@protoc_insertion_point(special_field:SensorSourceService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SensorSourceService {
    fn default() -> &'a SensorSourceService {
        <SensorSourceService as ::protobuf::Message>::default_instance()
    }
}

impl SensorSourceService {
    pub fn new() -> SensorSourceService {
        ::std::default::Default::default()
    }

    // optional uint32 location_characterization = 2;

    pub fn location_characterization(&self) -> u32 {
        self.location_characterization.unwrap_or(0)
    }

    pub fn clear_location_characterization(&mut self) {
        self.location_characterization = ::std::option::Option::None;
    }

    pub fn has_location_characterization(&self) -> bool {
        self.location_characterization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_characterization(&mut self, v: u32) {
        self.location_characterization = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sensors",
            |m: &SensorSourceService| { &m.sensors },
            |m: &mut SensorSourceService| { &mut m.sensors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location_characterization",
            |m: &SensorSourceService| { &m.location_characterization },
            |m: &mut SensorSourceService| { &mut m.location_characterization },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_fuel_types",
            |m: &SensorSourceService| { &m.supported_fuel_types },
            |m: &mut SensorSourceService| { &mut m.supported_fuel_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_ev_connector_types",
            |m: &SensorSourceService| { &m.supported_ev_connector_types },
            |m: &mut SensorSourceService| { &mut m.supported_ev_connector_types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorSourceService>(
            "SensorSourceService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorSourceService {
    const NAME: &'static str = "SensorSourceService";

    fn is_initialized(&self) -> bool {
        for v in &self.sensors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sensors.push(is.read_message()?);
                },
                16 => {
                    self.location_characterization = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.supported_fuel_types.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_fuel_types)?
                },
                32 => {
                    self.supported_ev_connector_types.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_ev_connector_types)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location_characterization {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.supported_fuel_types {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        for value in &self.supported_ev_connector_types {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sensors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.location_characterization {
            os.write_uint32(2, v)?;
        }
        for v in &self.supported_fuel_types {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.supported_ev_connector_types {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorSourceService {
        SensorSourceService::new()
    }

    fn clear(&mut self) {
        self.sensors.clear();
        self.location_characterization = ::std::option::Option::None;
        self.supported_fuel_types.clear();
        self.supported_ev_connector_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorSourceService {
        static instance: SensorSourceService = SensorSourceService {
            sensors: ::std::vec::Vec::new(),
            location_characterization: ::std::option::Option::None,
            supported_fuel_types: ::std::vec::Vec::new(),
            supported_ev_connector_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorSourceService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorSourceService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SensorSourceService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorSourceService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SensorSourceService`
pub mod sensor_source_service {
    // @@protoc_insertion_point(message:SensorSourceService.Sensor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sensor {
        // message fields
        // @@protoc_insertion_point(field:SensorSourceService.Sensor.sensor_type)
        pub sensor_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::SensorType>>,
        // special fields
        // @@protoc_insertion_point(special_field:SensorSourceService.Sensor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sensor {
        fn default() -> &'a Sensor {
            <Sensor as ::protobuf::Message>::default_instance()
        }
    }

    impl Sensor {
        pub fn new() -> Sensor {
            ::std::default::Default::default()
        }

        // required .SensorType sensor_type = 1;

        pub fn sensor_type(&self) -> super::SensorType {
            match self.sensor_type {
                Some(e) => e.enum_value_or(super::SensorType::SENSOR_LOCATION),
                None => super::SensorType::SENSOR_LOCATION,
            }
        }

        pub fn clear_sensor_type(&mut self) {
            self.sensor_type = ::std::option::Option::None;
        }

        pub fn has_sensor_type(&self) -> bool {
            self.sensor_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sensor_type(&mut self, v: super::SensorType) {
            self.sensor_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sensor_type",
                |m: &Sensor| { &m.sensor_type },
                |m: &mut Sensor| { &mut m.sensor_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sensor>(
                "SensorSourceService.Sensor",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sensor {
        const NAME: &'static str = "Sensor";

        fn is_initialized(&self) -> bool {
            if self.sensor_type.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sensor_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sensor_type {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sensor_type {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sensor {
            Sensor::new()
        }

        fn clear(&mut self) {
            self.sensor_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sensor {
            static instance: Sensor = Sensor {
                sensor_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sensor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SensorSourceService.Sensor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sensor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sensor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:MediaSinkService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaSinkService {
    // message fields
    // @@protoc_insertion_point(field:MediaSinkService.available_type)
    pub available_type: ::std::option::Option<::protobuf::EnumOrUnknown<MediaCodecType>>,
    // @@protoc_insertion_point(field:MediaSinkService.audio_type)
    pub audio_type: ::std::option::Option<::protobuf::EnumOrUnknown<AudioStreamType>>,
    // @@protoc_insertion_point(field:MediaSinkService.audio_configs)
    pub audio_configs: ::std::vec::Vec<AudioConfiguration>,
    // @@protoc_insertion_point(field:MediaSinkService.video_configs)
    pub video_configs: ::std::vec::Vec<VideoConfiguration>,
    // @@protoc_insertion_point(field:MediaSinkService.available_while_in_call)
    pub available_while_in_call: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MediaSinkService.display_id)
    pub display_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MediaSinkService.display_type)
    pub display_type: ::std::option::Option<::protobuf::EnumOrUnknown<DisplayType>>,
    // @@protoc_insertion_point(field:MediaSinkService.initial_content_keycode)
    pub initial_content_keycode: ::std::option::Option<::protobuf::EnumOrUnknown<KeyCode>>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaSinkService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaSinkService {
    fn default() -> &'a MediaSinkService {
        <MediaSinkService as ::protobuf::Message>::default_instance()
    }
}

impl MediaSinkService {
    pub fn new() -> MediaSinkService {
        ::std::default::Default::default()
    }

    // optional .MediaCodecType available_type = 1;

    pub fn available_type(&self) -> MediaCodecType {
        match self.available_type {
            Some(e) => e.enum_value_or(MediaCodecType::MEDIA_CODEC_AUDIO_PCM),
            None => MediaCodecType::MEDIA_CODEC_AUDIO_PCM,
        }
    }

    pub fn clear_available_type(&mut self) {
        self.available_type = ::std::option::Option::None;
    }

    pub fn has_available_type(&self) -> bool {
        self.available_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_type(&mut self, v: MediaCodecType) {
        self.available_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .AudioStreamType audio_type = 2;

    pub fn audio_type(&self) -> AudioStreamType {
        match self.audio_type {
            Some(e) => e.enum_value_or(AudioStreamType::AUDIO_STREAM_GUIDANCE),
            None => AudioStreamType::AUDIO_STREAM_GUIDANCE,
        }
    }

    pub fn clear_audio_type(&mut self) {
        self.audio_type = ::std::option::Option::None;
    }

    pub fn has_audio_type(&self) -> bool {
        self.audio_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_type(&mut self, v: AudioStreamType) {
        self.audio_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool available_while_in_call = 5;

    pub fn available_while_in_call(&self) -> bool {
        self.available_while_in_call.unwrap_or(false)
    }

    pub fn clear_available_while_in_call(&mut self) {
        self.available_while_in_call = ::std::option::Option::None;
    }

    pub fn has_available_while_in_call(&self) -> bool {
        self.available_while_in_call.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_while_in_call(&mut self, v: bool) {
        self.available_while_in_call = ::std::option::Option::Some(v);
    }

    // optional uint32 display_id = 6;

    pub fn display_id(&self) -> u32 {
        self.display_id.unwrap_or(0)
    }

    pub fn clear_display_id(&mut self) {
        self.display_id = ::std::option::Option::None;
    }

    pub fn has_display_id(&self) -> bool {
        self.display_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_id(&mut self, v: u32) {
        self.display_id = ::std::option::Option::Some(v);
    }

    // optional .DisplayType display_type = 7;

    pub fn display_type(&self) -> DisplayType {
        match self.display_type {
            Some(e) => e.enum_value_or(DisplayType::DISPLAY_TYPE_MAIN),
            None => DisplayType::DISPLAY_TYPE_MAIN,
        }
    }

    pub fn clear_display_type(&mut self) {
        self.display_type = ::std::option::Option::None;
    }

    pub fn has_display_type(&self) -> bool {
        self.display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_type(&mut self, v: DisplayType) {
        self.display_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .KeyCode initial_content_keycode = 8;

    pub fn initial_content_keycode(&self) -> KeyCode {
        match self.initial_content_keycode {
            Some(e) => e.enum_value_or(KeyCode::KEYCODE_UNKNOWN),
            None => KeyCode::KEYCODE_UNKNOWN,
        }
    }

    pub fn clear_initial_content_keycode(&mut self) {
        self.initial_content_keycode = ::std::option::Option::None;
    }

    pub fn has_initial_content_keycode(&self) -> bool {
        self.initial_content_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_content_keycode(&mut self, v: KeyCode) {
        self.initial_content_keycode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available_type",
            |m: &MediaSinkService| { &m.available_type },
            |m: &mut MediaSinkService| { &mut m.available_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_type",
            |m: &MediaSinkService| { &m.audio_type },
            |m: &mut MediaSinkService| { &mut m.audio_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "audio_configs",
            |m: &MediaSinkService| { &m.audio_configs },
            |m: &mut MediaSinkService| { &mut m.audio_configs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "video_configs",
            |m: &MediaSinkService| { &m.video_configs },
            |m: &mut MediaSinkService| { &mut m.video_configs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available_while_in_call",
            |m: &MediaSinkService| { &m.available_while_in_call },
            |m: &mut MediaSinkService| { &mut m.available_while_in_call },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_id",
            |m: &MediaSinkService| { &m.display_id },
            |m: &mut MediaSinkService| { &mut m.display_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_type",
            |m: &MediaSinkService| { &m.display_type },
            |m: &mut MediaSinkService| { &mut m.display_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_content_keycode",
            |m: &MediaSinkService| { &m.initial_content_keycode },
            |m: &mut MediaSinkService| { &mut m.initial_content_keycode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaSinkService>(
            "MediaSinkService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaSinkService {
    const NAME: &'static str = "MediaSinkService";

    fn is_initialized(&self) -> bool {
        for v in &self.audio_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.video_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.available_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.audio_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.audio_configs.push(is.read_message()?);
                },
                34 => {
                    self.video_configs.push(is.read_message()?);
                },
                40 => {
                    self.available_while_in_call = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.display_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.display_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.initial_content_keycode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.available_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.audio_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.audio_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.video_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.available_while_in_call {
            my_size += 1 + 1;
        }
        if let Some(v) = self.display_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.display_type {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.initial_content_keycode {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.available_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audio_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.audio_configs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.video_configs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.available_while_in_call {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.display_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.display_type {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.initial_content_keycode {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaSinkService {
        MediaSinkService::new()
    }

    fn clear(&mut self) {
        self.available_type = ::std::option::Option::None;
        self.audio_type = ::std::option::Option::None;
        self.audio_configs.clear();
        self.video_configs.clear();
        self.available_while_in_call = ::std::option::Option::None;
        self.display_id = ::std::option::Option::None;
        self.display_type = ::std::option::Option::None;
        self.initial_content_keycode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaSinkService {
        static instance: MediaSinkService = MediaSinkService {
            available_type: ::std::option::Option::None,
            audio_type: ::std::option::Option::None,
            audio_configs: ::std::vec::Vec::new(),
            video_configs: ::std::vec::Vec::new(),
            available_while_in_call: ::std::option::Option::None,
            display_id: ::std::option::Option::None,
            display_type: ::std::option::Option::None,
            initial_content_keycode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaSinkService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaSinkService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaSinkService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaSinkService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VideoConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoConfiguration {
    // message fields
    // @@protoc_insertion_point(field:VideoConfiguration.codec_resolution)
    pub codec_resolution: ::std::option::Option<::protobuf::EnumOrUnknown<VideoCodecResolutionType>>,
    // @@protoc_insertion_point(field:VideoConfiguration.frame_rate)
    pub frame_rate: ::std::option::Option<::protobuf::EnumOrUnknown<VideoFrameRateType>>,
    // @@protoc_insertion_point(field:VideoConfiguration.width_margin)
    pub width_margin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.height_margin)
    pub height_margin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.density)
    pub density: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.decoder_additional_depth)
    pub decoder_additional_depth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.viewing_distance)
    pub viewing_distance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.pixel_aspect_ratio_e4)
    pub pixel_aspect_ratio_e4: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.real_density)
    pub real_density: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoConfiguration.video_codec_type)
    pub video_codec_type: ::std::option::Option<::protobuf::EnumOrUnknown<MediaCodecType>>,
    // @@protoc_insertion_point(field:VideoConfiguration.ui_config)
    pub ui_config: ::protobuf::MessageField<UiConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:VideoConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoConfiguration {
    fn default() -> &'a VideoConfiguration {
        <VideoConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl VideoConfiguration {
    pub fn new() -> VideoConfiguration {
        ::std::default::Default::default()
    }

    // optional .VideoCodecResolutionType codec_resolution = 1;

    pub fn codec_resolution(&self) -> VideoCodecResolutionType {
        match self.codec_resolution {
            Some(e) => e.enum_value_or(VideoCodecResolutionType::VIDEO_800x480),
            None => VideoCodecResolutionType::VIDEO_800x480,
        }
    }

    pub fn clear_codec_resolution(&mut self) {
        self.codec_resolution = ::std::option::Option::None;
    }

    pub fn has_codec_resolution(&self) -> bool {
        self.codec_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_resolution(&mut self, v: VideoCodecResolutionType) {
        self.codec_resolution = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .VideoFrameRateType frame_rate = 2;

    pub fn frame_rate(&self) -> VideoFrameRateType {
        match self.frame_rate {
            Some(e) => e.enum_value_or(VideoFrameRateType::VIDEO_FPS_60),
            None => VideoFrameRateType::VIDEO_FPS_60,
        }
    }

    pub fn clear_frame_rate(&mut self) {
        self.frame_rate = ::std::option::Option::None;
    }

    pub fn has_frame_rate(&self) -> bool {
        self.frame_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_rate(&mut self, v: VideoFrameRateType) {
        self.frame_rate = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 width_margin = 3;

    pub fn width_margin(&self) -> u32 {
        self.width_margin.unwrap_or(0)
    }

    pub fn clear_width_margin(&mut self) {
        self.width_margin = ::std::option::Option::None;
    }

    pub fn has_width_margin(&self) -> bool {
        self.width_margin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width_margin(&mut self, v: u32) {
        self.width_margin = ::std::option::Option::Some(v);
    }

    // optional uint32 height_margin = 4;

    pub fn height_margin(&self) -> u32 {
        self.height_margin.unwrap_or(0)
    }

    pub fn clear_height_margin(&mut self) {
        self.height_margin = ::std::option::Option::None;
    }

    pub fn has_height_margin(&self) -> bool {
        self.height_margin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height_margin(&mut self, v: u32) {
        self.height_margin = ::std::option::Option::Some(v);
    }

    // optional uint32 density = 5;

    pub fn density(&self) -> u32 {
        self.density.unwrap_or(0)
    }

    pub fn clear_density(&mut self) {
        self.density = ::std::option::Option::None;
    }

    pub fn has_density(&self) -> bool {
        self.density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_density(&mut self, v: u32) {
        self.density = ::std::option::Option::Some(v);
    }

    // optional uint32 decoder_additional_depth = 6;

    pub fn decoder_additional_depth(&self) -> u32 {
        self.decoder_additional_depth.unwrap_or(0)
    }

    pub fn clear_decoder_additional_depth(&mut self) {
        self.decoder_additional_depth = ::std::option::Option::None;
    }

    pub fn has_decoder_additional_depth(&self) -> bool {
        self.decoder_additional_depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decoder_additional_depth(&mut self, v: u32) {
        self.decoder_additional_depth = ::std::option::Option::Some(v);
    }

    // optional uint32 viewing_distance = 7;

    pub fn viewing_distance(&self) -> u32 {
        self.viewing_distance.unwrap_or(0)
    }

    pub fn clear_viewing_distance(&mut self) {
        self.viewing_distance = ::std::option::Option::None;
    }

    pub fn has_viewing_distance(&self) -> bool {
        self.viewing_distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewing_distance(&mut self, v: u32) {
        self.viewing_distance = ::std::option::Option::Some(v);
    }

    // optional uint32 pixel_aspect_ratio_e4 = 8;

    pub fn pixel_aspect_ratio_e4(&self) -> u32 {
        self.pixel_aspect_ratio_e4.unwrap_or(0)
    }

    pub fn clear_pixel_aspect_ratio_e4(&mut self) {
        self.pixel_aspect_ratio_e4 = ::std::option::Option::None;
    }

    pub fn has_pixel_aspect_ratio_e4(&self) -> bool {
        self.pixel_aspect_ratio_e4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pixel_aspect_ratio_e4(&mut self, v: u32) {
        self.pixel_aspect_ratio_e4 = ::std::option::Option::Some(v);
    }

    // optional uint32 real_density = 9;

    pub fn real_density(&self) -> u32 {
        self.real_density.unwrap_or(0)
    }

    pub fn clear_real_density(&mut self) {
        self.real_density = ::std::option::Option::None;
    }

    pub fn has_real_density(&self) -> bool {
        self.real_density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_density(&mut self, v: u32) {
        self.real_density = ::std::option::Option::Some(v);
    }

    // optional .MediaCodecType video_codec_type = 10;

    pub fn video_codec_type(&self) -> MediaCodecType {
        match self.video_codec_type {
            Some(e) => e.enum_value_or(MediaCodecType::MEDIA_CODEC_AUDIO_PCM),
            None => MediaCodecType::MEDIA_CODEC_AUDIO_PCM,
        }
    }

    pub fn clear_video_codec_type(&mut self) {
        self.video_codec_type = ::std::option::Option::None;
    }

    pub fn has_video_codec_type(&self) -> bool {
        self.video_codec_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_codec_type(&mut self, v: MediaCodecType) {
        self.video_codec_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec_resolution",
            |m: &VideoConfiguration| { &m.codec_resolution },
            |m: &mut VideoConfiguration| { &mut m.codec_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_rate",
            |m: &VideoConfiguration| { &m.frame_rate },
            |m: &mut VideoConfiguration| { &mut m.frame_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width_margin",
            |m: &VideoConfiguration| { &m.width_margin },
            |m: &mut VideoConfiguration| { &mut m.width_margin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height_margin",
            |m: &VideoConfiguration| { &m.height_margin },
            |m: &mut VideoConfiguration| { &mut m.height_margin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "density",
            |m: &VideoConfiguration| { &m.density },
            |m: &mut VideoConfiguration| { &mut m.density },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decoder_additional_depth",
            |m: &VideoConfiguration| { &m.decoder_additional_depth },
            |m: &mut VideoConfiguration| { &mut m.decoder_additional_depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewing_distance",
            |m: &VideoConfiguration| { &m.viewing_distance },
            |m: &mut VideoConfiguration| { &mut m.viewing_distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pixel_aspect_ratio_e4",
            |m: &VideoConfiguration| { &m.pixel_aspect_ratio_e4 },
            |m: &mut VideoConfiguration| { &mut m.pixel_aspect_ratio_e4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_density",
            |m: &VideoConfiguration| { &m.real_density },
            |m: &mut VideoConfiguration| { &mut m.real_density },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_codec_type",
            |m: &VideoConfiguration| { &m.video_codec_type },
            |m: &mut VideoConfiguration| { &mut m.video_codec_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UiConfig>(
            "ui_config",
            |m: &VideoConfiguration| { &m.ui_config },
            |m: &mut VideoConfiguration| { &mut m.ui_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoConfiguration>(
            "VideoConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoConfiguration {
    const NAME: &'static str = "VideoConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.codec_resolution = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.frame_rate = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.width_margin = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height_margin = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.density = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.decoder_additional_depth = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.viewing_distance = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.pixel_aspect_ratio_e4 = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.real_density = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.video_codec_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.codec_resolution {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.frame_rate {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.width_margin {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height_margin {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.density {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.decoder_additional_depth {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.viewing_distance {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.pixel_aspect_ratio_e4 {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.real_density {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.video_codec_type {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.ui_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.codec_resolution {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frame_rate {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.width_margin {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height_margin {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.density {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.decoder_additional_depth {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.viewing_distance {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.pixel_aspect_ratio_e4 {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.real_density {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.video_codec_type {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ui_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoConfiguration {
        VideoConfiguration::new()
    }

    fn clear(&mut self) {
        self.codec_resolution = ::std::option::Option::None;
        self.frame_rate = ::std::option::Option::None;
        self.width_margin = ::std::option::Option::None;
        self.height_margin = ::std::option::Option::None;
        self.density = ::std::option::Option::None;
        self.decoder_additional_depth = ::std::option::Option::None;
        self.viewing_distance = ::std::option::Option::None;
        self.pixel_aspect_ratio_e4 = ::std::option::Option::None;
        self.real_density = ::std::option::Option::None;
        self.video_codec_type = ::std::option::Option::None;
        self.ui_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoConfiguration {
        static instance: VideoConfiguration = VideoConfiguration {
            codec_resolution: ::std::option::Option::None,
            frame_rate: ::std::option::Option::None,
            width_margin: ::std::option::Option::None,
            height_margin: ::std::option::Option::None,
            density: ::std::option::Option::None,
            decoder_additional_depth: ::std::option::Option::None,
            viewing_distance: ::std::option::Option::None,
            pixel_aspect_ratio_e4: ::std::option::Option::None,
            real_density: ::std::option::Option::None,
            video_codec_type: ::std::option::Option::None,
            ui_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UiConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UiConfig {
    // message fields
    // @@protoc_insertion_point(field:UiConfig.margins)
    pub margins: ::protobuf::MessageField<Insets>,
    // @@protoc_insertion_point(field:UiConfig.content_insets)
    pub content_insets: ::protobuf::MessageField<Insets>,
    // @@protoc_insertion_point(field:UiConfig.stable_content_insets)
    pub stable_content_insets: ::protobuf::MessageField<Insets>,
    // @@protoc_insertion_point(field:UiConfig.ui_theme)
    pub ui_theme: ::std::option::Option<::protobuf::EnumOrUnknown<UiTheme>>,
    // special fields
    // @@protoc_insertion_point(special_field:UiConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UiConfig {
    fn default() -> &'a UiConfig {
        <UiConfig as ::protobuf::Message>::default_instance()
    }
}

impl UiConfig {
    pub fn new() -> UiConfig {
        ::std::default::Default::default()
    }

    // optional .UiTheme ui_theme = 4;

    pub fn ui_theme(&self) -> UiTheme {
        match self.ui_theme {
            Some(e) => e.enum_value_or(UiTheme::UI_THEME_AUTOMATIC),
            None => UiTheme::UI_THEME_AUTOMATIC,
        }
    }

    pub fn clear_ui_theme(&mut self) {
        self.ui_theme = ::std::option::Option::None;
    }

    pub fn has_ui_theme(&self) -> bool {
        self.ui_theme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_theme(&mut self, v: UiTheme) {
        self.ui_theme = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Insets>(
            "margins",
            |m: &UiConfig| { &m.margins },
            |m: &mut UiConfig| { &mut m.margins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Insets>(
            "content_insets",
            |m: &UiConfig| { &m.content_insets },
            |m: &mut UiConfig| { &mut m.content_insets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Insets>(
            "stable_content_insets",
            |m: &UiConfig| { &m.stable_content_insets },
            |m: &mut UiConfig| { &mut m.stable_content_insets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ui_theme",
            |m: &UiConfig| { &m.ui_theme },
            |m: &mut UiConfig| { &mut m.ui_theme },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UiConfig>(
            "UiConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UiConfig {
    const NAME: &'static str = "UiConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.margins)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.content_insets)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stable_content_insets)?;
                },
                32 => {
                    self.ui_theme = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.margins.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.content_insets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stable_content_insets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_theme {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.margins.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.content_insets.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.stable_content_insets.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.ui_theme {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UiConfig {
        UiConfig::new()
    }

    fn clear(&mut self) {
        self.margins.clear();
        self.content_insets.clear();
        self.stable_content_insets.clear();
        self.ui_theme = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UiConfig {
        static instance: UiConfig = UiConfig {
            margins: ::protobuf::MessageField::none(),
            content_insets: ::protobuf::MessageField::none(),
            stable_content_insets: ::protobuf::MessageField::none(),
            ui_theme: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UiConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UiConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UiConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UiConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Insets)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Insets {
    // message fields
    // @@protoc_insertion_point(field:Insets.top)
    pub top: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Insets.bottom)
    pub bottom: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Insets.left)
    pub left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Insets.right)
    pub right: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:Insets.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Insets {
    fn default() -> &'a Insets {
        <Insets as ::protobuf::Message>::default_instance()
    }
}

impl Insets {
    pub fn new() -> Insets {
        ::std::default::Default::default()
    }

    // optional uint32 top = 1;

    pub fn top(&self) -> u32 {
        self.top.unwrap_or(0)
    }

    pub fn clear_top(&mut self) {
        self.top = ::std::option::Option::None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: u32) {
        self.top = ::std::option::Option::Some(v);
    }

    // optional uint32 bottom = 2;

    pub fn bottom(&self) -> u32 {
        self.bottom.unwrap_or(0)
    }

    pub fn clear_bottom(&mut self) {
        self.bottom = ::std::option::Option::None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: u32) {
        self.bottom = ::std::option::Option::Some(v);
    }

    // optional uint32 left = 3;

    pub fn left(&self) -> u32 {
        self.left.unwrap_or(0)
    }

    pub fn clear_left(&mut self) {
        self.left = ::std::option::Option::None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: u32) {
        self.left = ::std::option::Option::Some(v);
    }

    // optional uint32 right = 4;

    pub fn right(&self) -> u32 {
        self.right.unwrap_or(0)
    }

    pub fn clear_right(&mut self) {
        self.right = ::std::option::Option::None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: u32) {
        self.right = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "top",
            |m: &Insets| { &m.top },
            |m: &mut Insets| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bottom",
            |m: &Insets| { &m.bottom },
            |m: &mut Insets| { &mut m.bottom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "left",
            |m: &Insets| { &m.left },
            |m: &mut Insets| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "right",
            |m: &Insets| { &m.right },
            |m: &mut Insets| { &mut m.right },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Insets>(
            "Insets",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Insets {
    const NAME: &'static str = "Insets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.top = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.bottom = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.left = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.right = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.top {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bottom {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.left {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.right {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.top {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bottom {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.left {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.right {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Insets {
        Insets::new()
    }

    fn clear(&mut self) {
        self.top = ::std::option::Option::None;
        self.bottom = ::std::option::Option::None;
        self.left = ::std::option::Option::None;
        self.right = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Insets {
        static instance: Insets = Insets {
            top: ::std::option::Option::None,
            bottom: ::std::option::Option::None,
            left: ::std::option::Option::None,
            right: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Insets {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Insets").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Insets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Insets {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaSourceService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaSourceService {
    // message fields
    // @@protoc_insertion_point(field:MediaSourceService.available_type)
    pub available_type: ::std::option::Option<::protobuf::EnumOrUnknown<MediaCodecType>>,
    // @@protoc_insertion_point(field:MediaSourceService.audio_config)
    pub audio_config: ::protobuf::MessageField<AudioConfiguration>,
    // @@protoc_insertion_point(field:MediaSourceService.available_while_in_call)
    pub available_while_in_call: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaSourceService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaSourceService {
    fn default() -> &'a MediaSourceService {
        <MediaSourceService as ::protobuf::Message>::default_instance()
    }
}

impl MediaSourceService {
    pub fn new() -> MediaSourceService {
        ::std::default::Default::default()
    }

    // optional .MediaCodecType available_type = 1;

    pub fn available_type(&self) -> MediaCodecType {
        match self.available_type {
            Some(e) => e.enum_value_or(MediaCodecType::MEDIA_CODEC_AUDIO_PCM),
            None => MediaCodecType::MEDIA_CODEC_AUDIO_PCM,
        }
    }

    pub fn clear_available_type(&mut self) {
        self.available_type = ::std::option::Option::None;
    }

    pub fn has_available_type(&self) -> bool {
        self.available_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_type(&mut self, v: MediaCodecType) {
        self.available_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool available_while_in_call = 3;

    pub fn available_while_in_call(&self) -> bool {
        self.available_while_in_call.unwrap_or(false)
    }

    pub fn clear_available_while_in_call(&mut self) {
        self.available_while_in_call = ::std::option::Option::None;
    }

    pub fn has_available_while_in_call(&self) -> bool {
        self.available_while_in_call.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_while_in_call(&mut self, v: bool) {
        self.available_while_in_call = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available_type",
            |m: &MediaSourceService| { &m.available_type },
            |m: &mut MediaSourceService| { &mut m.available_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AudioConfiguration>(
            "audio_config",
            |m: &MediaSourceService| { &m.audio_config },
            |m: &mut MediaSourceService| { &mut m.audio_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "available_while_in_call",
            |m: &MediaSourceService| { &m.available_while_in_call },
            |m: &mut MediaSourceService| { &mut m.available_while_in_call },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaSourceService>(
            "MediaSourceService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaSourceService {
    const NAME: &'static str = "MediaSourceService";

    fn is_initialized(&self) -> bool {
        for v in &self.audio_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.available_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio_config)?;
                },
                24 => {
                    self.available_while_in_call = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.available_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.audio_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.available_while_in_call {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.available_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audio_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.available_while_in_call {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaSourceService {
        MediaSourceService::new()
    }

    fn clear(&mut self) {
        self.available_type = ::std::option::Option::None;
        self.audio_config.clear();
        self.available_while_in_call = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaSourceService {
        static instance: MediaSourceService = MediaSourceService {
            available_type: ::std::option::Option::None,
            audio_config: ::protobuf::MessageField::none(),
            available_while_in_call: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaSourceService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaSourceService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaSourceService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaSourceService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AudioConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioConfiguration {
    // message fields
    // @@protoc_insertion_point(field:AudioConfiguration.sampling_rate)
    pub sampling_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AudioConfiguration.number_of_bits)
    pub number_of_bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AudioConfiguration.number_of_channels)
    pub number_of_channels: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:AudioConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioConfiguration {
    fn default() -> &'a AudioConfiguration {
        <AudioConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl AudioConfiguration {
    pub fn new() -> AudioConfiguration {
        ::std::default::Default::default()
    }

    // required uint32 sampling_rate = 1;

    pub fn sampling_rate(&self) -> u32 {
        self.sampling_rate.unwrap_or(0)
    }

    pub fn clear_sampling_rate(&mut self) {
        self.sampling_rate = ::std::option::Option::None;
    }

    pub fn has_sampling_rate(&self) -> bool {
        self.sampling_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sampling_rate(&mut self, v: u32) {
        self.sampling_rate = ::std::option::Option::Some(v);
    }

    // required uint32 number_of_bits = 2;

    pub fn number_of_bits(&self) -> u32 {
        self.number_of_bits.unwrap_or(0)
    }

    pub fn clear_number_of_bits(&mut self) {
        self.number_of_bits = ::std::option::Option::None;
    }

    pub fn has_number_of_bits(&self) -> bool {
        self.number_of_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_bits(&mut self, v: u32) {
        self.number_of_bits = ::std::option::Option::Some(v);
    }

    // required uint32 number_of_channels = 3;

    pub fn number_of_channels(&self) -> u32 {
        self.number_of_channels.unwrap_or(0)
    }

    pub fn clear_number_of_channels(&mut self) {
        self.number_of_channels = ::std::option::Option::None;
    }

    pub fn has_number_of_channels(&self) -> bool {
        self.number_of_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_channels(&mut self, v: u32) {
        self.number_of_channels = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sampling_rate",
            |m: &AudioConfiguration| { &m.sampling_rate },
            |m: &mut AudioConfiguration| { &mut m.sampling_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_bits",
            |m: &AudioConfiguration| { &m.number_of_bits },
            |m: &mut AudioConfiguration| { &mut m.number_of_bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_channels",
            |m: &AudioConfiguration| { &m.number_of_channels },
            |m: &mut AudioConfiguration| { &mut m.number_of_channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioConfiguration>(
            "AudioConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioConfiguration {
    const NAME: &'static str = "AudioConfiguration";

    fn is_initialized(&self) -> bool {
        if self.sampling_rate.is_none() {
            return false;
        }
        if self.number_of_bits.is_none() {
            return false;
        }
        if self.number_of_channels.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sampling_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.number_of_bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.number_of_channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sampling_rate {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.number_of_bits {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.number_of_channels {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sampling_rate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.number_of_bits {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.number_of_channels {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioConfiguration {
        AudioConfiguration::new()
    }

    fn clear(&mut self) {
        self.sampling_rate = ::std::option::Option::None;
        self.number_of_bits = ::std::option::Option::None;
        self.number_of_channels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioConfiguration {
        static instance: AudioConfiguration = AudioConfiguration {
            sampling_rate: ::std::option::Option::None,
            number_of_bits: ::std::option::Option::None,
            number_of_channels: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:InputSourceService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputSourceService {
    // message fields
    // @@protoc_insertion_point(field:InputSourceService.keycodes_supported)
    pub keycodes_supported: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:InputSourceService.touchscreen)
    pub touchscreen: ::std::vec::Vec<input_source_service::TouchScreen>,
    // @@protoc_insertion_point(field:InputSourceService.touchpad)
    pub touchpad: ::std::vec::Vec<input_source_service::TouchPad>,
    // @@protoc_insertion_point(field:InputSourceService.feedback_events_supported)
    pub feedback_events_supported: ::std::vec::Vec<::protobuf::EnumOrUnknown<FeedbackEvent>>,
    // @@protoc_insertion_point(field:InputSourceService.display_id)
    pub display_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:InputSourceService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputSourceService {
    fn default() -> &'a InputSourceService {
        <InputSourceService as ::protobuf::Message>::default_instance()
    }
}

impl InputSourceService {
    pub fn new() -> InputSourceService {
        ::std::default::Default::default()
    }

    // optional uint32 display_id = 5;

    pub fn display_id(&self) -> u32 {
        self.display_id.unwrap_or(0)
    }

    pub fn clear_display_id(&mut self) {
        self.display_id = ::std::option::Option::None;
    }

    pub fn has_display_id(&self) -> bool {
        self.display_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_id(&mut self, v: u32) {
        self.display_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keycodes_supported",
            |m: &InputSourceService| { &m.keycodes_supported },
            |m: &mut InputSourceService| { &mut m.keycodes_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "touchscreen",
            |m: &InputSourceService| { &m.touchscreen },
            |m: &mut InputSourceService| { &mut m.touchscreen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "touchpad",
            |m: &InputSourceService| { &m.touchpad },
            |m: &mut InputSourceService| { &mut m.touchpad },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "feedback_events_supported",
            |m: &InputSourceService| { &m.feedback_events_supported },
            |m: &mut InputSourceService| { &mut m.feedback_events_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_id",
            |m: &InputSourceService| { &m.display_id },
            |m: &mut InputSourceService| { &mut m.display_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputSourceService>(
            "InputSourceService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputSourceService {
    const NAME: &'static str = "InputSourceService";

    fn is_initialized(&self) -> bool {
        for v in &self.touchscreen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.touchpad {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.keycodes_supported)?;
                },
                8 => {
                    self.keycodes_supported.push(is.read_int32()?);
                },
                18 => {
                    self.touchscreen.push(is.read_message()?);
                },
                26 => {
                    self.touchpad.push(is.read_message()?);
                },
                32 => {
                    self.feedback_events_supported.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.feedback_events_supported)?
                },
                40 => {
                    self.display_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        //my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.keycodes_supported);
        for value in &self.keycodes_supported {
            my_size += ::protobuf::rt::int32_size(1, *value);
        }
        for value in &self.touchscreen {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.touchpad {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.feedback_events_supported {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        if let Some(v) = self.display_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        //os.write_repeated_packed_int32(1, &self.keycodes_supported)?;
        for v in &self.keycodes_supported {
            os.write_int32(1, *v)?;
        }
        for v in &self.touchscreen {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.touchpad {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.feedback_events_supported {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.display_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputSourceService {
        InputSourceService::new()
    }

    fn clear(&mut self) {
        self.keycodes_supported.clear();
        self.touchscreen.clear();
        self.touchpad.clear();
        self.feedback_events_supported.clear();
        self.display_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputSourceService {
        static instance: InputSourceService = InputSourceService {
            keycodes_supported: ::std::vec::Vec::new(),
            touchscreen: ::std::vec::Vec::new(),
            touchpad: ::std::vec::Vec::new(),
            feedback_events_supported: ::std::vec::Vec::new(),
            display_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputSourceService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputSourceService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputSourceService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputSourceService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InputSourceService`
pub mod input_source_service {
    // @@protoc_insertion_point(message:InputSourceService.TouchScreen)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TouchScreen {
        // message fields
        // @@protoc_insertion_point(field:InputSourceService.TouchScreen.width)
        pub width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:InputSourceService.TouchScreen.height)
        pub height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:InputSourceService.TouchScreen.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<super::TouchScreenType>>,
        // @@protoc_insertion_point(field:InputSourceService.TouchScreen.is_secondary)
        pub is_secondary: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:InputSourceService.TouchScreen.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TouchScreen {
        fn default() -> &'a TouchScreen {
            <TouchScreen as ::protobuf::Message>::default_instance()
        }
    }

    impl TouchScreen {
        pub fn new() -> TouchScreen {
            ::std::default::Default::default()
        }

        // required int32 width = 1;

        pub fn width(&self) -> i32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: i32) {
            self.width = ::std::option::Option::Some(v);
        }

        // required int32 height = 2;

        pub fn height(&self) -> i32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: i32) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional .TouchScreenType type = 3;

        pub fn type_(&self) -> super::TouchScreenType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::TouchScreenType::CAPACITIVE),
                None => super::TouchScreenType::CAPACITIVE,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::TouchScreenType) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool is_secondary = 4;

        pub fn is_secondary(&self) -> bool {
            self.is_secondary.unwrap_or(false)
        }

        pub fn clear_is_secondary(&mut self) {
            self.is_secondary = ::std::option::Option::None;
        }

        pub fn has_is_secondary(&self) -> bool {
            self.is_secondary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_secondary(&mut self, v: bool) {
            self.is_secondary = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &TouchScreen| { &m.width },
                |m: &mut TouchScreen| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &TouchScreen| { &m.height },
                |m: &mut TouchScreen| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &TouchScreen| { &m.type_ },
                |m: &mut TouchScreen| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_secondary",
                |m: &TouchScreen| { &m.is_secondary },
                |m: &mut TouchScreen| { &mut m.is_secondary },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchScreen>(
                "InputSourceService.TouchScreen",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TouchScreen {
        const NAME: &'static str = "TouchScreen";

        fn is_initialized(&self) -> bool {
            if self.width.is_none() {
                return false;
            }
            if self.height.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.is_secondary = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.is_secondary {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.width {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.height {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.is_secondary {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TouchScreen {
            TouchScreen::new()
        }

        fn clear(&mut self) {
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.is_secondary = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TouchScreen {
            static instance: TouchScreen = TouchScreen {
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                is_secondary: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TouchScreen {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InputSourceService.TouchScreen").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TouchScreen {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TouchScreen {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:InputSourceService.TouchPad)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TouchPad {
        // message fields
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.width)
        pub width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.height)
        pub height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.ui_navigation)
        pub ui_navigation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.physical_width)
        pub physical_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.physical_height)
        pub physical_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.ui_absolute)
        pub ui_absolute: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.tap_as_select)
        pub tap_as_select: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:InputSourceService.TouchPad.sensitivity)
        pub sensitivity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:InputSourceService.TouchPad.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TouchPad {
        fn default() -> &'a TouchPad {
            <TouchPad as ::protobuf::Message>::default_instance()
        }
    }

    impl TouchPad {
        pub fn new() -> TouchPad {
            ::std::default::Default::default()
        }

        // required int32 width = 1;

        pub fn width(&self) -> i32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: i32) {
            self.width = ::std::option::Option::Some(v);
        }

        // required int32 height = 2;

        pub fn height(&self) -> i32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: i32) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional bool ui_navigation = 3;

        pub fn ui_navigation(&self) -> bool {
            self.ui_navigation.unwrap_or(false)
        }

        pub fn clear_ui_navigation(&mut self) {
            self.ui_navigation = ::std::option::Option::None;
        }

        pub fn has_ui_navigation(&self) -> bool {
            self.ui_navigation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ui_navigation(&mut self, v: bool) {
            self.ui_navigation = ::std::option::Option::Some(v);
        }

        // optional int32 physical_width = 4;

        pub fn physical_width(&self) -> i32 {
            self.physical_width.unwrap_or(0)
        }

        pub fn clear_physical_width(&mut self) {
            self.physical_width = ::std::option::Option::None;
        }

        pub fn has_physical_width(&self) -> bool {
            self.physical_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_physical_width(&mut self, v: i32) {
            self.physical_width = ::std::option::Option::Some(v);
        }

        // optional int32 physical_height = 5;

        pub fn physical_height(&self) -> i32 {
            self.physical_height.unwrap_or(0)
        }

        pub fn clear_physical_height(&mut self) {
            self.physical_height = ::std::option::Option::None;
        }

        pub fn has_physical_height(&self) -> bool {
            self.physical_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_physical_height(&mut self, v: i32) {
            self.physical_height = ::std::option::Option::Some(v);
        }

        // optional bool ui_absolute = 6;

        pub fn ui_absolute(&self) -> bool {
            self.ui_absolute.unwrap_or(false)
        }

        pub fn clear_ui_absolute(&mut self) {
            self.ui_absolute = ::std::option::Option::None;
        }

        pub fn has_ui_absolute(&self) -> bool {
            self.ui_absolute.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ui_absolute(&mut self, v: bool) {
            self.ui_absolute = ::std::option::Option::Some(v);
        }

        // optional bool tap_as_select = 7;

        pub fn tap_as_select(&self) -> bool {
            self.tap_as_select.unwrap_or(false)
        }

        pub fn clear_tap_as_select(&mut self) {
            self.tap_as_select = ::std::option::Option::None;
        }

        pub fn has_tap_as_select(&self) -> bool {
            self.tap_as_select.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tap_as_select(&mut self, v: bool) {
            self.tap_as_select = ::std::option::Option::Some(v);
        }

        // optional int32 sensitivity = 8;

        pub fn sensitivity(&self) -> i32 {
            self.sensitivity.unwrap_or(0)
        }

        pub fn clear_sensitivity(&mut self) {
            self.sensitivity = ::std::option::Option::None;
        }

        pub fn has_sensitivity(&self) -> bool {
            self.sensitivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sensitivity(&mut self, v: i32) {
            self.sensitivity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &TouchPad| { &m.width },
                |m: &mut TouchPad| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &TouchPad| { &m.height },
                |m: &mut TouchPad| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ui_navigation",
                |m: &TouchPad| { &m.ui_navigation },
                |m: &mut TouchPad| { &mut m.ui_navigation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "physical_width",
                |m: &TouchPad| { &m.physical_width },
                |m: &mut TouchPad| { &mut m.physical_width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "physical_height",
                |m: &TouchPad| { &m.physical_height },
                |m: &mut TouchPad| { &mut m.physical_height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ui_absolute",
                |m: &TouchPad| { &m.ui_absolute },
                |m: &mut TouchPad| { &mut m.ui_absolute },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tap_as_select",
                |m: &TouchPad| { &m.tap_as_select },
                |m: &mut TouchPad| { &mut m.tap_as_select },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sensitivity",
                |m: &TouchPad| { &m.sensitivity },
                |m: &mut TouchPad| { &mut m.sensitivity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchPad>(
                "InputSourceService.TouchPad",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TouchPad {
        const NAME: &'static str = "TouchPad";

        fn is_initialized(&self) -> bool {
            if self.width.is_none() {
                return false;
            }
            if self.height.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.ui_navigation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.physical_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.physical_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.ui_absolute = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.tap_as_select = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.sensitivity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.ui_navigation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.physical_width {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.physical_height {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.ui_absolute {
                my_size += 1 + 1;
            }
            if let Some(v) = self.tap_as_select {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sensitivity {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.width {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.height {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.ui_navigation {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.physical_width {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.physical_height {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.ui_absolute {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.tap_as_select {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.sensitivity {
                os.write_int32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TouchPad {
            TouchPad::new()
        }

        fn clear(&mut self) {
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.ui_navigation = ::std::option::Option::None;
            self.physical_width = ::std::option::Option::None;
            self.physical_height = ::std::option::Option::None;
            self.ui_absolute = ::std::option::Option::None;
            self.tap_as_select = ::std::option::Option::None;
            self.sensitivity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TouchPad {
            static instance: TouchPad = TouchPad {
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                ui_navigation: ::std::option::Option::None,
                physical_width: ::std::option::Option::None,
                physical_height: ::std::option::Option::None,
                ui_absolute: ::std::option::Option::None,
                tap_as_select: ::std::option::Option::None,
                sensitivity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TouchPad {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InputSourceService.TouchPad").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TouchPad {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TouchPad {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:BluetoothService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothService {
    // message fields
    // @@protoc_insertion_point(field:BluetoothService.car_address)
    pub car_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:BluetoothService.supported_pairing_methods)
    pub supported_pairing_methods: ::std::vec::Vec<::protobuf::EnumOrUnknown<BluetoothPairingMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothService {
    fn default() -> &'a BluetoothService {
        <BluetoothService as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothService {
    pub fn new() -> BluetoothService {
        ::std::default::Default::default()
    }

    // required string car_address = 1;

    pub fn car_address(&self) -> &str {
        match self.car_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_car_address(&mut self) {
        self.car_address = ::std::option::Option::None;
    }

    pub fn has_car_address(&self) -> bool {
        self.car_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_car_address(&mut self, v: ::std::string::String) {
        self.car_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_car_address(&mut self) -> &mut ::std::string::String {
        if self.car_address.is_none() {
            self.car_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.car_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_car_address(&mut self) -> ::std::string::String {
        self.car_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "car_address",
            |m: &BluetoothService| { &m.car_address },
            |m: &mut BluetoothService| { &mut m.car_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_pairing_methods",
            |m: &BluetoothService| { &m.supported_pairing_methods },
            |m: &mut BluetoothService| { &mut m.supported_pairing_methods },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothService>(
            "BluetoothService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothService {
    const NAME: &'static str = "BluetoothService";

    fn is_initialized(&self) -> bool {
        if self.car_address.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.car_address = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.supported_pairing_methods.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_pairing_methods)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.car_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(2, &self.supported_pairing_methods);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.car_address.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_repeated_packed_enum_or_unknown(2, &self.supported_pairing_methods)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothService {
        BluetoothService::new()
    }

    fn clear(&mut self) {
        self.car_address = ::std::option::Option::None;
        self.supported_pairing_methods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothService {
        static instance: BluetoothService = BluetoothService {
            car_address: ::std::option::Option::None,
            supported_pairing_methods: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioService {
    // message fields
    // @@protoc_insertion_point(field:RadioService.radio_properties)
    pub radio_properties: ::std::vec::Vec<RadioProperties>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioService {
    fn default() -> &'a RadioService {
        <RadioService as ::protobuf::Message>::default_instance()
    }
}

impl RadioService {
    pub fn new() -> RadioService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "radio_properties",
            |m: &RadioService| { &m.radio_properties },
            |m: &mut RadioService| { &mut m.radio_properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioService>(
            "RadioService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioService {
    const NAME: &'static str = "RadioService";

    fn is_initialized(&self) -> bool {
        for v in &self.radio_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.radio_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.radio_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.radio_properties {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioService {
        RadioService::new()
    }

    fn clear(&mut self) {
        self.radio_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioService {
        static instance: RadioService = RadioService {
            radio_properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioProperties)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioProperties {
    // message fields
    // @@protoc_insertion_point(field:RadioProperties.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioProperties.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<RadioType>>,
    // @@protoc_insertion_point(field:RadioProperties.channel_range)
    pub channel_range: ::std::vec::Vec<Range>,
    // @@protoc_insertion_point(field:RadioProperties.channel_spacings)
    pub channel_spacings: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RadioProperties.channel_spacing)
    pub channel_spacing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioProperties.background_tuner)
    pub background_tuner: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioProperties.region)
    pub region: ::std::option::Option<::protobuf::EnumOrUnknown<ItuRegion>>,
    // @@protoc_insertion_point(field:RadioProperties.rds)
    pub rds: ::std::option::Option<::protobuf::EnumOrUnknown<RdsType>>,
    // @@protoc_insertion_point(field:RadioProperties.af_switch)
    pub af_switch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioProperties.ta)
    pub ta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioProperties.traffic_service)
    pub traffic_service: ::std::option::Option<::protobuf::EnumOrUnknown<TrafficServiceType>>,
    // @@protoc_insertion_point(field:RadioProperties.audio_loopback)
    pub audio_loopback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioProperties.mute_capability)
    pub mute_capability: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioProperties.station_presets_access)
    pub station_presets_access: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioProperties.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioProperties {
    fn default() -> &'a RadioProperties {
        <RadioProperties as ::protobuf::Message>::default_instance()
    }
}

impl RadioProperties {
    pub fn new() -> RadioProperties {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required .RadioType type = 2;

    pub fn type_(&self) -> RadioType {
        match self.type_ {
            Some(e) => e.enum_value_or(RadioType::AM_RADIO),
            None => RadioType::AM_RADIO,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: RadioType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 channel_spacing = 5;

    pub fn channel_spacing(&self) -> i32 {
        self.channel_spacing.unwrap_or(0)
    }

    pub fn clear_channel_spacing(&mut self) {
        self.channel_spacing = ::std::option::Option::None;
    }

    pub fn has_channel_spacing(&self) -> bool {
        self.channel_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_spacing(&mut self, v: i32) {
        self.channel_spacing = ::std::option::Option::Some(v);
    }

    // optional bool background_tuner = 6;

    pub fn background_tuner(&self) -> bool {
        self.background_tuner.unwrap_or(false)
    }

    pub fn clear_background_tuner(&mut self) {
        self.background_tuner = ::std::option::Option::None;
    }

    pub fn has_background_tuner(&self) -> bool {
        self.background_tuner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background_tuner(&mut self, v: bool) {
        self.background_tuner = ::std::option::Option::Some(v);
    }

    // optional .ItuRegion region = 7;

    pub fn region(&self) -> ItuRegion {
        match self.region {
            Some(e) => e.enum_value_or(ItuRegion::RADIO_REGION_NONE),
            None => ItuRegion::RADIO_REGION_NONE,
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ItuRegion) {
        self.region = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .RdsType rds = 8;

    pub fn rds(&self) -> RdsType {
        match self.rds {
            Some(e) => e.enum_value_or(RdsType::NO_RDS),
            None => RdsType::NO_RDS,
        }
    }

    pub fn clear_rds(&mut self) {
        self.rds = ::std::option::Option::None;
    }

    pub fn has_rds(&self) -> bool {
        self.rds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rds(&mut self, v: RdsType) {
        self.rds = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool af_switch = 9;

    pub fn af_switch(&self) -> bool {
        self.af_switch.unwrap_or(false)
    }

    pub fn clear_af_switch(&mut self) {
        self.af_switch = ::std::option::Option::None;
    }

    pub fn has_af_switch(&self) -> bool {
        self.af_switch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_af_switch(&mut self, v: bool) {
        self.af_switch = ::std::option::Option::Some(v);
    }

    // optional bool ta = 10;

    pub fn ta(&self) -> bool {
        self.ta.unwrap_or(false)
    }

    pub fn clear_ta(&mut self) {
        self.ta = ::std::option::Option::None;
    }

    pub fn has_ta(&self) -> bool {
        self.ta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ta(&mut self, v: bool) {
        self.ta = ::std::option::Option::Some(v);
    }

    // optional .TrafficServiceType traffic_service = 11;

    pub fn traffic_service(&self) -> TrafficServiceType {
        match self.traffic_service {
            Some(e) => e.enum_value_or(TrafficServiceType::NO_TRAFFIC_SERVICE),
            None => TrafficServiceType::NO_TRAFFIC_SERVICE,
        }
    }

    pub fn clear_traffic_service(&mut self) {
        self.traffic_service = ::std::option::Option::None;
    }

    pub fn has_traffic_service(&self) -> bool {
        self.traffic_service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traffic_service(&mut self, v: TrafficServiceType) {
        self.traffic_service = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool audio_loopback = 12;

    pub fn audio_loopback(&self) -> bool {
        self.audio_loopback.unwrap_or(false)
    }

    pub fn clear_audio_loopback(&mut self) {
        self.audio_loopback = ::std::option::Option::None;
    }

    pub fn has_audio_loopback(&self) -> bool {
        self.audio_loopback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_loopback(&mut self, v: bool) {
        self.audio_loopback = ::std::option::Option::Some(v);
    }

    // optional bool mute_capability = 13;

    pub fn mute_capability(&self) -> bool {
        self.mute_capability.unwrap_or(false)
    }

    pub fn clear_mute_capability(&mut self) {
        self.mute_capability = ::std::option::Option::None;
    }

    pub fn has_mute_capability(&self) -> bool {
        self.mute_capability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mute_capability(&mut self, v: bool) {
        self.mute_capability = ::std::option::Option::Some(v);
    }

    // optional int32 station_presets_access = 14;

    pub fn station_presets_access(&self) -> i32 {
        self.station_presets_access.unwrap_or(0)
    }

    pub fn clear_station_presets_access(&mut self) {
        self.station_presets_access = ::std::option::Option::None;
    }

    pub fn has_station_presets_access(&self) -> bool {
        self.station_presets_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_presets_access(&mut self, v: i32) {
        self.station_presets_access = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &RadioProperties| { &m.radio_id },
            |m: &mut RadioProperties| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &RadioProperties| { &m.type_ },
            |m: &mut RadioProperties| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_range",
            |m: &RadioProperties| { &m.channel_range },
            |m: &mut RadioProperties| { &mut m.channel_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_spacings",
            |m: &RadioProperties| { &m.channel_spacings },
            |m: &mut RadioProperties| { &mut m.channel_spacings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_spacing",
            |m: &RadioProperties| { &m.channel_spacing },
            |m: &mut RadioProperties| { &mut m.channel_spacing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "background_tuner",
            |m: &RadioProperties| { &m.background_tuner },
            |m: &mut RadioProperties| { &mut m.background_tuner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region",
            |m: &RadioProperties| { &m.region },
            |m: &mut RadioProperties| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rds",
            |m: &RadioProperties| { &m.rds },
            |m: &mut RadioProperties| { &mut m.rds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "af_switch",
            |m: &RadioProperties| { &m.af_switch },
            |m: &mut RadioProperties| { &mut m.af_switch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ta",
            |m: &RadioProperties| { &m.ta },
            |m: &mut RadioProperties| { &mut m.ta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "traffic_service",
            |m: &RadioProperties| { &m.traffic_service },
            |m: &mut RadioProperties| { &mut m.traffic_service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_loopback",
            |m: &RadioProperties| { &m.audio_loopback },
            |m: &mut RadioProperties| { &mut m.audio_loopback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mute_capability",
            |m: &RadioProperties| { &m.mute_capability },
            |m: &mut RadioProperties| { &mut m.mute_capability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_presets_access",
            |m: &RadioProperties| { &m.station_presets_access },
            |m: &mut RadioProperties| { &mut m.station_presets_access },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioProperties>(
            "RadioProperties",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioProperties {
    const NAME: &'static str = "RadioProperties";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        if self.channel_spacing.is_none() {
            return false;
        }
        for v in &self.channel_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.channel_range.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.channel_spacings)?;
                },
                32 => {
                    self.channel_spacings.push(is.read_int32()?);
                },
                40 => {
                    self.channel_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.background_tuner = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.rds = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.af_switch = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.ta = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.traffic_service = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.audio_loopback = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.mute_capability = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.station_presets_access = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.channel_range {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.channel_spacings {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        if let Some(v) = self.channel_spacing {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.background_tuner {
            my_size += 1 + 1;
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.rds {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.af_switch {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.traffic_service {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.audio_loopback {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mute_capability {
            my_size += 1 + 1;
        }
        if let Some(v) = self.station_presets_access {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.channel_range {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.channel_spacings {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.channel_spacing {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.background_tuner {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.region {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rds {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.af_switch {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.ta {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.traffic_service {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audio_loopback {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.mute_capability {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.station_presets_access {
            os.write_int32(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioProperties {
        RadioProperties::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.channel_range.clear();
        self.channel_spacings.clear();
        self.channel_spacing = ::std::option::Option::None;
        self.background_tuner = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.rds = ::std::option::Option::None;
        self.af_switch = ::std::option::Option::None;
        self.ta = ::std::option::Option::None;
        self.traffic_service = ::std::option::Option::None;
        self.audio_loopback = ::std::option::Option::None;
        self.mute_capability = ::std::option::Option::None;
        self.station_presets_access = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioProperties {
        static instance: RadioProperties = RadioProperties {
            radio_id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            channel_range: ::std::vec::Vec::new(),
            channel_spacings: ::std::vec::Vec::new(),
            channel_spacing: ::std::option::Option::None,
            background_tuner: ::std::option::Option::None,
            region: ::std::option::Option::None,
            rds: ::std::option::Option::None,
            af_switch: ::std::option::Option::None,
            ta: ::std::option::Option::None,
            traffic_service: ::std::option::Option::None,
            audio_loopback: ::std::option::Option::None,
            mute_capability: ::std::option::Option::None,
            station_presets_access: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioProperties {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioProperties").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioProperties {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Range)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Range {
    // message fields
    // @@protoc_insertion_point(field:Range.min)
    pub min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Range.max)
    pub max: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:Range.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Range {
    fn default() -> &'a Range {
        <Range as ::protobuf::Message>::default_instance()
    }
}

impl Range {
    pub fn new() -> Range {
        ::std::default::Default::default()
    }

    // required int32 min = 1;

    pub fn min(&self) -> i32 {
        self.min.unwrap_or(0)
    }

    pub fn clear_min(&mut self) {
        self.min = ::std::option::Option::None;
    }

    pub fn has_min(&self) -> bool {
        self.min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: i32) {
        self.min = ::std::option::Option::Some(v);
    }

    // required int32 max = 2;

    pub fn max(&self) -> i32 {
        self.max.unwrap_or(0)
    }

    pub fn clear_max(&mut self) {
        self.max = ::std::option::Option::None;
    }

    pub fn has_max(&self) -> bool {
        self.max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: i32) {
        self.max = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min",
            |m: &Range| { &m.min },
            |m: &mut Range| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max",
            |m: &Range| { &m.max },
            |m: &mut Range| { &mut m.max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Range>(
            "Range",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Range {
    const NAME: &'static str = "Range";

    fn is_initialized(&self) -> bool {
        if self.min.is_none() {
            return false;
        }
        if self.max.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.min = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.max = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.min {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.max {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.min {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.max {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Range {
        Range::new()
    }

    fn clear(&mut self) {
        self.min = ::std::option::Option::None;
        self.max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Range {
        static instance: Range = Range {
            min: ::std::option::Option::None,
            max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Range {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Range").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Range {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationStatusService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationStatusService {
    // message fields
    // @@protoc_insertion_point(field:NavigationStatusService.minimum_interval_ms)
    pub minimum_interval_ms: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationStatusService.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_status_service::InstrumentClusterType>>,
    // @@protoc_insertion_point(field:NavigationStatusService.image_options)
    pub image_options: ::protobuf::MessageField<navigation_status_service::ImageOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationStatusService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationStatusService {
    fn default() -> &'a NavigationStatusService {
        <NavigationStatusService as ::protobuf::Message>::default_instance()
    }
}

impl NavigationStatusService {
    pub fn new() -> NavigationStatusService {
        ::std::default::Default::default()
    }

    // required int32 minimum_interval_ms = 1;

    pub fn minimum_interval_ms(&self) -> i32 {
        self.minimum_interval_ms.unwrap_or(0)
    }

    pub fn clear_minimum_interval_ms(&mut self) {
        self.minimum_interval_ms = ::std::option::Option::None;
    }

    pub fn has_minimum_interval_ms(&self) -> bool {
        self.minimum_interval_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_interval_ms(&mut self, v: i32) {
        self.minimum_interval_ms = ::std::option::Option::Some(v);
    }

    // required .NavigationStatusService.InstrumentClusterType type = 2;

    pub fn type_(&self) -> navigation_status_service::InstrumentClusterType {
        match self.type_ {
            Some(e) => e.enum_value_or(navigation_status_service::InstrumentClusterType::IMAGE),
            None => navigation_status_service::InstrumentClusterType::IMAGE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: navigation_status_service::InstrumentClusterType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum_interval_ms",
            |m: &NavigationStatusService| { &m.minimum_interval_ms },
            |m: &mut NavigationStatusService| { &mut m.minimum_interval_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &NavigationStatusService| { &m.type_ },
            |m: &mut NavigationStatusService| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, navigation_status_service::ImageOptions>(
            "image_options",
            |m: &NavigationStatusService| { &m.image_options },
            |m: &mut NavigationStatusService| { &mut m.image_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationStatusService>(
            "NavigationStatusService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationStatusService {
    const NAME: &'static str = "NavigationStatusService";

    fn is_initialized(&self) -> bool {
        if self.minimum_interval_ms.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        for v in &self.image_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minimum_interval_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum_interval_ms {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.image_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum_interval_ms {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationStatusService {
        NavigationStatusService::new()
    }

    fn clear(&mut self) {
        self.minimum_interval_ms = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.image_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationStatusService {
        static instance: NavigationStatusService = NavigationStatusService {
            minimum_interval_ms: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            image_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationStatusService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationStatusService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationStatusService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationStatusService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationStatusService`
pub mod navigation_status_service {
    // @@protoc_insertion_point(message:NavigationStatusService.ImageOptions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ImageOptions {
        // message fields
        // @@protoc_insertion_point(field:NavigationStatusService.ImageOptions.height)
        pub height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:NavigationStatusService.ImageOptions.width)
        pub width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:NavigationStatusService.ImageOptions.colour_depth_bits)
        pub colour_depth_bits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:NavigationStatusService.ImageOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ImageOptions {
        fn default() -> &'a ImageOptions {
            <ImageOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl ImageOptions {
        pub fn new() -> ImageOptions {
            ::std::default::Default::default()
        }

        // required int32 height = 1;

        pub fn height(&self) -> i32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: i32) {
            self.height = ::std::option::Option::Some(v);
        }

        // required int32 width = 2;

        pub fn width(&self) -> i32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: i32) {
            self.width = ::std::option::Option::Some(v);
        }

        // required int32 colour_depth_bits = 3;

        pub fn colour_depth_bits(&self) -> i32 {
            self.colour_depth_bits.unwrap_or(0)
        }

        pub fn clear_colour_depth_bits(&mut self) {
            self.colour_depth_bits = ::std::option::Option::None;
        }

        pub fn has_colour_depth_bits(&self) -> bool {
            self.colour_depth_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_colour_depth_bits(&mut self, v: i32) {
            self.colour_depth_bits = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &ImageOptions| { &m.height },
                |m: &mut ImageOptions| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &ImageOptions| { &m.width },
                |m: &mut ImageOptions| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "colour_depth_bits",
                |m: &ImageOptions| { &m.colour_depth_bits },
                |m: &mut ImageOptions| { &mut m.colour_depth_bits },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImageOptions>(
                "NavigationStatusService.ImageOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ImageOptions {
        const NAME: &'static str = "ImageOptions";

        fn is_initialized(&self) -> bool {
            if self.height.is_none() {
                return false;
            }
            if self.width.is_none() {
                return false;
            }
            if self.colour_depth_bits.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.colour_depth_bits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.height {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.width {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.colour_depth_bits {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.height {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.width {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.colour_depth_bits {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ImageOptions {
            ImageOptions::new()
        }

        fn clear(&mut self) {
            self.height = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.colour_depth_bits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ImageOptions {
            static instance: ImageOptions = ImageOptions {
                height: ::std::option::Option::None,
                width: ::std::option::Option::None,
                colour_depth_bits: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ImageOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NavigationStatusService.ImageOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ImageOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ImageOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationStatusService.InstrumentClusterType)
    pub enum InstrumentClusterType {
        // @@protoc_insertion_point(enum_value:NavigationStatusService.InstrumentClusterType.IMAGE)
        IMAGE = 1,
        // @@protoc_insertion_point(enum_value:NavigationStatusService.InstrumentClusterType.ENUM)
        ENUM = 2,
    }

    impl ::protobuf::Enum for InstrumentClusterType {
        const NAME: &'static str = "InstrumentClusterType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<InstrumentClusterType> {
            match value {
                1 => ::std::option::Option::Some(InstrumentClusterType::IMAGE),
                2 => ::std::option::Option::Some(InstrumentClusterType::ENUM),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<InstrumentClusterType> {
            match str {
                "IMAGE" => ::std::option::Option::Some(InstrumentClusterType::IMAGE),
                "ENUM" => ::std::option::Option::Some(InstrumentClusterType::ENUM),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [InstrumentClusterType] = &[
            InstrumentClusterType::IMAGE,
            InstrumentClusterType::ENUM,
        ];
    }

    impl ::protobuf::EnumFull for InstrumentClusterType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationStatusService.InstrumentClusterType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                InstrumentClusterType::IMAGE => 0,
                InstrumentClusterType::ENUM => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for InstrumentClusterType {
        fn default() -> Self {
            InstrumentClusterType::IMAGE
        }
    }

    impl InstrumentClusterType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InstrumentClusterType>("NavigationStatusService.InstrumentClusterType")
        }
    }
}

// @@protoc_insertion_point(message:MediaPlaybackStatusService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaPlaybackStatusService {
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlaybackStatusService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaPlaybackStatusService {
    fn default() -> &'a MediaPlaybackStatusService {
        <MediaPlaybackStatusService as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlaybackStatusService {
    pub fn new() -> MediaPlaybackStatusService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlaybackStatusService>(
            "MediaPlaybackStatusService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlaybackStatusService {
    const NAME: &'static str = "MediaPlaybackStatusService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlaybackStatusService {
        MediaPlaybackStatusService::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlaybackStatusService {
        static instance: MediaPlaybackStatusService = MediaPlaybackStatusService {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlaybackStatusService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlaybackStatusService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaPlaybackStatusService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlaybackStatusService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PhoneStatusService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PhoneStatusService {
    // special fields
    // @@protoc_insertion_point(special_field:PhoneStatusService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhoneStatusService {
    fn default() -> &'a PhoneStatusService {
        <PhoneStatusService as ::protobuf::Message>::default_instance()
    }
}

impl PhoneStatusService {
    pub fn new() -> PhoneStatusService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhoneStatusService>(
            "PhoneStatusService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhoneStatusService {
    const NAME: &'static str = "PhoneStatusService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhoneStatusService {
        PhoneStatusService::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhoneStatusService {
        static instance: PhoneStatusService = PhoneStatusService {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhoneStatusService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhoneStatusService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhoneStatusService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStatusService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaBrowserService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaBrowserService {
    // special fields
    // @@protoc_insertion_point(special_field:MediaBrowserService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaBrowserService {
    fn default() -> &'a MediaBrowserService {
        <MediaBrowserService as ::protobuf::Message>::default_instance()
    }
}

impl MediaBrowserService {
    pub fn new() -> MediaBrowserService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaBrowserService>(
            "MediaBrowserService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaBrowserService {
    const NAME: &'static str = "MediaBrowserService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaBrowserService {
        MediaBrowserService::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaBrowserService {
        static instance: MediaBrowserService = MediaBrowserService {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaBrowserService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaBrowserService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaBrowserService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaBrowserService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VendorExtensionService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VendorExtensionService {
    // message fields
    // @@protoc_insertion_point(field:VendorExtensionService.service_name)
    pub service_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VendorExtensionService.package_white_list)
    pub package_white_list: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:VendorExtensionService.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:VendorExtensionService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VendorExtensionService {
    fn default() -> &'a VendorExtensionService {
        <VendorExtensionService as ::protobuf::Message>::default_instance()
    }
}

impl VendorExtensionService {
    pub fn new() -> VendorExtensionService {
        ::std::default::Default::default()
    }

    // required string service_name = 1;

    pub fn service_name(&self) -> &str {
        match self.service_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_service_name(&mut self) {
        self.service_name = ::std::option::Option::None;
    }

    pub fn has_service_name(&self) -> bool {
        self.service_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        if self.service_name.is_none() {
            self.service_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.service_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        self.service_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_name",
            |m: &VendorExtensionService| { &m.service_name },
            |m: &mut VendorExtensionService| { &mut m.service_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "package_white_list",
            |m: &VendorExtensionService| { &m.package_white_list },
            |m: &mut VendorExtensionService| { &mut m.package_white_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &VendorExtensionService| { &m.data },
            |m: &mut VendorExtensionService| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VendorExtensionService>(
            "VendorExtensionService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VendorExtensionService {
    const NAME: &'static str = "VendorExtensionService";

    fn is_initialized(&self) -> bool {
        if self.service_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.service_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.package_white_list.push(is.read_string()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.service_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.package_white_list {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.service_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.package_white_list {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VendorExtensionService {
        VendorExtensionService::new()
    }

    fn clear(&mut self) {
        self.service_name = ::std::option::Option::None;
        self.package_white_list.clear();
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VendorExtensionService {
        static instance: VendorExtensionService = VendorExtensionService {
            service_name: ::std::option::Option::None,
            package_white_list: ::std::vec::Vec::new(),
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VendorExtensionService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VendorExtensionService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VendorExtensionService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VendorExtensionService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GenericNotificationService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GenericNotificationService {
    // special fields
    // @@protoc_insertion_point(special_field:GenericNotificationService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericNotificationService {
    fn default() -> &'a GenericNotificationService {
        <GenericNotificationService as ::protobuf::Message>::default_instance()
    }
}

impl GenericNotificationService {
    pub fn new() -> GenericNotificationService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericNotificationService>(
            "GenericNotificationService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericNotificationService {
    const NAME: &'static str = "GenericNotificationService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericNotificationService {
        GenericNotificationService::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericNotificationService {
        static instance: GenericNotificationService = GenericNotificationService {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericNotificationService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericNotificationService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericNotificationService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericNotificationService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChannelOpenRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelOpenRequest {
    // message fields
    // @@protoc_insertion_point(field:ChannelOpenRequest.priority)
    pub priority: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ChannelOpenRequest.service_id)
    pub service_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ChannelOpenRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelOpenRequest {
    fn default() -> &'a ChannelOpenRequest {
        <ChannelOpenRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelOpenRequest {
    pub fn new() -> ChannelOpenRequest {
        ::std::default::Default::default()
    }

    // required sint32 priority = 1;

    pub fn priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // required int32 service_id = 2;

    pub fn service_id(&self) -> i32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: i32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority",
            |m: &ChannelOpenRequest| { &m.priority },
            |m: &mut ChannelOpenRequest| { &mut m.priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_id",
            |m: &ChannelOpenRequest| { &m.service_id },
            |m: &mut ChannelOpenRequest| { &mut m.service_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelOpenRequest>(
            "ChannelOpenRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelOpenRequest {
    const NAME: &'static str = "ChannelOpenRequest";

    fn is_initialized(&self) -> bool {
        if self.priority.is_none() {
            return false;
        }
        if self.service_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.priority = ::std::option::Option::Some(is.read_sint32()?);
                },
                16 => {
                    self.service_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::sint32_size(1, v);
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.priority {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.service_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelOpenRequest {
        ChannelOpenRequest::new()
    }

    fn clear(&mut self) {
        self.priority = ::std::option::Option::None;
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelOpenRequest {
        static instance: ChannelOpenRequest = ChannelOpenRequest {
            priority: ::std::option::Option::None,
            service_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelOpenRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelOpenRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelOpenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelOpenRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChannelOpenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelOpenResponse {
    // message fields
    // @@protoc_insertion_point(field:ChannelOpenResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:ChannelOpenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelOpenResponse {
    fn default() -> &'a ChannelOpenResponse {
        <ChannelOpenResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelOpenResponse {
    pub fn new() -> ChannelOpenResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ChannelOpenResponse| { &m.status },
            |m: &mut ChannelOpenResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelOpenResponse>(
            "ChannelOpenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelOpenResponse {
    const NAME: &'static str = "ChannelOpenResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelOpenResponse {
        ChannelOpenResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelOpenResponse {
        static instance: ChannelOpenResponse = ChannelOpenResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelOpenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelOpenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelOpenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelOpenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChannelCloseNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChannelCloseNotification {
    // special fields
    // @@protoc_insertion_point(special_field:ChannelCloseNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelCloseNotification {
    fn default() -> &'a ChannelCloseNotification {
        <ChannelCloseNotification as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCloseNotification {
    pub fn new() -> ChannelCloseNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelCloseNotification>(
            "ChannelCloseNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelCloseNotification {
    const NAME: &'static str = "ChannelCloseNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelCloseNotification {
        ChannelCloseNotification::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelCloseNotification {
        static instance: ChannelCloseNotification = ChannelCloseNotification {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelCloseNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelCloseNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelCloseNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavFocusRequestNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavFocusRequestNotification {
    // message fields
    // @@protoc_insertion_point(field:NavFocusRequestNotification.focus_type)
    pub focus_type: ::std::option::Option<::protobuf::EnumOrUnknown<NavFocusType>>,
    // special fields
    // @@protoc_insertion_point(special_field:NavFocusRequestNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavFocusRequestNotification {
    fn default() -> &'a NavFocusRequestNotification {
        <NavFocusRequestNotification as ::protobuf::Message>::default_instance()
    }
}

impl NavFocusRequestNotification {
    pub fn new() -> NavFocusRequestNotification {
        ::std::default::Default::default()
    }

    // optional .NavFocusType focus_type = 1;

    pub fn focus_type(&self) -> NavFocusType {
        match self.focus_type {
            Some(e) => e.enum_value_or(NavFocusType::NAV_FOCUS_NATIVE),
            None => NavFocusType::NAV_FOCUS_NATIVE,
        }
    }

    pub fn clear_focus_type(&mut self) {
        self.focus_type = ::std::option::Option::None;
    }

    pub fn has_focus_type(&self) -> bool {
        self.focus_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus_type(&mut self, v: NavFocusType) {
        self.focus_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "focus_type",
            |m: &NavFocusRequestNotification| { &m.focus_type },
            |m: &mut NavFocusRequestNotification| { &mut m.focus_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavFocusRequestNotification>(
            "NavFocusRequestNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavFocusRequestNotification {
    const NAME: &'static str = "NavFocusRequestNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.focus_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.focus_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.focus_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavFocusRequestNotification {
        NavFocusRequestNotification::new()
    }

    fn clear(&mut self) {
        self.focus_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavFocusRequestNotification {
        static instance: NavFocusRequestNotification = NavFocusRequestNotification {
            focus_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavFocusRequestNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavFocusRequestNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavFocusRequestNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavFocusRequestNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavFocusNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavFocusNotification {
    // message fields
    // @@protoc_insertion_point(field:NavFocusNotification.focus_type)
    pub focus_type: ::std::option::Option<::protobuf::EnumOrUnknown<NavFocusType>>,
    // special fields
    // @@protoc_insertion_point(special_field:NavFocusNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavFocusNotification {
    fn default() -> &'a NavFocusNotification {
        <NavFocusNotification as ::protobuf::Message>::default_instance()
    }
}

impl NavFocusNotification {
    pub fn new() -> NavFocusNotification {
        ::std::default::Default::default()
    }

    // required .NavFocusType focus_type = 1;

    pub fn focus_type(&self) -> NavFocusType {
        match self.focus_type {
            Some(e) => e.enum_value_or(NavFocusType::NAV_FOCUS_NATIVE),
            None => NavFocusType::NAV_FOCUS_NATIVE,
        }
    }

    pub fn clear_focus_type(&mut self) {
        self.focus_type = ::std::option::Option::None;
    }

    pub fn has_focus_type(&self) -> bool {
        self.focus_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus_type(&mut self, v: NavFocusType) {
        self.focus_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "focus_type",
            |m: &NavFocusNotification| { &m.focus_type },
            |m: &mut NavFocusNotification| { &mut m.focus_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavFocusNotification>(
            "NavFocusNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavFocusNotification {
    const NAME: &'static str = "NavFocusNotification";

    fn is_initialized(&self) -> bool {
        if self.focus_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.focus_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.focus_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.focus_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavFocusNotification {
        NavFocusNotification::new()
    }

    fn clear(&mut self) {
        self.focus_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavFocusNotification {
        static instance: NavFocusNotification = NavFocusNotification {
            focus_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavFocusNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavFocusNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavFocusNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavFocusNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingRequest {
    // message fields
    // @@protoc_insertion_point(field:PingRequest.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:PingRequest.bug_report)
    pub bug_report: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:PingRequest.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    // required int64 timestamp = 1;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool bug_report = 2;

    pub fn bug_report(&self) -> bool {
        self.bug_report.unwrap_or(false)
    }

    pub fn clear_bug_report(&mut self) {
        self.bug_report = ::std::option::Option::None;
    }

    pub fn has_bug_report(&self) -> bool {
        self.bug_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bug_report(&mut self, v: bool) {
        self.bug_report = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &PingRequest| { &m.timestamp },
            |m: &mut PingRequest| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bug_report",
            |m: &PingRequest| { &m.bug_report },
            |m: &mut PingRequest| { &mut m.bug_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &PingRequest| { &m.data },
            |m: &mut PingRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.bug_report = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.bug_report {
            my_size += 1 + 1;
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bug_report {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.bug_report = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            timestamp: ::std::option::Option::None,
            bug_report: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingResponse {
    // message fields
    // @@protoc_insertion_point(field:PingResponse.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:PingResponse.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }

    // required int64 timestamp = 1;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &PingResponse| { &m.timestamp },
            |m: &mut PingResponse| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &PingResponse| { &m.data },
            |m: &mut PingResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            timestamp: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ByeByeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ByeByeRequest {
    // message fields
    // @@protoc_insertion_point(field:ByeByeRequest.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<ByeByeReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:ByeByeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ByeByeRequest {
    fn default() -> &'a ByeByeRequest {
        <ByeByeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ByeByeRequest {
    pub fn new() -> ByeByeRequest {
        ::std::default::Default::default()
    }

    // required .ByeByeReason reason = 1;

    pub fn reason(&self) -> ByeByeReason {
        match self.reason {
            Some(e) => e.enum_value_or(ByeByeReason::USER_SELECTION),
            None => ByeByeReason::USER_SELECTION,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ByeByeReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ByeByeRequest| { &m.reason },
            |m: &mut ByeByeRequest| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ByeByeRequest>(
            "ByeByeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ByeByeRequest {
    const NAME: &'static str = "ByeByeRequest";

    fn is_initialized(&self) -> bool {
        if self.reason.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ByeByeRequest {
        ByeByeRequest::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ByeByeRequest {
        static instance: ByeByeRequest = ByeByeRequest {
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ByeByeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ByeByeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ByeByeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ByeByeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ByeByeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ByeByeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ByeByeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ByeByeResponse {
    fn default() -> &'a ByeByeResponse {
        <ByeByeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ByeByeResponse {
    pub fn new() -> ByeByeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ByeByeResponse>(
            "ByeByeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ByeByeResponse {
    const NAME: &'static str = "ByeByeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ByeByeResponse {
        ByeByeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ByeByeResponse {
        static instance: ByeByeResponse = ByeByeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ByeByeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ByeByeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ByeByeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ByeByeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceSessionNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceSessionNotification {
    // message fields
    // @@protoc_insertion_point(field:VoiceSessionNotification.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<VoiceSessionStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceSessionNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceSessionNotification {
    fn default() -> &'a VoiceSessionNotification {
        <VoiceSessionNotification as ::protobuf::Message>::default_instance()
    }
}

impl VoiceSessionNotification {
    pub fn new() -> VoiceSessionNotification {
        ::std::default::Default::default()
    }

    // optional .VoiceSessionStatus status = 1;

    pub fn status(&self) -> VoiceSessionStatus {
        match self.status {
            Some(e) => e.enum_value_or(VoiceSessionStatus::VOICE_SESSION_START),
            None => VoiceSessionStatus::VOICE_SESSION_START,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: VoiceSessionStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &VoiceSessionNotification| { &m.status },
            |m: &mut VoiceSessionNotification| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceSessionNotification>(
            "VoiceSessionNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceSessionNotification {
    const NAME: &'static str = "VoiceSessionNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceSessionNotification {
        VoiceSessionNotification::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceSessionNotification {
        static instance: VoiceSessionNotification = VoiceSessionNotification {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceSessionNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceSessionNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceSessionNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceSessionNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CarConnectedDevicesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CarConnectedDevicesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CarConnectedDevicesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CarConnectedDevicesRequest {
    fn default() -> &'a CarConnectedDevicesRequest {
        <CarConnectedDevicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CarConnectedDevicesRequest {
    pub fn new() -> CarConnectedDevicesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CarConnectedDevicesRequest>(
            "CarConnectedDevicesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CarConnectedDevicesRequest {
    const NAME: &'static str = "CarConnectedDevicesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CarConnectedDevicesRequest {
        CarConnectedDevicesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CarConnectedDevicesRequest {
        static instance: CarConnectedDevicesRequest = CarConnectedDevicesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CarConnectedDevicesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CarConnectedDevicesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CarConnectedDevicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarConnectedDevicesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CarConnectedDevices)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CarConnectedDevices {
    // message fields
    // @@protoc_insertion_point(field:CarConnectedDevices.connected_devices)
    pub connected_devices: ::std::vec::Vec<ConnectedDevice>,
    // @@protoc_insertion_point(field:CarConnectedDevices.unsolicited)
    pub unsolicited: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CarConnectedDevices.final_list)
    pub final_list: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CarConnectedDevices.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CarConnectedDevices {
    fn default() -> &'a CarConnectedDevices {
        <CarConnectedDevices as ::protobuf::Message>::default_instance()
    }
}

impl CarConnectedDevices {
    pub fn new() -> CarConnectedDevices {
        ::std::default::Default::default()
    }

    // optional bool unsolicited = 2;

    pub fn unsolicited(&self) -> bool {
        self.unsolicited.unwrap_or(false)
    }

    pub fn clear_unsolicited(&mut self) {
        self.unsolicited = ::std::option::Option::None;
    }

    pub fn has_unsolicited(&self) -> bool {
        self.unsolicited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsolicited(&mut self, v: bool) {
        self.unsolicited = ::std::option::Option::Some(v);
    }

    // optional bool final_list = 3;

    pub fn final_list(&self) -> bool {
        self.final_list.unwrap_or(true)
    }

    pub fn clear_final_list(&mut self) {
        self.final_list = ::std::option::Option::None;
    }

    pub fn has_final_list(&self) -> bool {
        self.final_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_list(&mut self, v: bool) {
        self.final_list = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connected_devices",
            |m: &CarConnectedDevices| { &m.connected_devices },
            |m: &mut CarConnectedDevices| { &mut m.connected_devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsolicited",
            |m: &CarConnectedDevices| { &m.unsolicited },
            |m: &mut CarConnectedDevices| { &mut m.unsolicited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "final_list",
            |m: &CarConnectedDevices| { &m.final_list },
            |m: &mut CarConnectedDevices| { &mut m.final_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CarConnectedDevices>(
            "CarConnectedDevices",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CarConnectedDevices {
    const NAME: &'static str = "CarConnectedDevices";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connected_devices.push(is.read_message()?);
                },
                16 => {
                    self.unsolicited = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.final_list = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connected_devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.unsolicited {
            my_size += 1 + 1;
        }
        if let Some(v) = self.final_list {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.connected_devices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.unsolicited {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.final_list {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CarConnectedDevices {
        CarConnectedDevices::new()
    }

    fn clear(&mut self) {
        self.connected_devices.clear();
        self.unsolicited = ::std::option::Option::None;
        self.final_list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CarConnectedDevices {
        static instance: CarConnectedDevices = CarConnectedDevices {
            connected_devices: ::std::vec::Vec::new(),
            unsolicited: ::std::option::Option::None,
            final_list: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CarConnectedDevices {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CarConnectedDevices").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CarConnectedDevices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarConnectedDevices {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ConnectedDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectedDevice {
    // message fields
    // @@protoc_insertion_point(field:ConnectedDevice.device_name)
    pub device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ConnectedDevice.device_id)
    pub device_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ConnectedDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectedDevice {
    fn default() -> &'a ConnectedDevice {
        <ConnectedDevice as ::protobuf::Message>::default_instance()
    }
}

impl ConnectedDevice {
    pub fn new() -> ConnectedDevice {
        ::std::default::Default::default()
    }

    // optional string device_name = 1;

    pub fn device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self.device_name = ::std::option::Option::None;
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 device_id = 2;

    pub fn device_id(&self) -> i32 {
        self.device_id.unwrap_or(0)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: i32) {
        self.device_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_name",
            |m: &ConnectedDevice| { &m.device_name },
            |m: &mut ConnectedDevice| { &mut m.device_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &ConnectedDevice| { &m.device_id },
            |m: &mut ConnectedDevice| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectedDevice>(
            "ConnectedDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectedDevice {
    const NAME: &'static str = "ConnectedDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.device_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.device_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectedDevice {
        ConnectedDevice::new()
    }

    fn clear(&mut self) {
        self.device_name = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectedDevice {
        static instance: ConnectedDevice = ConnectedDevice {
            device_name: ::std::option::Option::None,
            device_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectedDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectedDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectedDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectedDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UserSwitchRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserSwitchRequest {
    // message fields
    // @@protoc_insertion_point(field:UserSwitchRequest.selected_device)
    pub selected_device: ::protobuf::MessageField<ConnectedDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:UserSwitchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserSwitchRequest {
    fn default() -> &'a UserSwitchRequest {
        <UserSwitchRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserSwitchRequest {
    pub fn new() -> UserSwitchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectedDevice>(
            "selected_device",
            |m: &UserSwitchRequest| { &m.selected_device },
            |m: &mut UserSwitchRequest| { &mut m.selected_device },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserSwitchRequest>(
            "UserSwitchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserSwitchRequest {
    const NAME: &'static str = "UserSwitchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selected_device)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selected_device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selected_device.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserSwitchRequest {
        UserSwitchRequest::new()
    }

    fn clear(&mut self) {
        self.selected_device.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserSwitchRequest {
        static instance: UserSwitchRequest = UserSwitchRequest {
            selected_device: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserSwitchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserSwitchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserSwitchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSwitchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UserSwitchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserSwitchResponse {
    // message fields
    // @@protoc_insertion_point(field:UserSwitchResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<UserSwitchStatus>>,
    // @@protoc_insertion_point(field:UserSwitchResponse.selected_device)
    pub selected_device: ::protobuf::MessageField<ConnectedDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:UserSwitchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserSwitchResponse {
    fn default() -> &'a UserSwitchResponse {
        <UserSwitchResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserSwitchResponse {
    pub fn new() -> UserSwitchResponse {
        ::std::default::Default::default()
    }

    // optional .UserSwitchStatus status = 1;

    pub fn status(&self) -> UserSwitchStatus {
        match self.status {
            Some(e) => e.enum_value_or(UserSwitchStatus::STATUS_OK),
            None => UserSwitchStatus::STATUS_OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UserSwitchStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &UserSwitchResponse| { &m.status },
            |m: &mut UserSwitchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectedDevice>(
            "selected_device",
            |m: &UserSwitchResponse| { &m.selected_device },
            |m: &mut UserSwitchResponse| { &mut m.selected_device },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserSwitchResponse>(
            "UserSwitchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserSwitchResponse {
    const NAME: &'static str = "UserSwitchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selected_device)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.selected_device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.selected_device.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserSwitchResponse {
        UserSwitchResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.selected_device.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserSwitchResponse {
        static instance: UserSwitchResponse = UserSwitchResponse {
            status: ::std::option::Option::None,
            selected_device: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserSwitchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserSwitchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserSwitchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSwitchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BatteryStatusNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BatteryStatusNotification {
    // message fields
    // @@protoc_insertion_point(field:BatteryStatusNotification.battery_level)
    pub battery_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:BatteryStatusNotification.time_remaining_s)
    pub time_remaining_s: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:BatteryStatusNotification.critical_battery)
    pub critical_battery: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:BatteryStatusNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatteryStatusNotification {
    fn default() -> &'a BatteryStatusNotification {
        <BatteryStatusNotification as ::protobuf::Message>::default_instance()
    }
}

impl BatteryStatusNotification {
    pub fn new() -> BatteryStatusNotification {
        ::std::default::Default::default()
    }

    // required uint32 battery_level = 1;

    pub fn battery_level(&self) -> u32 {
        self.battery_level.unwrap_or(0)
    }

    pub fn clear_battery_level(&mut self) {
        self.battery_level = ::std::option::Option::None;
    }

    pub fn has_battery_level(&self) -> bool {
        self.battery_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battery_level(&mut self, v: u32) {
        self.battery_level = ::std::option::Option::Some(v);
    }

    // optional uint32 time_remaining_s = 2;

    pub fn time_remaining_s(&self) -> u32 {
        self.time_remaining_s.unwrap_or(0)
    }

    pub fn clear_time_remaining_s(&mut self) {
        self.time_remaining_s = ::std::option::Option::None;
    }

    pub fn has_time_remaining_s(&self) -> bool {
        self.time_remaining_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_remaining_s(&mut self, v: u32) {
        self.time_remaining_s = ::std::option::Option::Some(v);
    }

    // optional bool critical_battery = 3;

    pub fn critical_battery(&self) -> bool {
        self.critical_battery.unwrap_or(false)
    }

    pub fn clear_critical_battery(&mut self) {
        self.critical_battery = ::std::option::Option::None;
    }

    pub fn has_critical_battery(&self) -> bool {
        self.critical_battery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_critical_battery(&mut self, v: bool) {
        self.critical_battery = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "battery_level",
            |m: &BatteryStatusNotification| { &m.battery_level },
            |m: &mut BatteryStatusNotification| { &mut m.battery_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_remaining_s",
            |m: &BatteryStatusNotification| { &m.time_remaining_s },
            |m: &mut BatteryStatusNotification| { &mut m.time_remaining_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "critical_battery",
            |m: &BatteryStatusNotification| { &m.critical_battery },
            |m: &mut BatteryStatusNotification| { &mut m.critical_battery },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatteryStatusNotification>(
            "BatteryStatusNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatteryStatusNotification {
    const NAME: &'static str = "BatteryStatusNotification";

    fn is_initialized(&self) -> bool {
        if self.battery_level.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battery_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.time_remaining_s = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.critical_battery = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battery_level {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time_remaining_s {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.critical_battery {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.battery_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_remaining_s {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.critical_battery {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatteryStatusNotification {
        BatteryStatusNotification::new()
    }

    fn clear(&mut self) {
        self.battery_level = ::std::option::Option::None;
        self.time_remaining_s = ::std::option::Option::None;
        self.critical_battery = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatteryStatusNotification {
        static instance: BatteryStatusNotification = BatteryStatusNotification {
            battery_level: ::std::option::Option::None,
            time_remaining_s: ::std::option::Option::None,
            critical_battery: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatteryStatusNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatteryStatusNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatteryStatusNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatteryStatusNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CallAvailabilityStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CallAvailabilityStatus {
    // message fields
    // @@protoc_insertion_point(field:CallAvailabilityStatus.call_available)
    pub call_available: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CallAvailabilityStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CallAvailabilityStatus {
    fn default() -> &'a CallAvailabilityStatus {
        <CallAvailabilityStatus as ::protobuf::Message>::default_instance()
    }
}

impl CallAvailabilityStatus {
    pub fn new() -> CallAvailabilityStatus {
        ::std::default::Default::default()
    }

    // optional bool call_available = 1;

    pub fn call_available(&self) -> bool {
        self.call_available.unwrap_or(false)
    }

    pub fn clear_call_available(&mut self) {
        self.call_available = ::std::option::Option::None;
    }

    pub fn has_call_available(&self) -> bool {
        self.call_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_available(&mut self, v: bool) {
        self.call_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "call_available",
            |m: &CallAvailabilityStatus| { &m.call_available },
            |m: &mut CallAvailabilityStatus| { &mut m.call_available },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallAvailabilityStatus>(
            "CallAvailabilityStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CallAvailabilityStatus {
    const NAME: &'static str = "CallAvailabilityStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.call_available = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.call_available {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.call_available {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CallAvailabilityStatus {
        CallAvailabilityStatus::new()
    }

    fn clear(&mut self) {
        self.call_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CallAvailabilityStatus {
        static instance: CallAvailabilityStatus = CallAvailabilityStatus {
            call_available: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CallAvailabilityStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CallAvailabilityStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CallAvailabilityStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallAvailabilityStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SensorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SensorRequest {
    // message fields
    // @@protoc_insertion_point(field:SensorRequest.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<SensorType>>,
    // @@protoc_insertion_point(field:SensorRequest.min_update_period)
    pub min_update_period: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:SensorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SensorRequest {
    fn default() -> &'a SensorRequest {
        <SensorRequest as ::protobuf::Message>::default_instance()
    }
}

impl SensorRequest {
    pub fn new() -> SensorRequest {
        ::std::default::Default::default()
    }

    // required .SensorType type = 1;

    pub fn type_(&self) -> SensorType {
        match self.type_ {
            Some(e) => e.enum_value_or(SensorType::SENSOR_LOCATION),
            None => SensorType::SENSOR_LOCATION,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: SensorType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 min_update_period = 2;

    pub fn min_update_period(&self) -> i64 {
        self.min_update_period.unwrap_or(0)
    }

    pub fn clear_min_update_period(&mut self) {
        self.min_update_period = ::std::option::Option::None;
    }

    pub fn has_min_update_period(&self) -> bool {
        self.min_update_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_update_period(&mut self, v: i64) {
        self.min_update_period = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &SensorRequest| { &m.type_ },
            |m: &mut SensorRequest| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_update_period",
            |m: &SensorRequest| { &m.min_update_period },
            |m: &mut SensorRequest| { &mut m.min_update_period },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorRequest>(
            "SensorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorRequest {
    const NAME: &'static str = "SensorRequest";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.min_update_period.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.min_update_period = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.min_update_period {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.min_update_period {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorRequest {
        SensorRequest::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.min_update_period = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorRequest {
        static instance: SensorRequest = SensorRequest {
            type_: ::std::option::Option::None,
            min_update_period: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SensorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SensorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SensorResponse {
    // message fields
    // @@protoc_insertion_point(field:SensorResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:SensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SensorResponse {
    fn default() -> &'a SensorResponse {
        <SensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SensorResponse {
    pub fn new() -> SensorResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SensorResponse| { &m.status },
            |m: &mut SensorResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorResponse>(
            "SensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorResponse {
    const NAME: &'static str = "SensorResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorResponse {
        SensorResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorResponse {
        static instance: SensorResponse = SensorResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SensorBatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SensorBatch {
    // message fields
    // @@protoc_insertion_point(field:SensorBatch.location_data)
    pub location_data: ::std::vec::Vec<LocationData>,
    // @@protoc_insertion_point(field:SensorBatch.compass_data)
    pub compass_data: ::std::vec::Vec<CompassData>,
    // @@protoc_insertion_point(field:SensorBatch.speed_data)
    pub speed_data: ::std::vec::Vec<SpeedData>,
    // @@protoc_insertion_point(field:SensorBatch.rpm_data)
    pub rpm_data: ::std::vec::Vec<RpmData>,
    // @@protoc_insertion_point(field:SensorBatch.odometer_data)
    pub odometer_data: ::std::vec::Vec<OdometerData>,
    // @@protoc_insertion_point(field:SensorBatch.fuel_data)
    pub fuel_data: ::std::vec::Vec<FuelData>,
    // @@protoc_insertion_point(field:SensorBatch.parking_brake_data)
    pub parking_brake_data: ::std::vec::Vec<ParkingBrakeData>,
    // @@protoc_insertion_point(field:SensorBatch.gear_data)
    pub gear_data: ::std::vec::Vec<GearData>,
    // @@protoc_insertion_point(field:SensorBatch.diagnostics_data)
    pub diagnostics_data: ::std::vec::Vec<DiagnosticsData>,
    // @@protoc_insertion_point(field:SensorBatch.night_mode_data)
    pub night_mode_data: ::std::vec::Vec<NightModeData>,
    // @@protoc_insertion_point(field:SensorBatch.environment_data)
    pub environment_data: ::std::vec::Vec<EnvironmentData>,
    // @@protoc_insertion_point(field:SensorBatch.hvac_data)
    pub hvac_data: ::std::vec::Vec<HvacData>,
    // @@protoc_insertion_point(field:SensorBatch.driving_status_data)
    pub driving_status_data: ::std::vec::Vec<DrivingStatusData>,
    // @@protoc_insertion_point(field:SensorBatch.dead_reckoning_data)
    pub dead_reckoning_data: ::std::vec::Vec<DeadReckoningData>,
    // @@protoc_insertion_point(field:SensorBatch.passenger_data)
    pub passenger_data: ::std::vec::Vec<PassengerData>,
    // @@protoc_insertion_point(field:SensorBatch.door_data)
    pub door_data: ::std::vec::Vec<DoorData>,
    // @@protoc_insertion_point(field:SensorBatch.light_data)
    pub light_data: ::std::vec::Vec<LightData>,
    // @@protoc_insertion_point(field:SensorBatch.tire_pressure_data)
    pub tire_pressure_data: ::std::vec::Vec<TirePressureData>,
    // @@protoc_insertion_point(field:SensorBatch.accelerometer_data)
    pub accelerometer_data: ::std::vec::Vec<AccelerometerData>,
    // @@protoc_insertion_point(field:SensorBatch.gyroscope_data)
    pub gyroscope_data: ::std::vec::Vec<GyroscopeData>,
    // @@protoc_insertion_point(field:SensorBatch.gps_satellite_data)
    pub gps_satellite_data: ::std::vec::Vec<GpsSatelliteData>,
    // @@protoc_insertion_point(field:SensorBatch.toll_card_data)
    pub toll_card_data: ::std::vec::Vec<TollCardData>,
    // special fields
    // @@protoc_insertion_point(special_field:SensorBatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SensorBatch {
    fn default() -> &'a SensorBatch {
        <SensorBatch as ::protobuf::Message>::default_instance()
    }
}

impl SensorBatch {
    pub fn new() -> SensorBatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "location_data",
            |m: &SensorBatch| { &m.location_data },
            |m: &mut SensorBatch| { &mut m.location_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "compass_data",
            |m: &SensorBatch| { &m.compass_data },
            |m: &mut SensorBatch| { &mut m.compass_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "speed_data",
            |m: &SensorBatch| { &m.speed_data },
            |m: &mut SensorBatch| { &mut m.speed_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rpm_data",
            |m: &SensorBatch| { &m.rpm_data },
            |m: &mut SensorBatch| { &mut m.rpm_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "odometer_data",
            |m: &SensorBatch| { &m.odometer_data },
            |m: &mut SensorBatch| { &mut m.odometer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fuel_data",
            |m: &SensorBatch| { &m.fuel_data },
            |m: &mut SensorBatch| { &mut m.fuel_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parking_brake_data",
            |m: &SensorBatch| { &m.parking_brake_data },
            |m: &mut SensorBatch| { &mut m.parking_brake_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gear_data",
            |m: &SensorBatch| { &m.gear_data },
            |m: &mut SensorBatch| { &mut m.gear_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diagnostics_data",
            |m: &SensorBatch| { &m.diagnostics_data },
            |m: &mut SensorBatch| { &mut m.diagnostics_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "night_mode_data",
            |m: &SensorBatch| { &m.night_mode_data },
            |m: &mut SensorBatch| { &mut m.night_mode_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "environment_data",
            |m: &SensorBatch| { &m.environment_data },
            |m: &mut SensorBatch| { &mut m.environment_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hvac_data",
            |m: &SensorBatch| { &m.hvac_data },
            |m: &mut SensorBatch| { &mut m.hvac_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "driving_status_data",
            |m: &SensorBatch| { &m.driving_status_data },
            |m: &mut SensorBatch| { &mut m.driving_status_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dead_reckoning_data",
            |m: &SensorBatch| { &m.dead_reckoning_data },
            |m: &mut SensorBatch| { &mut m.dead_reckoning_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passenger_data",
            |m: &SensorBatch| { &m.passenger_data },
            |m: &mut SensorBatch| { &mut m.passenger_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "door_data",
            |m: &SensorBatch| { &m.door_data },
            |m: &mut SensorBatch| { &mut m.door_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "light_data",
            |m: &SensorBatch| { &m.light_data },
            |m: &mut SensorBatch| { &mut m.light_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tire_pressure_data",
            |m: &SensorBatch| { &m.tire_pressure_data },
            |m: &mut SensorBatch| { &mut m.tire_pressure_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accelerometer_data",
            |m: &SensorBatch| { &m.accelerometer_data },
            |m: &mut SensorBatch| { &mut m.accelerometer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gyroscope_data",
            |m: &SensorBatch| { &m.gyroscope_data },
            |m: &mut SensorBatch| { &mut m.gyroscope_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gps_satellite_data",
            |m: &SensorBatch| { &m.gps_satellite_data },
            |m: &mut SensorBatch| { &mut m.gps_satellite_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toll_card_data",
            |m: &SensorBatch| { &m.toll_card_data },
            |m: &mut SensorBatch| { &mut m.toll_card_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorBatch>(
            "SensorBatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorBatch {
    const NAME: &'static str = "SensorBatch";

    fn is_initialized(&self) -> bool {
        for v in &self.location_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compass_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speed_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rpm_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.odometer_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fuel_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parking_brake_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gear_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.diagnostics_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.night_mode_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.environment_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hvac_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.driving_status_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dead_reckoning_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.passenger_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.door_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.light_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tire_pressure_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accelerometer_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gyroscope_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gps_satellite_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.toll_card_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.location_data.push(is.read_message()?);
                },
                18 => {
                    self.compass_data.push(is.read_message()?);
                },
                26 => {
                    self.speed_data.push(is.read_message()?);
                },
                34 => {
                    self.rpm_data.push(is.read_message()?);
                },
                42 => {
                    self.odometer_data.push(is.read_message()?);
                },
                50 => {
                    self.fuel_data.push(is.read_message()?);
                },
                58 => {
                    self.parking_brake_data.push(is.read_message()?);
                },
                66 => {
                    self.gear_data.push(is.read_message()?);
                },
                74 => {
                    self.diagnostics_data.push(is.read_message()?);
                },
                82 => {
                    self.night_mode_data.push(is.read_message()?);
                },
                90 => {
                    self.environment_data.push(is.read_message()?);
                },
                98 => {
                    self.hvac_data.push(is.read_message()?);
                },
                106 => {
                    self.driving_status_data.push(is.read_message()?);
                },
                114 => {
                    self.dead_reckoning_data.push(is.read_message()?);
                },
                122 => {
                    self.passenger_data.push(is.read_message()?);
                },
                130 => {
                    self.door_data.push(is.read_message()?);
                },
                138 => {
                    self.light_data.push(is.read_message()?);
                },
                146 => {
                    self.tire_pressure_data.push(is.read_message()?);
                },
                154 => {
                    self.accelerometer_data.push(is.read_message()?);
                },
                162 => {
                    self.gyroscope_data.push(is.read_message()?);
                },
                170 => {
                    self.gps_satellite_data.push(is.read_message()?);
                },
                178 => {
                    self.toll_card_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.location_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.compass_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.speed_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rpm_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.odometer_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fuel_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.parking_brake_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.gear_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.diagnostics_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.night_mode_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.environment_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.hvac_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.driving_status_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dead_reckoning_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.passenger_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.door_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.light_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tire_pressure_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accelerometer_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.gyroscope_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.gps_satellite_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.toll_card_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.location_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.compass_data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.speed_data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.rpm_data {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.odometer_data {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.fuel_data {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.parking_brake_data {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.gear_data {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.diagnostics_data {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.night_mode_data {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.environment_data {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.hvac_data {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.driving_status_data {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.dead_reckoning_data {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.passenger_data {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.door_data {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.light_data {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        for v in &self.tire_pressure_data {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.accelerometer_data {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        for v in &self.gyroscope_data {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.gps_satellite_data {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.toll_card_data {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorBatch {
        SensorBatch::new()
    }

    fn clear(&mut self) {
        self.location_data.clear();
        self.compass_data.clear();
        self.speed_data.clear();
        self.rpm_data.clear();
        self.odometer_data.clear();
        self.fuel_data.clear();
        self.parking_brake_data.clear();
        self.gear_data.clear();
        self.diagnostics_data.clear();
        self.night_mode_data.clear();
        self.environment_data.clear();
        self.hvac_data.clear();
        self.driving_status_data.clear();
        self.dead_reckoning_data.clear();
        self.passenger_data.clear();
        self.door_data.clear();
        self.light_data.clear();
        self.tire_pressure_data.clear();
        self.accelerometer_data.clear();
        self.gyroscope_data.clear();
        self.gps_satellite_data.clear();
        self.toll_card_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorBatch {
        static instance: SensorBatch = SensorBatch {
            location_data: ::std::vec::Vec::new(),
            compass_data: ::std::vec::Vec::new(),
            speed_data: ::std::vec::Vec::new(),
            rpm_data: ::std::vec::Vec::new(),
            odometer_data: ::std::vec::Vec::new(),
            fuel_data: ::std::vec::Vec::new(),
            parking_brake_data: ::std::vec::Vec::new(),
            gear_data: ::std::vec::Vec::new(),
            diagnostics_data: ::std::vec::Vec::new(),
            night_mode_data: ::std::vec::Vec::new(),
            environment_data: ::std::vec::Vec::new(),
            hvac_data: ::std::vec::Vec::new(),
            driving_status_data: ::std::vec::Vec::new(),
            dead_reckoning_data: ::std::vec::Vec::new(),
            passenger_data: ::std::vec::Vec::new(),
            door_data: ::std::vec::Vec::new(),
            light_data: ::std::vec::Vec::new(),
            tire_pressure_data: ::std::vec::Vec::new(),
            accelerometer_data: ::std::vec::Vec::new(),
            gyroscope_data: ::std::vec::Vec::new(),
            gps_satellite_data: ::std::vec::Vec::new(),
            toll_card_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorBatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorBatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SensorBatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorBatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SensorError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SensorError {
    // message fields
    // @@protoc_insertion_point(field:SensorError.sensor_type)
    pub sensor_type: ::std::option::Option<::protobuf::EnumOrUnknown<SensorType>>,
    // @@protoc_insertion_point(field:SensorError.sensor_error_type)
    pub sensor_error_type: ::std::option::Option<::protobuf::EnumOrUnknown<SensorErrorType>>,
    // special fields
    // @@protoc_insertion_point(special_field:SensorError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SensorError {
    fn default() -> &'a SensorError {
        <SensorError as ::protobuf::Message>::default_instance()
    }
}

impl SensorError {
    pub fn new() -> SensorError {
        ::std::default::Default::default()
    }

    // required .SensorType sensor_type = 1;

    pub fn sensor_type(&self) -> SensorType {
        match self.sensor_type {
            Some(e) => e.enum_value_or(SensorType::SENSOR_LOCATION),
            None => SensorType::SENSOR_LOCATION,
        }
    }

    pub fn clear_sensor_type(&mut self) {
        self.sensor_type = ::std::option::Option::None;
    }

    pub fn has_sensor_type(&self) -> bool {
        self.sensor_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sensor_type(&mut self, v: SensorType) {
        self.sensor_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .SensorErrorType sensor_error_type = 2;

    pub fn sensor_error_type(&self) -> SensorErrorType {
        match self.sensor_error_type {
            Some(e) => e.enum_value_or(SensorErrorType::SENSOR_OK),
            None => SensorErrorType::SENSOR_OK,
        }
    }

    pub fn clear_sensor_error_type(&mut self) {
        self.sensor_error_type = ::std::option::Option::None;
    }

    pub fn has_sensor_error_type(&self) -> bool {
        self.sensor_error_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sensor_error_type(&mut self, v: SensorErrorType) {
        self.sensor_error_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sensor_type",
            |m: &SensorError| { &m.sensor_type },
            |m: &mut SensorError| { &mut m.sensor_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sensor_error_type",
            |m: &SensorError| { &m.sensor_error_type },
            |m: &mut SensorError| { &mut m.sensor_error_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorError>(
            "SensorError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorError {
    const NAME: &'static str = "SensorError";

    fn is_initialized(&self) -> bool {
        if self.sensor_type.is_none() {
            return false;
        }
        if self.sensor_error_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sensor_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.sensor_error_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sensor_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.sensor_error_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sensor_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sensor_error_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorError {
        SensorError::new()
    }

    fn clear(&mut self) {
        self.sensor_type = ::std::option::Option::None;
        self.sensor_error_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorError {
        static instance: SensorError = SensorError {
            sensor_type: ::std::option::Option::None,
            sensor_error_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SensorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LocationData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LocationData {
    // message fields
    // @@protoc_insertion_point(field:LocationData.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:LocationData.latitude_e7)
    pub latitude_e7: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LocationData.longitude_e7)
    pub longitude_e7: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LocationData.accuracy_e3)
    pub accuracy_e3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LocationData.altitude_e2)
    pub altitude_e2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LocationData.speed_e3)
    pub speed_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LocationData.bearing_e6)
    pub bearing_e6: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:LocationData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocationData {
    fn default() -> &'a LocationData {
        <LocationData as ::protobuf::Message>::default_instance()
    }
}

impl LocationData {
    pub fn new() -> LocationData {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // required int32 latitude_e7 = 2;

    pub fn latitude_e7(&self) -> i32 {
        self.latitude_e7.unwrap_or(0)
    }

    pub fn clear_latitude_e7(&mut self) {
        self.latitude_e7 = ::std::option::Option::None;
    }

    pub fn has_latitude_e7(&self) -> bool {
        self.latitude_e7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latitude_e7(&mut self, v: i32) {
        self.latitude_e7 = ::std::option::Option::Some(v);
    }

    // required int32 longitude_e7 = 3;

    pub fn longitude_e7(&self) -> i32 {
        self.longitude_e7.unwrap_or(0)
    }

    pub fn clear_longitude_e7(&mut self) {
        self.longitude_e7 = ::std::option::Option::None;
    }

    pub fn has_longitude_e7(&self) -> bool {
        self.longitude_e7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longitude_e7(&mut self, v: i32) {
        self.longitude_e7 = ::std::option::Option::Some(v);
    }

    // optional uint32 accuracy_e3 = 4;

    pub fn accuracy_e3(&self) -> u32 {
        self.accuracy_e3.unwrap_or(0)
    }

    pub fn clear_accuracy_e3(&mut self) {
        self.accuracy_e3 = ::std::option::Option::None;
    }

    pub fn has_accuracy_e3(&self) -> bool {
        self.accuracy_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accuracy_e3(&mut self, v: u32) {
        self.accuracy_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 altitude_e2 = 5;

    pub fn altitude_e2(&self) -> i32 {
        self.altitude_e2.unwrap_or(0)
    }

    pub fn clear_altitude_e2(&mut self) {
        self.altitude_e2 = ::std::option::Option::None;
    }

    pub fn has_altitude_e2(&self) -> bool {
        self.altitude_e2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altitude_e2(&mut self, v: i32) {
        self.altitude_e2 = ::std::option::Option::Some(v);
    }

    // optional int32 speed_e3 = 6;

    pub fn speed_e3(&self) -> i32 {
        self.speed_e3.unwrap_or(0)
    }

    pub fn clear_speed_e3(&mut self) {
        self.speed_e3 = ::std::option::Option::None;
    }

    pub fn has_speed_e3(&self) -> bool {
        self.speed_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed_e3(&mut self, v: i32) {
        self.speed_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 bearing_e6 = 7;

    pub fn bearing_e6(&self) -> i32 {
        self.bearing_e6.unwrap_or(0)
    }

    pub fn clear_bearing_e6(&mut self) {
        self.bearing_e6 = ::std::option::Option::None;
    }

    pub fn has_bearing_e6(&self) -> bool {
        self.bearing_e6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bearing_e6(&mut self, v: i32) {
        self.bearing_e6 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &LocationData| { &m.timestamp },
            |m: &mut LocationData| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "latitude_e7",
            |m: &LocationData| { &m.latitude_e7 },
            |m: &mut LocationData| { &mut m.latitude_e7 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "longitude_e7",
            |m: &LocationData| { &m.longitude_e7 },
            |m: &mut LocationData| { &mut m.longitude_e7 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accuracy_e3",
            |m: &LocationData| { &m.accuracy_e3 },
            |m: &mut LocationData| { &mut m.accuracy_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "altitude_e2",
            |m: &LocationData| { &m.altitude_e2 },
            |m: &mut LocationData| { &mut m.altitude_e2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed_e3",
            |m: &LocationData| { &m.speed_e3 },
            |m: &mut LocationData| { &mut m.speed_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bearing_e6",
            |m: &LocationData| { &m.bearing_e6 },
            |m: &mut LocationData| { &mut m.bearing_e6 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocationData>(
            "LocationData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocationData {
    const NAME: &'static str = "LocationData";

    fn is_initialized(&self) -> bool {
        if self.latitude_e7.is_none() {
            return false;
        }
        if self.longitude_e7.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.latitude_e7 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.longitude_e7 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.accuracy_e3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.altitude_e2 = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.speed_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.bearing_e6 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.latitude_e7 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.longitude_e7 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.accuracy_e3 {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.altitude_e2 {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.speed_e3 {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.bearing_e6 {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.latitude_e7 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.longitude_e7 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.accuracy_e3 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.altitude_e2 {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.speed_e3 {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bearing_e6 {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocationData {
        LocationData::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.latitude_e7 = ::std::option::Option::None;
        self.longitude_e7 = ::std::option::Option::None;
        self.accuracy_e3 = ::std::option::Option::None;
        self.altitude_e2 = ::std::option::Option::None;
        self.speed_e3 = ::std::option::Option::None;
        self.bearing_e6 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocationData {
        static instance: LocationData = LocationData {
            timestamp: ::std::option::Option::None,
            latitude_e7: ::std::option::Option::None,
            longitude_e7: ::std::option::Option::None,
            accuracy_e3: ::std::option::Option::None,
            altitude_e2: ::std::option::Option::None,
            speed_e3: ::std::option::Option::None,
            bearing_e6: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocationData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocationData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CompassData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CompassData {
    // message fields
    // @@protoc_insertion_point(field:CompassData.bearing_e6)
    pub bearing_e6: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CompassData.pitch_e6)
    pub pitch_e6: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CompassData.roll_e6)
    pub roll_e6: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CompassData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CompassData {
    fn default() -> &'a CompassData {
        <CompassData as ::protobuf::Message>::default_instance()
    }
}

impl CompassData {
    pub fn new() -> CompassData {
        ::std::default::Default::default()
    }

    // required int32 bearing_e6 = 1;

    pub fn bearing_e6(&self) -> i32 {
        self.bearing_e6.unwrap_or(0)
    }

    pub fn clear_bearing_e6(&mut self) {
        self.bearing_e6 = ::std::option::Option::None;
    }

    pub fn has_bearing_e6(&self) -> bool {
        self.bearing_e6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bearing_e6(&mut self, v: i32) {
        self.bearing_e6 = ::std::option::Option::Some(v);
    }

    // optional int32 pitch_e6 = 2;

    pub fn pitch_e6(&self) -> i32 {
        self.pitch_e6.unwrap_or(0)
    }

    pub fn clear_pitch_e6(&mut self) {
        self.pitch_e6 = ::std::option::Option::None;
    }

    pub fn has_pitch_e6(&self) -> bool {
        self.pitch_e6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch_e6(&mut self, v: i32) {
        self.pitch_e6 = ::std::option::Option::Some(v);
    }

    // optional int32 roll_e6 = 3;

    pub fn roll_e6(&self) -> i32 {
        self.roll_e6.unwrap_or(0)
    }

    pub fn clear_roll_e6(&mut self) {
        self.roll_e6 = ::std::option::Option::None;
    }

    pub fn has_roll_e6(&self) -> bool {
        self.roll_e6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_e6(&mut self, v: i32) {
        self.roll_e6 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bearing_e6",
            |m: &CompassData| { &m.bearing_e6 },
            |m: &mut CompassData| { &mut m.bearing_e6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch_e6",
            |m: &CompassData| { &m.pitch_e6 },
            |m: &mut CompassData| { &mut m.pitch_e6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roll_e6",
            |m: &CompassData| { &m.roll_e6 },
            |m: &mut CompassData| { &mut m.roll_e6 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompassData>(
            "CompassData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CompassData {
    const NAME: &'static str = "CompassData";

    fn is_initialized(&self) -> bool {
        if self.bearing_e6.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bearing_e6 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pitch_e6 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.roll_e6 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bearing_e6 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pitch_e6 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.roll_e6 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bearing_e6 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pitch_e6 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.roll_e6 {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CompassData {
        CompassData::new()
    }

    fn clear(&mut self) {
        self.bearing_e6 = ::std::option::Option::None;
        self.pitch_e6 = ::std::option::Option::None;
        self.roll_e6 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CompassData {
        static instance: CompassData = CompassData {
            bearing_e6: ::std::option::Option::None,
            pitch_e6: ::std::option::Option::None,
            roll_e6: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CompassData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CompassData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CompassData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompassData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SpeedData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpeedData {
    // message fields
    // @@protoc_insertion_point(field:SpeedData.speed_e3)
    pub speed_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SpeedData.cruise_engaged)
    pub cruise_engaged: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SpeedData.cruise_set_speed)
    pub cruise_set_speed: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SpeedData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SpeedData {
    fn default() -> &'a SpeedData {
        <SpeedData as ::protobuf::Message>::default_instance()
    }
}

impl SpeedData {
    pub fn new() -> SpeedData {
        ::std::default::Default::default()
    }

    // required int32 speed_e3 = 1;

    pub fn speed_e3(&self) -> i32 {
        self.speed_e3.unwrap_or(0)
    }

    pub fn clear_speed_e3(&mut self) {
        self.speed_e3 = ::std::option::Option::None;
    }

    pub fn has_speed_e3(&self) -> bool {
        self.speed_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed_e3(&mut self, v: i32) {
        self.speed_e3 = ::std::option::Option::Some(v);
    }

    // optional bool cruise_engaged = 2;

    pub fn cruise_engaged(&self) -> bool {
        self.cruise_engaged.unwrap_or(false)
    }

    pub fn clear_cruise_engaged(&mut self) {
        self.cruise_engaged = ::std::option::Option::None;
    }

    pub fn has_cruise_engaged(&self) -> bool {
        self.cruise_engaged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cruise_engaged(&mut self, v: bool) {
        self.cruise_engaged = ::std::option::Option::Some(v);
    }

    // optional int32 cruise_set_speed = 4;

    pub fn cruise_set_speed(&self) -> i32 {
        self.cruise_set_speed.unwrap_or(0)
    }

    pub fn clear_cruise_set_speed(&mut self) {
        self.cruise_set_speed = ::std::option::Option::None;
    }

    pub fn has_cruise_set_speed(&self) -> bool {
        self.cruise_set_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cruise_set_speed(&mut self, v: i32) {
        self.cruise_set_speed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed_e3",
            |m: &SpeedData| { &m.speed_e3 },
            |m: &mut SpeedData| { &mut m.speed_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cruise_engaged",
            |m: &SpeedData| { &m.cruise_engaged },
            |m: &mut SpeedData| { &mut m.cruise_engaged },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cruise_set_speed",
            |m: &SpeedData| { &m.cruise_set_speed },
            |m: &mut SpeedData| { &mut m.cruise_set_speed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpeedData>(
            "SpeedData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SpeedData {
    const NAME: &'static str = "SpeedData";

    fn is_initialized(&self) -> bool {
        if self.speed_e3.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.speed_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.cruise_engaged = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.cruise_set_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.speed_e3 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cruise_engaged {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cruise_set_speed {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.speed_e3 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cruise_engaged {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.cruise_set_speed {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SpeedData {
        SpeedData::new()
    }

    fn clear(&mut self) {
        self.speed_e3 = ::std::option::Option::None;
        self.cruise_engaged = ::std::option::Option::None;
        self.cruise_set_speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SpeedData {
        static instance: SpeedData = SpeedData {
            speed_e3: ::std::option::Option::None,
            cruise_engaged: ::std::option::Option::None,
            cruise_set_speed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SpeedData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SpeedData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SpeedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpeedData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RpmData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RpmData {
    // message fields
    // @@protoc_insertion_point(field:RpmData.rpm_e3)
    pub rpm_e3: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:RpmData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RpmData {
    fn default() -> &'a RpmData {
        <RpmData as ::protobuf::Message>::default_instance()
    }
}

impl RpmData {
    pub fn new() -> RpmData {
        ::std::default::Default::default()
    }

    // required int32 rpm_e3 = 1;

    pub fn rpm_e3(&self) -> i32 {
        self.rpm_e3.unwrap_or(0)
    }

    pub fn clear_rpm_e3(&mut self) {
        self.rpm_e3 = ::std::option::Option::None;
    }

    pub fn has_rpm_e3(&self) -> bool {
        self.rpm_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpm_e3(&mut self, v: i32) {
        self.rpm_e3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpm_e3",
            |m: &RpmData| { &m.rpm_e3 },
            |m: &mut RpmData| { &mut m.rpm_e3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RpmData>(
            "RpmData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RpmData {
    const NAME: &'static str = "RpmData";

    fn is_initialized(&self) -> bool {
        if self.rpm_e3.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rpm_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rpm_e3 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rpm_e3 {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RpmData {
        RpmData::new()
    }

    fn clear(&mut self) {
        self.rpm_e3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RpmData {
        static instance: RpmData = RpmData {
            rpm_e3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RpmData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RpmData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RpmData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpmData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OdometerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OdometerData {
    // message fields
    // @@protoc_insertion_point(field:OdometerData.kms_e1)
    pub kms_e1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OdometerData.trip_kms_e1)
    pub trip_kms_e1: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OdometerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OdometerData {
    fn default() -> &'a OdometerData {
        <OdometerData as ::protobuf::Message>::default_instance()
    }
}

impl OdometerData {
    pub fn new() -> OdometerData {
        ::std::default::Default::default()
    }

    // required int32 kms_e1 = 1;

    pub fn kms_e1(&self) -> i32 {
        self.kms_e1.unwrap_or(0)
    }

    pub fn clear_kms_e1(&mut self) {
        self.kms_e1 = ::std::option::Option::None;
    }

    pub fn has_kms_e1(&self) -> bool {
        self.kms_e1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kms_e1(&mut self, v: i32) {
        self.kms_e1 = ::std::option::Option::Some(v);
    }

    // optional int32 trip_kms_e1 = 2;

    pub fn trip_kms_e1(&self) -> i32 {
        self.trip_kms_e1.unwrap_or(0)
    }

    pub fn clear_trip_kms_e1(&mut self) {
        self.trip_kms_e1 = ::std::option::Option::None;
    }

    pub fn has_trip_kms_e1(&self) -> bool {
        self.trip_kms_e1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trip_kms_e1(&mut self, v: i32) {
        self.trip_kms_e1 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kms_e1",
            |m: &OdometerData| { &m.kms_e1 },
            |m: &mut OdometerData| { &mut m.kms_e1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trip_kms_e1",
            |m: &OdometerData| { &m.trip_kms_e1 },
            |m: &mut OdometerData| { &mut m.trip_kms_e1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OdometerData>(
            "OdometerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OdometerData {
    const NAME: &'static str = "OdometerData";

    fn is_initialized(&self) -> bool {
        if self.kms_e1.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kms_e1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.trip_kms_e1 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kms_e1 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.trip_kms_e1 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kms_e1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.trip_kms_e1 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OdometerData {
        OdometerData::new()
    }

    fn clear(&mut self) {
        self.kms_e1 = ::std::option::Option::None;
        self.trip_kms_e1 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OdometerData {
        static instance: OdometerData = OdometerData {
            kms_e1: ::std::option::Option::None,
            trip_kms_e1: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OdometerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OdometerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OdometerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OdometerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FuelData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FuelData {
    // message fields
    // @@protoc_insertion_point(field:FuelData.fuel_level)
    pub fuel_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:FuelData.range)
    pub range: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:FuelData.low_fuel_warning)
    pub low_fuel_warning: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:FuelData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FuelData {
    fn default() -> &'a FuelData {
        <FuelData as ::protobuf::Message>::default_instance()
    }
}

impl FuelData {
    pub fn new() -> FuelData {
        ::std::default::Default::default()
    }

    // optional int32 fuel_level = 1;

    pub fn fuel_level(&self) -> i32 {
        self.fuel_level.unwrap_or(0)
    }

    pub fn clear_fuel_level(&mut self) {
        self.fuel_level = ::std::option::Option::None;
    }

    pub fn has_fuel_level(&self) -> bool {
        self.fuel_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fuel_level(&mut self, v: i32) {
        self.fuel_level = ::std::option::Option::Some(v);
    }

    // optional int32 range = 2;

    pub fn range(&self) -> i32 {
        self.range.unwrap_or(0)
    }

    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = ::std::option::Option::Some(v);
    }

    // optional bool low_fuel_warning = 3;

    pub fn low_fuel_warning(&self) -> bool {
        self.low_fuel_warning.unwrap_or(false)
    }

    pub fn clear_low_fuel_warning(&mut self) {
        self.low_fuel_warning = ::std::option::Option::None;
    }

    pub fn has_low_fuel_warning(&self) -> bool {
        self.low_fuel_warning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_fuel_warning(&mut self, v: bool) {
        self.low_fuel_warning = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fuel_level",
            |m: &FuelData| { &m.fuel_level },
            |m: &mut FuelData| { &mut m.fuel_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range",
            |m: &FuelData| { &m.range },
            |m: &mut FuelData| { &mut m.range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_fuel_warning",
            |m: &FuelData| { &m.low_fuel_warning },
            |m: &mut FuelData| { &mut m.low_fuel_warning },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FuelData>(
            "FuelData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FuelData {
    const NAME: &'static str = "FuelData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fuel_level = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.range = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.low_fuel_warning = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fuel_level {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.range {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.low_fuel_warning {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fuel_level {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.range {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.low_fuel_warning {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FuelData {
        FuelData::new()
    }

    fn clear(&mut self) {
        self.fuel_level = ::std::option::Option::None;
        self.range = ::std::option::Option::None;
        self.low_fuel_warning = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FuelData {
        static instance: FuelData = FuelData {
            fuel_level: ::std::option::Option::None,
            range: ::std::option::Option::None,
            low_fuel_warning: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FuelData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FuelData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FuelData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FuelData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ParkingBrakeData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParkingBrakeData {
    // message fields
    // @@protoc_insertion_point(field:ParkingBrakeData.parking_brake)
    pub parking_brake: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ParkingBrakeData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParkingBrakeData {
    fn default() -> &'a ParkingBrakeData {
        <ParkingBrakeData as ::protobuf::Message>::default_instance()
    }
}

impl ParkingBrakeData {
    pub fn new() -> ParkingBrakeData {
        ::std::default::Default::default()
    }

    // required bool parking_brake = 1;

    pub fn parking_brake(&self) -> bool {
        self.parking_brake.unwrap_or(false)
    }

    pub fn clear_parking_brake(&mut self) {
        self.parking_brake = ::std::option::Option::None;
    }

    pub fn has_parking_brake(&self) -> bool {
        self.parking_brake.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parking_brake(&mut self, v: bool) {
        self.parking_brake = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parking_brake",
            |m: &ParkingBrakeData| { &m.parking_brake },
            |m: &mut ParkingBrakeData| { &mut m.parking_brake },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParkingBrakeData>(
            "ParkingBrakeData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParkingBrakeData {
    const NAME: &'static str = "ParkingBrakeData";

    fn is_initialized(&self) -> bool {
        if self.parking_brake.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.parking_brake = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.parking_brake {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.parking_brake {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParkingBrakeData {
        ParkingBrakeData::new()
    }

    fn clear(&mut self) {
        self.parking_brake = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParkingBrakeData {
        static instance: ParkingBrakeData = ParkingBrakeData {
            parking_brake: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParkingBrakeData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParkingBrakeData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParkingBrakeData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParkingBrakeData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GearData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GearData {
    // message fields
    // @@protoc_insertion_point(field:GearData.gear)
    pub gear: ::std::option::Option<::protobuf::EnumOrUnknown<Gear>>,
    // special fields
    // @@protoc_insertion_point(special_field:GearData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GearData {
    fn default() -> &'a GearData {
        <GearData as ::protobuf::Message>::default_instance()
    }
}

impl GearData {
    pub fn new() -> GearData {
        ::std::default::Default::default()
    }

    // required .Gear gear = 1;

    pub fn gear(&self) -> Gear {
        match self.gear {
            Some(e) => e.enum_value_or(Gear::GEAR_NEUTRAL),
            None => Gear::GEAR_NEUTRAL,
        }
    }

    pub fn clear_gear(&mut self) {
        self.gear = ::std::option::Option::None;
    }

    pub fn has_gear(&self) -> bool {
        self.gear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gear(&mut self, v: Gear) {
        self.gear = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gear",
            |m: &GearData| { &m.gear },
            |m: &mut GearData| { &mut m.gear },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GearData>(
            "GearData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GearData {
    const NAME: &'static str = "GearData";

    fn is_initialized(&self) -> bool {
        if self.gear.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gear = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gear {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gear {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GearData {
        GearData::new()
    }

    fn clear(&mut self) {
        self.gear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GearData {
        static instance: GearData = GearData {
            gear: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GearData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GearData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GearData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GearData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DiagnosticsData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DiagnosticsData {
    // message fields
    // @@protoc_insertion_point(field:DiagnosticsData.dtc)
    pub dtc: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:DiagnosticsData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiagnosticsData {
    fn default() -> &'a DiagnosticsData {
        <DiagnosticsData as ::protobuf::Message>::default_instance()
    }
}

impl DiagnosticsData {
    pub fn new() -> DiagnosticsData {
        ::std::default::Default::default()
    }

    // optional bytes dtc = 1;

    pub fn dtc(&self) -> &[u8] {
        match self.dtc.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dtc(&mut self) {
        self.dtc = ::std::option::Option::None;
    }

    pub fn has_dtc(&self) -> bool {
        self.dtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtc(&mut self, v: ::std::vec::Vec<u8>) {
        self.dtc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dtc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dtc.is_none() {
            self.dtc = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dtc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dtc(&mut self) -> ::std::vec::Vec<u8> {
        self.dtc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dtc",
            |m: &DiagnosticsData| { &m.dtc },
            |m: &mut DiagnosticsData| { &mut m.dtc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiagnosticsData>(
            "DiagnosticsData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiagnosticsData {
    const NAME: &'static str = "DiagnosticsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dtc = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dtc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dtc.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiagnosticsData {
        DiagnosticsData::new()
    }

    fn clear(&mut self) {
        self.dtc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiagnosticsData {
        static instance: DiagnosticsData = DiagnosticsData {
            dtc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiagnosticsData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiagnosticsData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiagnosticsData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiagnosticsData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NightModeData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NightModeData {
    // message fields
    // @@protoc_insertion_point(field:NightModeData.night_mode)
    pub night_mode: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:NightModeData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NightModeData {
    fn default() -> &'a NightModeData {
        <NightModeData as ::protobuf::Message>::default_instance()
    }
}

impl NightModeData {
    pub fn new() -> NightModeData {
        ::std::default::Default::default()
    }

    // optional bool night_mode = 1;

    pub fn night_mode(&self) -> bool {
        self.night_mode.unwrap_or(false)
    }

    pub fn clear_night_mode(&mut self) {
        self.night_mode = ::std::option::Option::None;
    }

    pub fn has_night_mode(&self) -> bool {
        self.night_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_night_mode(&mut self, v: bool) {
        self.night_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "night_mode",
            |m: &NightModeData| { &m.night_mode },
            |m: &mut NightModeData| { &mut m.night_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NightModeData>(
            "NightModeData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NightModeData {
    const NAME: &'static str = "NightModeData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.night_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.night_mode {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.night_mode {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NightModeData {
        NightModeData::new()
    }

    fn clear(&mut self) {
        self.night_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NightModeData {
        static instance: NightModeData = NightModeData {
            night_mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NightModeData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NightModeData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NightModeData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NightModeData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EnvironmentData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnvironmentData {
    // message fields
    // @@protoc_insertion_point(field:EnvironmentData.temperature_e3)
    pub temperature_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:EnvironmentData.pressure_e3)
    pub pressure_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:EnvironmentData.rain)
    pub rain: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:EnvironmentData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnvironmentData {
    fn default() -> &'a EnvironmentData {
        <EnvironmentData as ::protobuf::Message>::default_instance()
    }
}

impl EnvironmentData {
    pub fn new() -> EnvironmentData {
        ::std::default::Default::default()
    }

    // optional int32 temperature_e3 = 1;

    pub fn temperature_e3(&self) -> i32 {
        self.temperature_e3.unwrap_or(0)
    }

    pub fn clear_temperature_e3(&mut self) {
        self.temperature_e3 = ::std::option::Option::None;
    }

    pub fn has_temperature_e3(&self) -> bool {
        self.temperature_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature_e3(&mut self, v: i32) {
        self.temperature_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 pressure_e3 = 2;

    pub fn pressure_e3(&self) -> i32 {
        self.pressure_e3.unwrap_or(0)
    }

    pub fn clear_pressure_e3(&mut self) {
        self.pressure_e3 = ::std::option::Option::None;
    }

    pub fn has_pressure_e3(&self) -> bool {
        self.pressure_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pressure_e3(&mut self, v: i32) {
        self.pressure_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 rain = 3;

    pub fn rain(&self) -> i32 {
        self.rain.unwrap_or(0)
    }

    pub fn clear_rain(&mut self) {
        self.rain = ::std::option::Option::None;
    }

    pub fn has_rain(&self) -> bool {
        self.rain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rain(&mut self, v: i32) {
        self.rain = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "temperature_e3",
            |m: &EnvironmentData| { &m.temperature_e3 },
            |m: &mut EnvironmentData| { &mut m.temperature_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pressure_e3",
            |m: &EnvironmentData| { &m.pressure_e3 },
            |m: &mut EnvironmentData| { &mut m.pressure_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rain",
            |m: &EnvironmentData| { &m.rain },
            |m: &mut EnvironmentData| { &mut m.rain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvironmentData>(
            "EnvironmentData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnvironmentData {
    const NAME: &'static str = "EnvironmentData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.temperature_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pressure_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.rain = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.temperature_e3 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pressure_e3 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rain {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.temperature_e3 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pressure_e3 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rain {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnvironmentData {
        EnvironmentData::new()
    }

    fn clear(&mut self) {
        self.temperature_e3 = ::std::option::Option::None;
        self.pressure_e3 = ::std::option::Option::None;
        self.rain = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnvironmentData {
        static instance: EnvironmentData = EnvironmentData {
            temperature_e3: ::std::option::Option::None,
            pressure_e3: ::std::option::Option::None,
            rain: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnvironmentData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnvironmentData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnvironmentData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvironmentData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HvacData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HvacData {
    // message fields
    // @@protoc_insertion_point(field:HvacData.target_temperature_e3)
    pub target_temperature_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:HvacData.current_temperature_e3)
    pub current_temperature_e3: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:HvacData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HvacData {
    fn default() -> &'a HvacData {
        <HvacData as ::protobuf::Message>::default_instance()
    }
}

impl HvacData {
    pub fn new() -> HvacData {
        ::std::default::Default::default()
    }

    // optional int32 target_temperature_e3 = 1;

    pub fn target_temperature_e3(&self) -> i32 {
        self.target_temperature_e3.unwrap_or(0)
    }

    pub fn clear_target_temperature_e3(&mut self) {
        self.target_temperature_e3 = ::std::option::Option::None;
    }

    pub fn has_target_temperature_e3(&self) -> bool {
        self.target_temperature_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_e3(&mut self, v: i32) {
        self.target_temperature_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 current_temperature_e3 = 2;

    pub fn current_temperature_e3(&self) -> i32 {
        self.current_temperature_e3.unwrap_or(0)
    }

    pub fn clear_current_temperature_e3(&mut self) {
        self.current_temperature_e3 = ::std::option::Option::None;
    }

    pub fn has_current_temperature_e3(&self) -> bool {
        self.current_temperature_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_temperature_e3(&mut self, v: i32) {
        self.current_temperature_e3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_temperature_e3",
            |m: &HvacData| { &m.target_temperature_e3 },
            |m: &mut HvacData| { &mut m.target_temperature_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_temperature_e3",
            |m: &HvacData| { &m.current_temperature_e3 },
            |m: &mut HvacData| { &mut m.current_temperature_e3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HvacData>(
            "HvacData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HvacData {
    const NAME: &'static str = "HvacData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_temperature_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.current_temperature_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_temperature_e3 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.current_temperature_e3 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_temperature_e3 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.current_temperature_e3 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HvacData {
        HvacData::new()
    }

    fn clear(&mut self) {
        self.target_temperature_e3 = ::std::option::Option::None;
        self.current_temperature_e3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HvacData {
        static instance: HvacData = HvacData {
            target_temperature_e3: ::std::option::Option::None,
            current_temperature_e3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HvacData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HvacData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HvacData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HvacData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DrivingStatusData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DrivingStatusData {
    // message fields
    // @@protoc_insertion_point(field:DrivingStatusData.status)
    pub status: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:DrivingStatusData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DrivingStatusData {
    fn default() -> &'a DrivingStatusData {
        <DrivingStatusData as ::protobuf::Message>::default_instance()
    }
}

impl DrivingStatusData {
    pub fn new() -> DrivingStatusData {
        ::std::default::Default::default()
    }

    // required int32 status = 1;

    pub fn status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DrivingStatusData| { &m.status },
            |m: &mut DrivingStatusData| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DrivingStatusData>(
            "DrivingStatusData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DrivingStatusData {
    const NAME: &'static str = "DrivingStatusData";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DrivingStatusData {
        DrivingStatusData::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DrivingStatusData {
        static instance: DrivingStatusData = DrivingStatusData {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DrivingStatusData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DrivingStatusData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DrivingStatusData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DrivingStatusData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeadReckoningData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeadReckoningData {
    // message fields
    // @@protoc_insertion_point(field:DeadReckoningData.steering_angle_e1)
    pub steering_angle_e1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeadReckoningData.wheel_speed_e3)
    pub wheel_speed_e3: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:DeadReckoningData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeadReckoningData {
    fn default() -> &'a DeadReckoningData {
        <DeadReckoningData as ::protobuf::Message>::default_instance()
    }
}

impl DeadReckoningData {
    pub fn new() -> DeadReckoningData {
        ::std::default::Default::default()
    }

    // optional int32 steering_angle_e1 = 1;

    pub fn steering_angle_e1(&self) -> i32 {
        self.steering_angle_e1.unwrap_or(0)
    }

    pub fn clear_steering_angle_e1(&mut self) {
        self.steering_angle_e1 = ::std::option::Option::None;
    }

    pub fn has_steering_angle_e1(&self) -> bool {
        self.steering_angle_e1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steering_angle_e1(&mut self, v: i32) {
        self.steering_angle_e1 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steering_angle_e1",
            |m: &DeadReckoningData| { &m.steering_angle_e1 },
            |m: &mut DeadReckoningData| { &mut m.steering_angle_e1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wheel_speed_e3",
            |m: &DeadReckoningData| { &m.wheel_speed_e3 },
            |m: &mut DeadReckoningData| { &mut m.wheel_speed_e3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeadReckoningData>(
            "DeadReckoningData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeadReckoningData {
    const NAME: &'static str = "DeadReckoningData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steering_angle_e1 = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.wheel_speed_e3)?;
                },
                16 => {
                    self.wheel_speed_e3.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steering_angle_e1 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.wheel_speed_e3 {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steering_angle_e1 {
            os.write_int32(1, v)?;
        }
        for v in &self.wheel_speed_e3 {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeadReckoningData {
        DeadReckoningData::new()
    }

    fn clear(&mut self) {
        self.steering_angle_e1 = ::std::option::Option::None;
        self.wheel_speed_e3.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeadReckoningData {
        static instance: DeadReckoningData = DeadReckoningData {
            steering_angle_e1: ::std::option::Option::None,
            wheel_speed_e3: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeadReckoningData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeadReckoningData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeadReckoningData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeadReckoningData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LightData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LightData {
    // message fields
    // @@protoc_insertion_point(field:LightData.head_light_state)
    pub head_light_state: ::std::option::Option<::protobuf::EnumOrUnknown<HeadLightState>>,
    // @@protoc_insertion_point(field:LightData.turn_indicator_state)
    pub turn_indicator_state: ::std::option::Option<::protobuf::EnumOrUnknown<TurnIndicatorState>>,
    // @@protoc_insertion_point(field:LightData.hazard_lights_on)
    pub hazard_lights_on: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:LightData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LightData {
    fn default() -> &'a LightData {
        <LightData as ::protobuf::Message>::default_instance()
    }
}

impl LightData {
    pub fn new() -> LightData {
        ::std::default::Default::default()
    }

    // optional .HeadLightState head_light_state = 1;

    pub fn head_light_state(&self) -> HeadLightState {
        match self.head_light_state {
            Some(e) => e.enum_value_or(HeadLightState::HEAD_LIGHT_STATE_OFF),
            None => HeadLightState::HEAD_LIGHT_STATE_OFF,
        }
    }

    pub fn clear_head_light_state(&mut self) {
        self.head_light_state = ::std::option::Option::None;
    }

    pub fn has_head_light_state(&self) -> bool {
        self.head_light_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_head_light_state(&mut self, v: HeadLightState) {
        self.head_light_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .TurnIndicatorState turn_indicator_state = 2;

    pub fn turn_indicator_state(&self) -> TurnIndicatorState {
        match self.turn_indicator_state {
            Some(e) => e.enum_value_or(TurnIndicatorState::TURN_INDICATOR_NONE),
            None => TurnIndicatorState::TURN_INDICATOR_NONE,
        }
    }

    pub fn clear_turn_indicator_state(&mut self) {
        self.turn_indicator_state = ::std::option::Option::None;
    }

    pub fn has_turn_indicator_state(&self) -> bool {
        self.turn_indicator_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_indicator_state(&mut self, v: TurnIndicatorState) {
        self.turn_indicator_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool hazard_lights_on = 3;

    pub fn hazard_lights_on(&self) -> bool {
        self.hazard_lights_on.unwrap_or(false)
    }

    pub fn clear_hazard_lights_on(&mut self) {
        self.hazard_lights_on = ::std::option::Option::None;
    }

    pub fn has_hazard_lights_on(&self) -> bool {
        self.hazard_lights_on.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hazard_lights_on(&mut self, v: bool) {
        self.hazard_lights_on = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "head_light_state",
            |m: &LightData| { &m.head_light_state },
            |m: &mut LightData| { &mut m.head_light_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turn_indicator_state",
            |m: &LightData| { &m.turn_indicator_state },
            |m: &mut LightData| { &mut m.turn_indicator_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hazard_lights_on",
            |m: &LightData| { &m.hazard_lights_on },
            |m: &mut LightData| { &mut m.hazard_lights_on },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightData>(
            "LightData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightData {
    const NAME: &'static str = "LightData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.head_light_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.turn_indicator_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.hazard_lights_on = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.head_light_state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.turn_indicator_state {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.hazard_lights_on {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.head_light_state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.turn_indicator_state {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.hazard_lights_on {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightData {
        LightData::new()
    }

    fn clear(&mut self) {
        self.head_light_state = ::std::option::Option::None;
        self.turn_indicator_state = ::std::option::Option::None;
        self.hazard_lights_on = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightData {
        static instance: LightData = LightData {
            head_light_state: ::std::option::Option::None,
            turn_indicator_state: ::std::option::Option::None,
            hazard_lights_on: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LightData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PassengerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PassengerData {
    // message fields
    // @@protoc_insertion_point(field:PassengerData.passenger_present)
    pub passenger_present: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:PassengerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PassengerData {
    fn default() -> &'a PassengerData {
        <PassengerData as ::protobuf::Message>::default_instance()
    }
}

impl PassengerData {
    pub fn new() -> PassengerData {
        ::std::default::Default::default()
    }

    // optional bool passenger_present = 1;

    pub fn passenger_present(&self) -> bool {
        self.passenger_present.unwrap_or(false)
    }

    pub fn clear_passenger_present(&mut self) {
        self.passenger_present = ::std::option::Option::None;
    }

    pub fn has_passenger_present(&self) -> bool {
        self.passenger_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passenger_present(&mut self, v: bool) {
        self.passenger_present = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passenger_present",
            |m: &PassengerData| { &m.passenger_present },
            |m: &mut PassengerData| { &mut m.passenger_present },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PassengerData>(
            "PassengerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PassengerData {
    const NAME: &'static str = "PassengerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.passenger_present = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.passenger_present {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.passenger_present {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PassengerData {
        PassengerData::new()
    }

    fn clear(&mut self) {
        self.passenger_present = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PassengerData {
        static instance: PassengerData = PassengerData {
            passenger_present: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PassengerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PassengerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PassengerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassengerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DoorData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DoorData {
    // message fields
    // @@protoc_insertion_point(field:DoorData.hood_open)
    pub hood_open: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DoorData.trunk_open)
    pub trunk_open: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DoorData.door_open)
    pub door_open: ::std::vec::Vec<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:DoorData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoorData {
    fn default() -> &'a DoorData {
        <DoorData as ::protobuf::Message>::default_instance()
    }
}

impl DoorData {
    pub fn new() -> DoorData {
        ::std::default::Default::default()
    }

    // optional bool hood_open = 1;

    pub fn hood_open(&self) -> bool {
        self.hood_open.unwrap_or(false)
    }

    pub fn clear_hood_open(&mut self) {
        self.hood_open = ::std::option::Option::None;
    }

    pub fn has_hood_open(&self) -> bool {
        self.hood_open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hood_open(&mut self, v: bool) {
        self.hood_open = ::std::option::Option::Some(v);
    }

    // optional bool trunk_open = 2;

    pub fn trunk_open(&self) -> bool {
        self.trunk_open.unwrap_or(false)
    }

    pub fn clear_trunk_open(&mut self) {
        self.trunk_open = ::std::option::Option::None;
    }

    pub fn has_trunk_open(&self) -> bool {
        self.trunk_open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trunk_open(&mut self, v: bool) {
        self.trunk_open = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hood_open",
            |m: &DoorData| { &m.hood_open },
            |m: &mut DoorData| { &mut m.hood_open },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trunk_open",
            |m: &DoorData| { &m.trunk_open },
            |m: &mut DoorData| { &mut m.trunk_open },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "door_open",
            |m: &DoorData| { &m.door_open },
            |m: &mut DoorData| { &mut m.door_open },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoorData>(
            "DoorData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoorData {
    const NAME: &'static str = "DoorData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hood_open = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.trunk_open = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_bool_into(&mut self.door_open)?;
                },
                24 => {
                    self.door_open.push(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hood_open {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trunk_open {
            my_size += 1 + 1;
        }
        my_size += 2 * self.door_open.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hood_open {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.trunk_open {
            os.write_bool(2, v)?;
        }
        for v in &self.door_open {
            os.write_bool(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoorData {
        DoorData::new()
    }

    fn clear(&mut self) {
        self.hood_open = ::std::option::Option::None;
        self.trunk_open = ::std::option::Option::None;
        self.door_open.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoorData {
        static instance: DoorData = DoorData {
            hood_open: ::std::option::Option::None,
            trunk_open: ::std::option::Option::None,
            door_open: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoorData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoorData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoorData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoorData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TirePressureData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TirePressureData {
    // message fields
    // @@protoc_insertion_point(field:TirePressureData.tire_pressures_e2)
    pub tire_pressures_e2: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:TirePressureData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TirePressureData {
    fn default() -> &'a TirePressureData {
        <TirePressureData as ::protobuf::Message>::default_instance()
    }
}

impl TirePressureData {
    pub fn new() -> TirePressureData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tire_pressures_e2",
            |m: &TirePressureData| { &m.tire_pressures_e2 },
            |m: &mut TirePressureData| { &mut m.tire_pressures_e2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TirePressureData>(
            "TirePressureData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TirePressureData {
    const NAME: &'static str = "TirePressureData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.tire_pressures_e2)?;
                },
                8 => {
                    self.tire_pressures_e2.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tire_pressures_e2 {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tire_pressures_e2 {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TirePressureData {
        TirePressureData::new()
    }

    fn clear(&mut self) {
        self.tire_pressures_e2.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TirePressureData {
        static instance: TirePressureData = TirePressureData {
            tire_pressures_e2: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TirePressureData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TirePressureData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TirePressureData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TirePressureData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AccelerometerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccelerometerData {
    // message fields
    // @@protoc_insertion_point(field:AccelerometerData.acceleration_x_e3)
    pub acceleration_x_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:AccelerometerData.acceleration_y_e3)
    pub acceleration_y_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:AccelerometerData.acceleration_z_e3)
    pub acceleration_z_e3: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:AccelerometerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccelerometerData {
    fn default() -> &'a AccelerometerData {
        <AccelerometerData as ::protobuf::Message>::default_instance()
    }
}

impl AccelerometerData {
    pub fn new() -> AccelerometerData {
        ::std::default::Default::default()
    }

    // optional int32 acceleration_x_e3 = 1;

    pub fn acceleration_x_e3(&self) -> i32 {
        self.acceleration_x_e3.unwrap_or(0)
    }

    pub fn clear_acceleration_x_e3(&mut self) {
        self.acceleration_x_e3 = ::std::option::Option::None;
    }

    pub fn has_acceleration_x_e3(&self) -> bool {
        self.acceleration_x_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleration_x_e3(&mut self, v: i32) {
        self.acceleration_x_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 acceleration_y_e3 = 2;

    pub fn acceleration_y_e3(&self) -> i32 {
        self.acceleration_y_e3.unwrap_or(0)
    }

    pub fn clear_acceleration_y_e3(&mut self) {
        self.acceleration_y_e3 = ::std::option::Option::None;
    }

    pub fn has_acceleration_y_e3(&self) -> bool {
        self.acceleration_y_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleration_y_e3(&mut self, v: i32) {
        self.acceleration_y_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 acceleration_z_e3 = 3;

    pub fn acceleration_z_e3(&self) -> i32 {
        self.acceleration_z_e3.unwrap_or(0)
    }

    pub fn clear_acceleration_z_e3(&mut self) {
        self.acceleration_z_e3 = ::std::option::Option::None;
    }

    pub fn has_acceleration_z_e3(&self) -> bool {
        self.acceleration_z_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleration_z_e3(&mut self, v: i32) {
        self.acceleration_z_e3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acceleration_x_e3",
            |m: &AccelerometerData| { &m.acceleration_x_e3 },
            |m: &mut AccelerometerData| { &mut m.acceleration_x_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acceleration_y_e3",
            |m: &AccelerometerData| { &m.acceleration_y_e3 },
            |m: &mut AccelerometerData| { &mut m.acceleration_y_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acceleration_z_e3",
            |m: &AccelerometerData| { &m.acceleration_z_e3 },
            |m: &mut AccelerometerData| { &mut m.acceleration_z_e3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccelerometerData>(
            "AccelerometerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccelerometerData {
    const NAME: &'static str = "AccelerometerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.acceleration_x_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.acceleration_y_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.acceleration_z_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.acceleration_x_e3 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.acceleration_y_e3 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.acceleration_z_e3 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.acceleration_x_e3 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.acceleration_y_e3 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.acceleration_z_e3 {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccelerometerData {
        AccelerometerData::new()
    }

    fn clear(&mut self) {
        self.acceleration_x_e3 = ::std::option::Option::None;
        self.acceleration_y_e3 = ::std::option::Option::None;
        self.acceleration_z_e3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccelerometerData {
        static instance: AccelerometerData = AccelerometerData {
            acceleration_x_e3: ::std::option::Option::None,
            acceleration_y_e3: ::std::option::Option::None,
            acceleration_z_e3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccelerometerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccelerometerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccelerometerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccelerometerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GyroscopeData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GyroscopeData {
    // message fields
    // @@protoc_insertion_point(field:GyroscopeData.rotation_speed_x_e3)
    pub rotation_speed_x_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GyroscopeData.rotation_speed_y_e3)
    pub rotation_speed_y_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GyroscopeData.rotation_speed_z_e3)
    pub rotation_speed_z_e3: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GyroscopeData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GyroscopeData {
    fn default() -> &'a GyroscopeData {
        <GyroscopeData as ::protobuf::Message>::default_instance()
    }
}

impl GyroscopeData {
    pub fn new() -> GyroscopeData {
        ::std::default::Default::default()
    }

    // optional int32 rotation_speed_x_e3 = 1;

    pub fn rotation_speed_x_e3(&self) -> i32 {
        self.rotation_speed_x_e3.unwrap_or(0)
    }

    pub fn clear_rotation_speed_x_e3(&mut self) {
        self.rotation_speed_x_e3 = ::std::option::Option::None;
    }

    pub fn has_rotation_speed_x_e3(&self) -> bool {
        self.rotation_speed_x_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation_speed_x_e3(&mut self, v: i32) {
        self.rotation_speed_x_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 rotation_speed_y_e3 = 2;

    pub fn rotation_speed_y_e3(&self) -> i32 {
        self.rotation_speed_y_e3.unwrap_or(0)
    }

    pub fn clear_rotation_speed_y_e3(&mut self) {
        self.rotation_speed_y_e3 = ::std::option::Option::None;
    }

    pub fn has_rotation_speed_y_e3(&self) -> bool {
        self.rotation_speed_y_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation_speed_y_e3(&mut self, v: i32) {
        self.rotation_speed_y_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 rotation_speed_z_e3 = 3;

    pub fn rotation_speed_z_e3(&self) -> i32 {
        self.rotation_speed_z_e3.unwrap_or(0)
    }

    pub fn clear_rotation_speed_z_e3(&mut self) {
        self.rotation_speed_z_e3 = ::std::option::Option::None;
    }

    pub fn has_rotation_speed_z_e3(&self) -> bool {
        self.rotation_speed_z_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation_speed_z_e3(&mut self, v: i32) {
        self.rotation_speed_z_e3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rotation_speed_x_e3",
            |m: &GyroscopeData| { &m.rotation_speed_x_e3 },
            |m: &mut GyroscopeData| { &mut m.rotation_speed_x_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rotation_speed_y_e3",
            |m: &GyroscopeData| { &m.rotation_speed_y_e3 },
            |m: &mut GyroscopeData| { &mut m.rotation_speed_y_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rotation_speed_z_e3",
            |m: &GyroscopeData| { &m.rotation_speed_z_e3 },
            |m: &mut GyroscopeData| { &mut m.rotation_speed_z_e3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GyroscopeData>(
            "GyroscopeData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GyroscopeData {
    const NAME: &'static str = "GyroscopeData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rotation_speed_x_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.rotation_speed_y_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.rotation_speed_z_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rotation_speed_x_e3 {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.rotation_speed_y_e3 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rotation_speed_z_e3 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rotation_speed_x_e3 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rotation_speed_y_e3 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rotation_speed_z_e3 {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GyroscopeData {
        GyroscopeData::new()
    }

    fn clear(&mut self) {
        self.rotation_speed_x_e3 = ::std::option::Option::None;
        self.rotation_speed_y_e3 = ::std::option::Option::None;
        self.rotation_speed_z_e3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GyroscopeData {
        static instance: GyroscopeData = GyroscopeData {
            rotation_speed_x_e3: ::std::option::Option::None,
            rotation_speed_y_e3: ::std::option::Option::None,
            rotation_speed_z_e3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GyroscopeData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GyroscopeData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GyroscopeData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GyroscopeData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GpsSatellite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GpsSatellite {
    // message fields
    // @@protoc_insertion_point(field:GpsSatellite.prn)
    pub prn: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GpsSatellite.snr_e3)
    pub snr_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GpsSatellite.used_in_fix)
    pub used_in_fix: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GpsSatellite.azimuth_e3)
    pub azimuth_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GpsSatellite.elevation_e3)
    pub elevation_e3: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GpsSatellite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GpsSatellite {
    fn default() -> &'a GpsSatellite {
        <GpsSatellite as ::protobuf::Message>::default_instance()
    }
}

impl GpsSatellite {
    pub fn new() -> GpsSatellite {
        ::std::default::Default::default()
    }

    // required int32 prn = 1;

    pub fn prn(&self) -> i32 {
        self.prn.unwrap_or(0)
    }

    pub fn clear_prn(&mut self) {
        self.prn = ::std::option::Option::None;
    }

    pub fn has_prn(&self) -> bool {
        self.prn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prn(&mut self, v: i32) {
        self.prn = ::std::option::Option::Some(v);
    }

    // required int32 snr_e3 = 2;

    pub fn snr_e3(&self) -> i32 {
        self.snr_e3.unwrap_or(0)
    }

    pub fn clear_snr_e3(&mut self) {
        self.snr_e3 = ::std::option::Option::None;
    }

    pub fn has_snr_e3(&self) -> bool {
        self.snr_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snr_e3(&mut self, v: i32) {
        self.snr_e3 = ::std::option::Option::Some(v);
    }

    // required bool used_in_fix = 3;

    pub fn used_in_fix(&self) -> bool {
        self.used_in_fix.unwrap_or(false)
    }

    pub fn clear_used_in_fix(&mut self) {
        self.used_in_fix = ::std::option::Option::None;
    }

    pub fn has_used_in_fix(&self) -> bool {
        self.used_in_fix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used_in_fix(&mut self, v: bool) {
        self.used_in_fix = ::std::option::Option::Some(v);
    }

    // optional int32 azimuth_e3 = 4;

    pub fn azimuth_e3(&self) -> i32 {
        self.azimuth_e3.unwrap_or(0)
    }

    pub fn clear_azimuth_e3(&mut self) {
        self.azimuth_e3 = ::std::option::Option::None;
    }

    pub fn has_azimuth_e3(&self) -> bool {
        self.azimuth_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azimuth_e3(&mut self, v: i32) {
        self.azimuth_e3 = ::std::option::Option::Some(v);
    }

    // optional int32 elevation_e3 = 5;

    pub fn elevation_e3(&self) -> i32 {
        self.elevation_e3.unwrap_or(0)
    }

    pub fn clear_elevation_e3(&mut self) {
        self.elevation_e3 = ::std::option::Option::None;
    }

    pub fn has_elevation_e3(&self) -> bool {
        self.elevation_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevation_e3(&mut self, v: i32) {
        self.elevation_e3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prn",
            |m: &GpsSatellite| { &m.prn },
            |m: &mut GpsSatellite| { &mut m.prn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snr_e3",
            |m: &GpsSatellite| { &m.snr_e3 },
            |m: &mut GpsSatellite| { &mut m.snr_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "used_in_fix",
            |m: &GpsSatellite| { &m.used_in_fix },
            |m: &mut GpsSatellite| { &mut m.used_in_fix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "azimuth_e3",
            |m: &GpsSatellite| { &m.azimuth_e3 },
            |m: &mut GpsSatellite| { &mut m.azimuth_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevation_e3",
            |m: &GpsSatellite| { &m.elevation_e3 },
            |m: &mut GpsSatellite| { &mut m.elevation_e3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GpsSatellite>(
            "GpsSatellite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GpsSatellite {
    const NAME: &'static str = "GpsSatellite";

    fn is_initialized(&self) -> bool {
        if self.prn.is_none() {
            return false;
        }
        if self.snr_e3.is_none() {
            return false;
        }
        if self.used_in_fix.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prn = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.snr_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.used_in_fix = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.azimuth_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.elevation_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prn {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.snr_e3 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.used_in_fix {
            my_size += 1 + 1;
        }
        if let Some(v) = self.azimuth_e3 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.elevation_e3 {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prn {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.snr_e3 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.used_in_fix {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.azimuth_e3 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.elevation_e3 {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GpsSatellite {
        GpsSatellite::new()
    }

    fn clear(&mut self) {
        self.prn = ::std::option::Option::None;
        self.snr_e3 = ::std::option::Option::None;
        self.used_in_fix = ::std::option::Option::None;
        self.azimuth_e3 = ::std::option::Option::None;
        self.elevation_e3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GpsSatellite {
        static instance: GpsSatellite = GpsSatellite {
            prn: ::std::option::Option::None,
            snr_e3: ::std::option::Option::None,
            used_in_fix: ::std::option::Option::None,
            azimuth_e3: ::std::option::Option::None,
            elevation_e3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GpsSatellite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GpsSatellite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GpsSatellite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GpsSatellite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GpsSatelliteData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GpsSatelliteData {
    // message fields
    // @@protoc_insertion_point(field:GpsSatelliteData.number_in_use)
    pub number_in_use: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GpsSatelliteData.number_in_view)
    pub number_in_view: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GpsSatelliteData.satellites)
    pub satellites: ::std::vec::Vec<GpsSatellite>,
    // special fields
    // @@protoc_insertion_point(special_field:GpsSatelliteData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GpsSatelliteData {
    fn default() -> &'a GpsSatelliteData {
        <GpsSatelliteData as ::protobuf::Message>::default_instance()
    }
}

impl GpsSatelliteData {
    pub fn new() -> GpsSatelliteData {
        ::std::default::Default::default()
    }

    // required int32 number_in_use = 1;

    pub fn number_in_use(&self) -> i32 {
        self.number_in_use.unwrap_or(0)
    }

    pub fn clear_number_in_use(&mut self) {
        self.number_in_use = ::std::option::Option::None;
    }

    pub fn has_number_in_use(&self) -> bool {
        self.number_in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_in_use(&mut self, v: i32) {
        self.number_in_use = ::std::option::Option::Some(v);
    }

    // optional int32 number_in_view = 2;

    pub fn number_in_view(&self) -> i32 {
        self.number_in_view.unwrap_or(0)
    }

    pub fn clear_number_in_view(&mut self) {
        self.number_in_view = ::std::option::Option::None;
    }

    pub fn has_number_in_view(&self) -> bool {
        self.number_in_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_in_view(&mut self, v: i32) {
        self.number_in_view = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_in_use",
            |m: &GpsSatelliteData| { &m.number_in_use },
            |m: &mut GpsSatelliteData| { &mut m.number_in_use },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_in_view",
            |m: &GpsSatelliteData| { &m.number_in_view },
            |m: &mut GpsSatelliteData| { &mut m.number_in_view },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "satellites",
            |m: &GpsSatelliteData| { &m.satellites },
            |m: &mut GpsSatelliteData| { &mut m.satellites },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GpsSatelliteData>(
            "GpsSatelliteData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GpsSatelliteData {
    const NAME: &'static str = "GpsSatelliteData";

    fn is_initialized(&self) -> bool {
        if self.number_in_use.is_none() {
            return false;
        }
        for v in &self.satellites {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.number_in_use = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.number_in_view = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.satellites.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.number_in_use {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.number_in_view {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.satellites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.number_in_use {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.number_in_view {
            os.write_int32(2, v)?;
        }
        for v in &self.satellites {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GpsSatelliteData {
        GpsSatelliteData::new()
    }

    fn clear(&mut self) {
        self.number_in_use = ::std::option::Option::None;
        self.number_in_view = ::std::option::Option::None;
        self.satellites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GpsSatelliteData {
        static instance: GpsSatelliteData = GpsSatelliteData {
            number_in_use: ::std::option::Option::None,
            number_in_view: ::std::option::Option::None,
            satellites: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GpsSatelliteData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GpsSatelliteData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GpsSatelliteData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GpsSatelliteData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TollCardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TollCardData {
    // message fields
    // @@protoc_insertion_point(field:TollCardData.is_card_present)
    pub is_card_present: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:TollCardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TollCardData {
    fn default() -> &'a TollCardData {
        <TollCardData as ::protobuf::Message>::default_instance()
    }
}

impl TollCardData {
    pub fn new() -> TollCardData {
        ::std::default::Default::default()
    }

    // required bool is_card_present = 1;

    pub fn is_card_present(&self) -> bool {
        self.is_card_present.unwrap_or(false)
    }

    pub fn clear_is_card_present(&mut self) {
        self.is_card_present = ::std::option::Option::None;
    }

    pub fn has_is_card_present(&self) -> bool {
        self.is_card_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_card_present(&mut self, v: bool) {
        self.is_card_present = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_card_present",
            |m: &TollCardData| { &m.is_card_present },
            |m: &mut TollCardData| { &mut m.is_card_present },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TollCardData>(
            "TollCardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TollCardData {
    const NAME: &'static str = "TollCardData";

    fn is_initialized(&self) -> bool {
        if self.is_card_present.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_card_present = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_card_present {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_card_present {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TollCardData {
        TollCardData::new()
    }

    fn clear(&mut self) {
        self.is_card_present = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TollCardData {
        static instance: TollCardData = TollCardData {
            is_card_present: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TollCardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TollCardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TollCardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TollCardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Setup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Setup {
    // message fields
    // @@protoc_insertion_point(field:Setup.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<MediaCodecType>>,
    // special fields
    // @@protoc_insertion_point(special_field:Setup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Setup {
    fn default() -> &'a Setup {
        <Setup as ::protobuf::Message>::default_instance()
    }
}

impl Setup {
    pub fn new() -> Setup {
        ::std::default::Default::default()
    }

    // required .MediaCodecType type = 1;

    pub fn type_(&self) -> MediaCodecType {
        match self.type_ {
            Some(e) => e.enum_value_or(MediaCodecType::MEDIA_CODEC_AUDIO_PCM),
            None => MediaCodecType::MEDIA_CODEC_AUDIO_PCM,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: MediaCodecType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Setup| { &m.type_ },
            |m: &mut Setup| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Setup>(
            "Setup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Setup {
    const NAME: &'static str = "Setup";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Setup {
        Setup::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Setup {
        static instance: Setup = Setup {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Setup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Setup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Setup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Setup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Start)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Start {
    // message fields
    // @@protoc_insertion_point(field:Start.session_id)
    pub session_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Start.configuration_index)
    pub configuration_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:Start.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Start {
    fn default() -> &'a Start {
        <Start as ::protobuf::Message>::default_instance()
    }
}

impl Start {
    pub fn new() -> Start {
        ::std::default::Default::default()
    }

    // required int32 session_id = 1;

    pub fn session_id(&self) -> i32 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: i32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // required uint32 configuration_index = 2;

    pub fn configuration_index(&self) -> u32 {
        self.configuration_index.unwrap_or(0)
    }

    pub fn clear_configuration_index(&mut self) {
        self.configuration_index = ::std::option::Option::None;
    }

    pub fn has_configuration_index(&self) -> bool {
        self.configuration_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration_index(&mut self, v: u32) {
        self.configuration_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &Start| { &m.session_id },
            |m: &mut Start| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configuration_index",
            |m: &Start| { &m.configuration_index },
            |m: &mut Start| { &mut m.configuration_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Start>(
            "Start",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Start {
    const NAME: &'static str = "Start";

    fn is_initialized(&self) -> bool {
        if self.session_id.is_none() {
            return false;
        }
        if self.configuration_index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.configuration_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.configuration_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.configuration_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Start {
        Start::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.configuration_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Start {
        static instance: Start = Start {
            session_id: ::std::option::Option::None,
            configuration_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Start {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Start").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Start {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Start {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Stop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Stop {
    // special fields
    // @@protoc_insertion_point(special_field:Stop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Stop {
    fn default() -> &'a Stop {
        <Stop as ::protobuf::Message>::default_instance()
    }
}

impl Stop {
    pub fn new() -> Stop {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stop>(
            "Stop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Stop {
    const NAME: &'static str = "Stop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Stop {
        Stop::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Stop {
        static instance: Stop = Stop {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Stop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Stop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Stop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Config)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Config {
    // message fields
    // @@protoc_insertion_point(field:Config.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<config::Status>>,
    // @@protoc_insertion_point(field:Config.max_unacked)
    pub max_unacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Config.configuration_indices)
    pub configuration_indices: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:Config.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // required .Config.Status status = 1;

    pub fn status(&self) -> config::Status {
        match self.status {
            Some(e) => e.enum_value_or(config::Status::STATUS_WAIT),
            None => config::Status::STATUS_WAIT,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: config::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 max_unacked = 2;

    pub fn max_unacked(&self) -> u32 {
        self.max_unacked.unwrap_or(0)
    }

    pub fn clear_max_unacked(&mut self) {
        self.max_unacked = ::std::option::Option::None;
    }

    pub fn has_max_unacked(&self) -> bool {
        self.max_unacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_unacked(&mut self, v: u32) {
        self.max_unacked = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &Config| { &m.status },
            |m: &mut Config| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_unacked",
            |m: &Config| { &m.max_unacked },
            |m: &mut Config| { &mut m.max_unacked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "configuration_indices",
            |m: &Config| { &m.configuration_indices },
            |m: &mut Config| { &mut m.configuration_indices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Config>(
            "Config",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Config {
    const NAME: &'static str = "Config";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.max_unacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.configuration_indices)?;
                },
                24 => {
                    self.configuration_indices.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.max_unacked {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.configuration_indices {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.max_unacked {
            os.write_uint32(2, v)?;
        }
        for v in &self.configuration_indices {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Config {
        Config::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.max_unacked = ::std::option::Option::None;
        self.configuration_indices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Config {
        static instance: Config = Config {
            status: ::std::option::Option::None,
            max_unacked: ::std::option::Option::None,
            configuration_indices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Config {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Config").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Config`
pub mod config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Config.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:Config.Status.STATUS_WAIT)
        STATUS_WAIT = 1,
        // @@protoc_insertion_point(enum_value:Config.Status.STATUS_READY)
        STATUS_READY = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                1 => ::std::option::Option::Some(Status::STATUS_WAIT),
                2 => ::std::option::Option::Some(Status::STATUS_READY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "STATUS_WAIT" => ::std::option::Option::Some(Status::STATUS_WAIT),
                "STATUS_READY" => ::std::option::Option::Some(Status::STATUS_READY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::STATUS_WAIT,
            Status::STATUS_READY,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Config.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Status::STATUS_WAIT => 0,
                Status::STATUS_READY => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::STATUS_WAIT
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("Config.Status")
        }
    }
}

// @@protoc_insertion_point(message:Ack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ack {
    // message fields
    // @@protoc_insertion_point(field:Ack.session_id)
    pub session_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Ack.ack)
    pub ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Ack.receive_timestamp_ns)
    pub receive_timestamp_ns: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:Ack.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ack {
    fn default() -> &'a Ack {
        <Ack as ::protobuf::Message>::default_instance()
    }
}

impl Ack {
    pub fn new() -> Ack {
        ::std::default::Default::default()
    }

    // required int32 session_id = 1;

    pub fn session_id(&self) -> i32 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: i32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ack = 2;

    pub fn ack(&self) -> u32 {
        self.ack.unwrap_or(0)
    }

    pub fn clear_ack(&mut self) {
        self.ack = ::std::option::Option::None;
    }

    pub fn has_ack(&self) -> bool {
        self.ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack(&mut self, v: u32) {
        self.ack = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &Ack| { &m.session_id },
            |m: &mut Ack| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack",
            |m: &Ack| { &m.ack },
            |m: &mut Ack| { &mut m.ack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "receive_timestamp_ns",
            |m: &Ack| { &m.receive_timestamp_ns },
            |m: &mut Ack| { &mut m.receive_timestamp_ns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ack>(
            "Ack",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ack {
    const NAME: &'static str = "Ack";

    fn is_initialized(&self) -> bool {
        if self.session_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.receive_timestamp_ns)?;
                },
                24 => {
                    self.receive_timestamp_ns.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ack {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.receive_timestamp_ns {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ack {
            os.write_uint32(2, v)?;
        }
        for v in &self.receive_timestamp_ns {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ack {
        Ack::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.ack = ::std::option::Option::None;
        self.receive_timestamp_ns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ack {
        static instance: Ack = Ack {
            session_id: ::std::option::Option::None,
            ack: ::std::option::Option::None,
            receive_timestamp_ns: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ack {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ack").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ack {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AudioUnderflowNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioUnderflowNotification {
    // message fields
    // @@protoc_insertion_point(field:AudioUnderflowNotification.session_id)
    pub session_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:AudioUnderflowNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioUnderflowNotification {
    fn default() -> &'a AudioUnderflowNotification {
        <AudioUnderflowNotification as ::protobuf::Message>::default_instance()
    }
}

impl AudioUnderflowNotification {
    pub fn new() -> AudioUnderflowNotification {
        ::std::default::Default::default()
    }

    // required int32 session_id = 1;

    pub fn session_id(&self) -> i32 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: i32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &AudioUnderflowNotification| { &m.session_id },
            |m: &mut AudioUnderflowNotification| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioUnderflowNotification>(
            "AudioUnderflowNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioUnderflowNotification {
    const NAME: &'static str = "AudioUnderflowNotification";

    fn is_initialized(&self) -> bool {
        if self.session_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioUnderflowNotification {
        AudioUnderflowNotification::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioUnderflowNotification {
        static instance: AudioUnderflowNotification = AudioUnderflowNotification {
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioUnderflowNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioUnderflowNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioUnderflowNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioUnderflowNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VideoFocusRequestNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoFocusRequestNotification {
    // message fields
    // @@protoc_insertion_point(field:VideoFocusRequestNotification.disp_channel_id)
    pub disp_channel_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VideoFocusRequestNotification.mode)
    pub mode: ::std::option::Option<::protobuf::EnumOrUnknown<VideoFocusMode>>,
    // @@protoc_insertion_point(field:VideoFocusRequestNotification.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<VideoFocusReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:VideoFocusRequestNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoFocusRequestNotification {
    fn default() -> &'a VideoFocusRequestNotification {
        <VideoFocusRequestNotification as ::protobuf::Message>::default_instance()
    }
}

impl VideoFocusRequestNotification {
    pub fn new() -> VideoFocusRequestNotification {
        ::std::default::Default::default()
    }

    // optional int32 disp_channel_id = 1;

    pub fn disp_channel_id(&self) -> i32 {
        self.disp_channel_id.unwrap_or(0)
    }

    pub fn clear_disp_channel_id(&mut self) {
        self.disp_channel_id = ::std::option::Option::None;
    }

    pub fn has_disp_channel_id(&self) -> bool {
        self.disp_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_channel_id(&mut self, v: i32) {
        self.disp_channel_id = ::std::option::Option::Some(v);
    }

    // optional .VideoFocusMode mode = 2;

    pub fn mode(&self) -> VideoFocusMode {
        match self.mode {
            Some(e) => e.enum_value_or(VideoFocusMode::VIDEO_FOCUS_PROJECTED),
            None => VideoFocusMode::VIDEO_FOCUS_PROJECTED,
        }
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: VideoFocusMode) {
        self.mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .VideoFocusReason reason = 3;

    pub fn reason(&self) -> VideoFocusReason {
        match self.reason {
            Some(e) => e.enum_value_or(VideoFocusReason::UNKNOWN),
            None => VideoFocusReason::UNKNOWN,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: VideoFocusReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disp_channel_id",
            |m: &VideoFocusRequestNotification| { &m.disp_channel_id },
            |m: &mut VideoFocusRequestNotification| { &mut m.disp_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &VideoFocusRequestNotification| { &m.mode },
            |m: &mut VideoFocusRequestNotification| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &VideoFocusRequestNotification| { &m.reason },
            |m: &mut VideoFocusRequestNotification| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFocusRequestNotification>(
            "VideoFocusRequestNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoFocusRequestNotification {
    const NAME: &'static str = "VideoFocusRequestNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.disp_channel_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.disp_channel_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.disp_channel_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reason {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoFocusRequestNotification {
        VideoFocusRequestNotification::new()
    }

    fn clear(&mut self) {
        self.disp_channel_id = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoFocusRequestNotification {
        static instance: VideoFocusRequestNotification = VideoFocusRequestNotification {
            disp_channel_id: ::std::option::Option::None,
            mode: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoFocusRequestNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoFocusRequestNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoFocusRequestNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFocusRequestNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VideoFocusNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoFocusNotification {
    // message fields
    // @@protoc_insertion_point(field:VideoFocusNotification.focus)
    pub focus: ::std::option::Option<::protobuf::EnumOrUnknown<VideoFocusMode>>,
    // @@protoc_insertion_point(field:VideoFocusNotification.unsolicited)
    pub unsolicited: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:VideoFocusNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoFocusNotification {
    fn default() -> &'a VideoFocusNotification {
        <VideoFocusNotification as ::protobuf::Message>::default_instance()
    }
}

impl VideoFocusNotification {
    pub fn new() -> VideoFocusNotification {
        ::std::default::Default::default()
    }

    // optional .VideoFocusMode focus = 1;

    pub fn focus(&self) -> VideoFocusMode {
        match self.focus {
            Some(e) => e.enum_value_or(VideoFocusMode::VIDEO_FOCUS_PROJECTED),
            None => VideoFocusMode::VIDEO_FOCUS_PROJECTED,
        }
    }

    pub fn clear_focus(&mut self) {
        self.focus = ::std::option::Option::None;
    }

    pub fn has_focus(&self) -> bool {
        self.focus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus(&mut self, v: VideoFocusMode) {
        self.focus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool unsolicited = 2;

    pub fn unsolicited(&self) -> bool {
        self.unsolicited.unwrap_or(false)
    }

    pub fn clear_unsolicited(&mut self) {
        self.unsolicited = ::std::option::Option::None;
    }

    pub fn has_unsolicited(&self) -> bool {
        self.unsolicited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsolicited(&mut self, v: bool) {
        self.unsolicited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "focus",
            |m: &VideoFocusNotification| { &m.focus },
            |m: &mut VideoFocusNotification| { &mut m.focus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsolicited",
            |m: &VideoFocusNotification| { &m.unsolicited },
            |m: &mut VideoFocusNotification| { &mut m.unsolicited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFocusNotification>(
            "VideoFocusNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoFocusNotification {
    const NAME: &'static str = "VideoFocusNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.focus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.unsolicited = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.focus {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.unsolicited {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.focus {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.unsolicited {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoFocusNotification {
        VideoFocusNotification::new()
    }

    fn clear(&mut self) {
        self.focus = ::std::option::Option::None;
        self.unsolicited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoFocusNotification {
        static instance: VideoFocusNotification = VideoFocusNotification {
            focus: ::std::option::Option::None,
            unsolicited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoFocusNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoFocusNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoFocusNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFocusNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpdateUiConfigRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateUiConfigRequest {
    // message fields
    // @@protoc_insertion_point(field:UpdateUiConfigRequest.ui_config)
    pub ui_config: ::protobuf::MessageField<UiConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:UpdateUiConfigRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUiConfigRequest {
    fn default() -> &'a UpdateUiConfigRequest {
        <UpdateUiConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUiConfigRequest {
    pub fn new() -> UpdateUiConfigRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UiConfig>(
            "ui_config",
            |m: &UpdateUiConfigRequest| { &m.ui_config },
            |m: &mut UpdateUiConfigRequest| { &mut m.ui_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUiConfigRequest>(
            "UpdateUiConfigRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUiConfigRequest {
    const NAME: &'static str = "UpdateUiConfigRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ui_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ui_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUiConfigRequest {
        UpdateUiConfigRequest::new()
    }

    fn clear(&mut self) {
        self.ui_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUiConfigRequest {
        static instance: UpdateUiConfigRequest = UpdateUiConfigRequest {
            ui_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUiConfigRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUiConfigRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUiConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUiConfigRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpdateUiConfigReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateUiConfigReply {
    // message fields
    // @@protoc_insertion_point(field:UpdateUiConfigReply.ui_config)
    pub ui_config: ::protobuf::MessageField<UiConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:UpdateUiConfigReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUiConfigReply {
    fn default() -> &'a UpdateUiConfigReply {
        <UpdateUiConfigReply as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUiConfigReply {
    pub fn new() -> UpdateUiConfigReply {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UiConfig>(
            "ui_config",
            |m: &UpdateUiConfigReply| { &m.ui_config },
            |m: &mut UpdateUiConfigReply| { &mut m.ui_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUiConfigReply>(
            "UpdateUiConfigReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUiConfigReply {
    const NAME: &'static str = "UpdateUiConfigReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ui_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ui_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUiConfigReply {
        UpdateUiConfigReply::new()
    }

    fn clear(&mut self) {
        self.ui_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUiConfigReply {
        static instance: UpdateUiConfigReply = UpdateUiConfigReply {
            ui_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUiConfigReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUiConfigReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUiConfigReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUiConfigReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AudioFocusRequestNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioFocusRequestNotification {
    // message fields
    // @@protoc_insertion_point(field:AudioFocusRequestNotification.request)
    pub request: ::std::option::Option<::protobuf::EnumOrUnknown<AudioFocusRequestType>>,
    // special fields
    // @@protoc_insertion_point(special_field:AudioFocusRequestNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFocusRequestNotification {
    fn default() -> &'a AudioFocusRequestNotification {
        <AudioFocusRequestNotification as ::protobuf::Message>::default_instance()
    }
}

impl AudioFocusRequestNotification {
    pub fn new() -> AudioFocusRequestNotification {
        ::std::default::Default::default()
    }

    // required .AudioFocusRequestType request = 1;

    pub fn request(&self) -> AudioFocusRequestType {
        match self.request {
            Some(e) => e.enum_value_or(AudioFocusRequestType::AUDIO_FOCUS_GAIN),
            None => AudioFocusRequestType::AUDIO_FOCUS_GAIN,
        }
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: AudioFocusRequestType) {
        self.request = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request",
            |m: &AudioFocusRequestNotification| { &m.request },
            |m: &mut AudioFocusRequestNotification| { &mut m.request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFocusRequestNotification>(
            "AudioFocusRequestNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFocusRequestNotification {
    const NAME: &'static str = "AudioFocusRequestNotification";

    fn is_initialized(&self) -> bool {
        if self.request.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFocusRequestNotification {
        AudioFocusRequestNotification::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFocusRequestNotification {
        static instance: AudioFocusRequestNotification = AudioFocusRequestNotification {
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFocusRequestNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFocusRequestNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFocusRequestNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFocusRequestNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AudioFocusNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioFocusNotification {
    // message fields
    // @@protoc_insertion_point(field:AudioFocusNotification.focus_state)
    pub focus_state: ::std::option::Option<::protobuf::EnumOrUnknown<AudioFocusStateType>>,
    // @@protoc_insertion_point(field:AudioFocusNotification.unsolicited)
    pub unsolicited: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:AudioFocusNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFocusNotification {
    fn default() -> &'a AudioFocusNotification {
        <AudioFocusNotification as ::protobuf::Message>::default_instance()
    }
}

impl AudioFocusNotification {
    pub fn new() -> AudioFocusNotification {
        ::std::default::Default::default()
    }

    // required .AudioFocusStateType focus_state = 1;

    pub fn focus_state(&self) -> AudioFocusStateType {
        match self.focus_state {
            Some(e) => e.enum_value_or(AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID),
            None => AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID,
        }
    }

    pub fn clear_focus_state(&mut self) {
        self.focus_state = ::std::option::Option::None;
    }

    pub fn has_focus_state(&self) -> bool {
        self.focus_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus_state(&mut self, v: AudioFocusStateType) {
        self.focus_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool unsolicited = 2;

    pub fn unsolicited(&self) -> bool {
        self.unsolicited.unwrap_or(false)
    }

    pub fn clear_unsolicited(&mut self) {
        self.unsolicited = ::std::option::Option::None;
    }

    pub fn has_unsolicited(&self) -> bool {
        self.unsolicited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsolicited(&mut self, v: bool) {
        self.unsolicited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "focus_state",
            |m: &AudioFocusNotification| { &m.focus_state },
            |m: &mut AudioFocusNotification| { &mut m.focus_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsolicited",
            |m: &AudioFocusNotification| { &m.unsolicited },
            |m: &mut AudioFocusNotification| { &mut m.unsolicited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFocusNotification>(
            "AudioFocusNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFocusNotification {
    const NAME: &'static str = "AudioFocusNotification";

    fn is_initialized(&self) -> bool {
        if self.focus_state.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.focus_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.unsolicited = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.focus_state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.unsolicited {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.focus_state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.unsolicited {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFocusNotification {
        AudioFocusNotification::new()
    }

    fn clear(&mut self) {
        self.focus_state = ::std::option::Option::None;
        self.unsolicited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFocusNotification {
        static instance: AudioFocusNotification = AudioFocusNotification {
            focus_state: ::std::option::Option::None,
            unsolicited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFocusNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFocusNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFocusNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFocusNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MicrophoneRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MicrophoneRequest {
    // message fields
    // @@protoc_insertion_point(field:MicrophoneRequest.open)
    pub open: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MicrophoneRequest.anc_enabled)
    pub anc_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MicrophoneRequest.ec_enabled)
    pub ec_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MicrophoneRequest.max_unacked)
    pub max_unacked: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:MicrophoneRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MicrophoneRequest {
    fn default() -> &'a MicrophoneRequest {
        <MicrophoneRequest as ::protobuf::Message>::default_instance()
    }
}

impl MicrophoneRequest {
    pub fn new() -> MicrophoneRequest {
        ::std::default::Default::default()
    }

    // required bool open = 1;

    pub fn open(&self) -> bool {
        self.open.unwrap_or(false)
    }

    pub fn clear_open(&mut self) {
        self.open = ::std::option::Option::None;
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: bool) {
        self.open = ::std::option::Option::Some(v);
    }

    // optional bool anc_enabled = 2;

    pub fn anc_enabled(&self) -> bool {
        self.anc_enabled.unwrap_or(false)
    }

    pub fn clear_anc_enabled(&mut self) {
        self.anc_enabled = ::std::option::Option::None;
    }

    pub fn has_anc_enabled(&self) -> bool {
        self.anc_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anc_enabled(&mut self, v: bool) {
        self.anc_enabled = ::std::option::Option::Some(v);
    }

    // optional bool ec_enabled = 3;

    pub fn ec_enabled(&self) -> bool {
        self.ec_enabled.unwrap_or(false)
    }

    pub fn clear_ec_enabled(&mut self) {
        self.ec_enabled = ::std::option::Option::None;
    }

    pub fn has_ec_enabled(&self) -> bool {
        self.ec_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ec_enabled(&mut self, v: bool) {
        self.ec_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 max_unacked = 4;

    pub fn max_unacked(&self) -> i32 {
        self.max_unacked.unwrap_or(0)
    }

    pub fn clear_max_unacked(&mut self) {
        self.max_unacked = ::std::option::Option::None;
    }

    pub fn has_max_unacked(&self) -> bool {
        self.max_unacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_unacked(&mut self, v: i32) {
        self.max_unacked = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "open",
            |m: &MicrophoneRequest| { &m.open },
            |m: &mut MicrophoneRequest| { &mut m.open },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "anc_enabled",
            |m: &MicrophoneRequest| { &m.anc_enabled },
            |m: &mut MicrophoneRequest| { &mut m.anc_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ec_enabled",
            |m: &MicrophoneRequest| { &m.ec_enabled },
            |m: &mut MicrophoneRequest| { &mut m.ec_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_unacked",
            |m: &MicrophoneRequest| { &m.max_unacked },
            |m: &mut MicrophoneRequest| { &mut m.max_unacked },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MicrophoneRequest>(
            "MicrophoneRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MicrophoneRequest {
    const NAME: &'static str = "MicrophoneRequest";

    fn is_initialized(&self) -> bool {
        if self.open.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.open = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.anc_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.ec_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.max_unacked = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.open {
            my_size += 1 + 1;
        }
        if let Some(v) = self.anc_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ec_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.max_unacked {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.open {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.anc_enabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.ec_enabled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.max_unacked {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MicrophoneRequest {
        MicrophoneRequest::new()
    }

    fn clear(&mut self) {
        self.open = ::std::option::Option::None;
        self.anc_enabled = ::std::option::Option::None;
        self.ec_enabled = ::std::option::Option::None;
        self.max_unacked = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MicrophoneRequest {
        static instance: MicrophoneRequest = MicrophoneRequest {
            open: ::std::option::Option::None,
            anc_enabled: ::std::option::Option::None,
            ec_enabled: ::std::option::Option::None,
            max_unacked: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MicrophoneRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MicrophoneRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MicrophoneRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MicrophoneRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MicrophoneResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MicrophoneResponse {
    // message fields
    // @@protoc_insertion_point(field:MicrophoneResponse.status)
    pub status: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MicrophoneResponse.session_id)
    pub session_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:MicrophoneResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MicrophoneResponse {
    fn default() -> &'a MicrophoneResponse {
        <MicrophoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl MicrophoneResponse {
    pub fn new() -> MicrophoneResponse {
        ::std::default::Default::default()
    }

    // required int32 status = 1;

    pub fn status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional int32 session_id = 2;

    pub fn session_id(&self) -> i32 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: i32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &MicrophoneResponse| { &m.status },
            |m: &mut MicrophoneResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &MicrophoneResponse| { &m.session_id },
            |m: &mut MicrophoneResponse| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MicrophoneResponse>(
            "MicrophoneResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MicrophoneResponse {
    const NAME: &'static str = "MicrophoneResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.session_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MicrophoneResponse {
        MicrophoneResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MicrophoneResponse {
        static instance: MicrophoneResponse = MicrophoneResponse {
            status: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MicrophoneResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MicrophoneResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MicrophoneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MicrophoneResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KeyBindingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyBindingRequest {
    // message fields
    // @@protoc_insertion_point(field:KeyBindingRequest.keycodes)
    pub keycodes: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:KeyBindingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyBindingRequest {
    fn default() -> &'a KeyBindingRequest {
        <KeyBindingRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyBindingRequest {
    pub fn new() -> KeyBindingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keycodes",
            |m: &KeyBindingRequest| { &m.keycodes },
            |m: &mut KeyBindingRequest| { &mut m.keycodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyBindingRequest>(
            "KeyBindingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyBindingRequest {
    const NAME: &'static str = "KeyBindingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.keycodes)?;
                },
                8 => {
                    self.keycodes.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.keycodes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_int32(1, &self.keycodes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyBindingRequest {
        KeyBindingRequest::new()
    }

    fn clear(&mut self) {
        self.keycodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyBindingRequest {
        static instance: KeyBindingRequest = KeyBindingRequest {
            keycodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyBindingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyBindingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyBindingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyBindingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KeyBindingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyBindingResponse {
    // message fields
    // @@protoc_insertion_point(field:KeyBindingResponse.status)
    pub status: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:KeyBindingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyBindingResponse {
    fn default() -> &'a KeyBindingResponse {
        <KeyBindingResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyBindingResponse {
    pub fn new() -> KeyBindingResponse {
        ::std::default::Default::default()
    }

    // required int32 status = 1;

    pub fn status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &KeyBindingResponse| { &m.status },
            |m: &mut KeyBindingResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyBindingResponse>(
            "KeyBindingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyBindingResponse {
    const NAME: &'static str = "KeyBindingResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyBindingResponse {
        KeyBindingResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyBindingResponse {
        static instance: KeyBindingResponse = KeyBindingResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyBindingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyBindingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyBindingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyBindingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:InputReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputReport {
    // message fields
    // @@protoc_insertion_point(field:InputReport.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:InputReport.disp_channel_id)
    pub disp_channel_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:InputReport.touch_event)
    pub touch_event: ::protobuf::MessageField<TouchEvent>,
    // @@protoc_insertion_point(field:InputReport.key_event)
    pub key_event: ::protobuf::MessageField<KeyEvent>,
    // @@protoc_insertion_point(field:InputReport.absolute_event)
    pub absolute_event: ::protobuf::MessageField<AbsoluteEvent>,
    // @@protoc_insertion_point(field:InputReport.relative_event)
    pub relative_event: ::protobuf::MessageField<RelativeEvent>,
    // @@protoc_insertion_point(field:InputReport.touchpad_event)
    pub touchpad_event: ::protobuf::MessageField<TouchEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:InputReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputReport {
    fn default() -> &'a InputReport {
        <InputReport as ::protobuf::Message>::default_instance()
    }
}

impl InputReport {
    pub fn new() -> InputReport {
        ::std::default::Default::default()
    }

    // required uint64 timestamp = 1;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 disp_channel_id = 2;

    pub fn disp_channel_id(&self) -> i32 {
        self.disp_channel_id.unwrap_or(0)
    }

    pub fn clear_disp_channel_id(&mut self) {
        self.disp_channel_id = ::std::option::Option::None;
    }

    pub fn has_disp_channel_id(&self) -> bool {
        self.disp_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_channel_id(&mut self, v: i32) {
        self.disp_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &InputReport| { &m.timestamp },
            |m: &mut InputReport| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disp_channel_id",
            |m: &InputReport| { &m.disp_channel_id },
            |m: &mut InputReport| { &mut m.disp_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TouchEvent>(
            "touch_event",
            |m: &InputReport| { &m.touch_event },
            |m: &mut InputReport| { &mut m.touch_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyEvent>(
            "key_event",
            |m: &InputReport| { &m.key_event },
            |m: &mut InputReport| { &mut m.key_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AbsoluteEvent>(
            "absolute_event",
            |m: &InputReport| { &m.absolute_event },
            |m: &mut InputReport| { &mut m.absolute_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RelativeEvent>(
            "relative_event",
            |m: &InputReport| { &m.relative_event },
            |m: &mut InputReport| { &mut m.relative_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TouchEvent>(
            "touchpad_event",
            |m: &InputReport| { &m.touchpad_event },
            |m: &mut InputReport| { &mut m.touchpad_event },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputReport>(
            "InputReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputReport {
    const NAME: &'static str = "InputReport";

    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        }
        for v in &self.touch_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.absolute_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relative_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.touchpad_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.disp_channel_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.touch_event)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key_event)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.absolute_event)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.relative_event)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.touchpad_event)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.disp_channel_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.touch_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.key_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.absolute_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.relative_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.touchpad_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.disp_channel_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.touch_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.key_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.absolute_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.relative_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.touchpad_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputReport {
        InputReport::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.disp_channel_id = ::std::option::Option::None;
        self.touch_event.clear();
        self.key_event.clear();
        self.absolute_event.clear();
        self.relative_event.clear();
        self.touchpad_event.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputReport {
        static instance: InputReport = InputReport {
            timestamp: ::std::option::Option::None,
            disp_channel_id: ::std::option::Option::None,
            touch_event: ::protobuf::MessageField::none(),
            key_event: ::protobuf::MessageField::none(),
            absolute_event: ::protobuf::MessageField::none(),
            relative_event: ::protobuf::MessageField::none(),
            touchpad_event: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KeyEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyEvent {
    // message fields
    // @@protoc_insertion_point(field:KeyEvent.keys)
    pub keys: ::std::vec::Vec<key_event::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:KeyEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyEvent {
    fn default() -> &'a KeyEvent {
        <KeyEvent as ::protobuf::Message>::default_instance()
    }
}

impl KeyEvent {
    pub fn new() -> KeyEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &KeyEvent| { &m.keys },
            |m: &mut KeyEvent| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyEvent>(
            "KeyEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyEvent {
    const NAME: &'static str = "KeyEvent";

    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyEvent {
        KeyEvent::new()
    }

    fn clear(&mut self) {
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyEvent {
        static instance: KeyEvent = KeyEvent {
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KeyEvent`
pub mod key_event {
    // @@protoc_insertion_point(message:KeyEvent.Key)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key {
        // message fields
        // @@protoc_insertion_point(field:KeyEvent.Key.keycode)
        pub keycode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:KeyEvent.Key.down)
        pub down: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:KeyEvent.Key.metastate)
        pub metastate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:KeyEvent.Key.longpress)
        pub longpress: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:KeyEvent.Key.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key {
        fn default() -> &'a Key {
            <Key as ::protobuf::Message>::default_instance()
        }
    }

    impl Key {
        pub fn new() -> Key {
            ::std::default::Default::default()
        }

        // required uint32 keycode = 1;

        pub fn keycode(&self) -> u32 {
            self.keycode.unwrap_or(0)
        }

        pub fn clear_keycode(&mut self) {
            self.keycode = ::std::option::Option::None;
        }

        pub fn has_keycode(&self) -> bool {
            self.keycode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_keycode(&mut self, v: u32) {
            self.keycode = ::std::option::Option::Some(v);
        }

        // required bool down = 2;

        pub fn down(&self) -> bool {
            self.down.unwrap_or(false)
        }

        pub fn clear_down(&mut self) {
            self.down = ::std::option::Option::None;
        }

        pub fn has_down(&self) -> bool {
            self.down.is_some()
        }

        // Param is passed by value, moved
        pub fn set_down(&mut self, v: bool) {
            self.down = ::std::option::Option::Some(v);
        }

        // required uint32 metastate = 3;

        pub fn metastate(&self) -> u32 {
            self.metastate.unwrap_or(0)
        }

        pub fn clear_metastate(&mut self) {
            self.metastate = ::std::option::Option::None;
        }

        pub fn has_metastate(&self) -> bool {
            self.metastate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metastate(&mut self, v: u32) {
            self.metastate = ::std::option::Option::Some(v);
        }

        // optional bool longpress = 4;

        pub fn longpress(&self) -> bool {
            self.longpress.unwrap_or(false)
        }

        pub fn clear_longpress(&mut self) {
            self.longpress = ::std::option::Option::None;
        }

        pub fn has_longpress(&self) -> bool {
            self.longpress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longpress(&mut self, v: bool) {
            self.longpress = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "keycode",
                |m: &Key| { &m.keycode },
                |m: &mut Key| { &mut m.keycode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "down",
                |m: &Key| { &m.down },
                |m: &mut Key| { &mut m.down },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "metastate",
                |m: &Key| { &m.metastate },
                |m: &mut Key| { &mut m.metastate },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "longpress",
                |m: &Key| { &m.longpress },
                |m: &mut Key| { &mut m.longpress },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key>(
                "KeyEvent.Key",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key {
        const NAME: &'static str = "Key";

        fn is_initialized(&self) -> bool {
            if self.keycode.is_none() {
                return false;
            }
            if self.down.is_none() {
                return false;
            }
            if self.metastate.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.keycode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.down = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.metastate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.longpress = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.keycode {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.down {
                my_size += 1 + 1;
            }
            if let Some(v) = self.metastate {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.longpress {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.keycode {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.down {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.metastate {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.longpress {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key {
            Key::new()
        }

        fn clear(&mut self) {
            self.keycode = ::std::option::Option::None;
            self.down = ::std::option::Option::None;
            self.metastate = ::std::option::Option::None;
            self.longpress = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key {
            static instance: Key = Key {
                keycode: ::std::option::Option::None,
                down: ::std::option::Option::None,
                metastate: ::std::option::Option::None,
                longpress: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("KeyEvent.Key").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TouchEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TouchEvent {
    // message fields
    // @@protoc_insertion_point(field:TouchEvent.pointer_data)
    pub pointer_data: ::std::vec::Vec<touch_event::Pointer>,
    // @@protoc_insertion_point(field:TouchEvent.action_index)
    pub action_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TouchEvent.action)
    pub action: ::std::option::Option<::protobuf::EnumOrUnknown<PointerAction>>,
    // special fields
    // @@protoc_insertion_point(special_field:TouchEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TouchEvent {
    fn default() -> &'a TouchEvent {
        <TouchEvent as ::protobuf::Message>::default_instance()
    }
}

impl TouchEvent {
    pub fn new() -> TouchEvent {
        ::std::default::Default::default()
    }

    // optional uint32 action_index = 2;

    pub fn action_index(&self) -> u32 {
        self.action_index.unwrap_or(0)
    }

    pub fn clear_action_index(&mut self) {
        self.action_index = ::std::option::Option::None;
    }

    pub fn has_action_index(&self) -> bool {
        self.action_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_index(&mut self, v: u32) {
        self.action_index = ::std::option::Option::Some(v);
    }

    // optional .PointerAction action = 3;

    pub fn action(&self) -> PointerAction {
        match self.action {
            Some(e) => e.enum_value_or(PointerAction::ACTION_DOWN),
            None => PointerAction::ACTION_DOWN,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: PointerAction) {
        self.action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pointer_data",
            |m: &TouchEvent| { &m.pointer_data },
            |m: &mut TouchEvent| { &mut m.pointer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action_index",
            |m: &TouchEvent| { &m.action_index },
            |m: &mut TouchEvent| { &mut m.action_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &TouchEvent| { &m.action },
            |m: &mut TouchEvent| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TouchEvent>(
            "TouchEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TouchEvent {
    const NAME: &'static str = "TouchEvent";

    fn is_initialized(&self) -> bool {
        for v in &self.pointer_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pointer_data.push(is.read_message()?);
                },
                16 => {
                    self.action_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pointer_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.action_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pointer_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.action_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TouchEvent {
        TouchEvent::new()
    }

    fn clear(&mut self) {
        self.pointer_data.clear();
        self.action_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TouchEvent {
        static instance: TouchEvent = TouchEvent {
            pointer_data: ::std::vec::Vec::new(),
            action_index: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TouchEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TouchEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TouchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TouchEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TouchEvent`
pub mod touch_event {
    // @@protoc_insertion_point(message:TouchEvent.Pointer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pointer {
        // message fields
        // @@protoc_insertion_point(field:TouchEvent.Pointer.x)
        pub x: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:TouchEvent.Pointer.y)
        pub y: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:TouchEvent.Pointer.pointer_id)
        pub pointer_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:TouchEvent.Pointer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pointer {
        fn default() -> &'a Pointer {
            <Pointer as ::protobuf::Message>::default_instance()
        }
    }

    impl Pointer {
        pub fn new() -> Pointer {
            ::std::default::Default::default()
        }

        // required uint32 x = 1;

        pub fn x(&self) -> u32 {
            self.x.unwrap_or(0)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: u32) {
            self.x = ::std::option::Option::Some(v);
        }

        // required uint32 y = 2;

        pub fn y(&self) -> u32 {
            self.y.unwrap_or(0)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: u32) {
            self.y = ::std::option::Option::Some(v);
        }

        // required uint32 pointer_id = 3;

        pub fn pointer_id(&self) -> u32 {
            self.pointer_id.unwrap_or(0)
        }

        pub fn clear_pointer_id(&mut self) {
            self.pointer_id = ::std::option::Option::None;
        }

        pub fn has_pointer_id(&self) -> bool {
            self.pointer_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pointer_id(&mut self, v: u32) {
            self.pointer_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &Pointer| { &m.x },
                |m: &mut Pointer| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &Pointer| { &m.y },
                |m: &mut Pointer| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pointer_id",
                |m: &Pointer| { &m.pointer_id },
                |m: &mut Pointer| { &mut m.pointer_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pointer>(
                "TouchEvent.Pointer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pointer {
        const NAME: &'static str = "Pointer";

        fn is_initialized(&self) -> bool {
            if self.x.is_none() {
                return false;
            }
            if self.y.is_none() {
                return false;
            }
            if self.pointer_id.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.x = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.y = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.pointer_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.y {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.pointer_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.pointer_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pointer {
            Pointer::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.pointer_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pointer {
            static instance: Pointer = Pointer {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                pointer_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pointer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TouchEvent.Pointer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pointer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pointer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:AbsoluteEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AbsoluteEvent {
    // message fields
    // @@protoc_insertion_point(field:AbsoluteEvent.data)
    pub data: ::std::vec::Vec<absolute_event::Abs>,
    // special fields
    // @@protoc_insertion_point(special_field:AbsoluteEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AbsoluteEvent {
    fn default() -> &'a AbsoluteEvent {
        <AbsoluteEvent as ::protobuf::Message>::default_instance()
    }
}

impl AbsoluteEvent {
    pub fn new() -> AbsoluteEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &AbsoluteEvent| { &m.data },
            |m: &mut AbsoluteEvent| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AbsoluteEvent>(
            "AbsoluteEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AbsoluteEvent {
    const NAME: &'static str = "AbsoluteEvent";

    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AbsoluteEvent {
        AbsoluteEvent::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AbsoluteEvent {
        static instance: AbsoluteEvent = AbsoluteEvent {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AbsoluteEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AbsoluteEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AbsoluteEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbsoluteEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AbsoluteEvent`
pub mod absolute_event {
    // @@protoc_insertion_point(message:AbsoluteEvent.Abs)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Abs {
        // message fields
        // @@protoc_insertion_point(field:AbsoluteEvent.Abs.keycode)
        pub keycode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:AbsoluteEvent.Abs.value)
        pub value: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:AbsoluteEvent.Abs.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Abs {
        fn default() -> &'a Abs {
            <Abs as ::protobuf::Message>::default_instance()
        }
    }

    impl Abs {
        pub fn new() -> Abs {
            ::std::default::Default::default()
        }

        // required uint32 keycode = 1;

        pub fn keycode(&self) -> u32 {
            self.keycode.unwrap_or(0)
        }

        pub fn clear_keycode(&mut self) {
            self.keycode = ::std::option::Option::None;
        }

        pub fn has_keycode(&self) -> bool {
            self.keycode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_keycode(&mut self, v: u32) {
            self.keycode = ::std::option::Option::Some(v);
        }

        // required int32 value = 2;

        pub fn value(&self) -> i32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: i32) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "keycode",
                |m: &Abs| { &m.keycode },
                |m: &mut Abs| { &mut m.keycode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Abs| { &m.value },
                |m: &mut Abs| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Abs>(
                "AbsoluteEvent.Abs",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Abs {
        const NAME: &'static str = "Abs";

        fn is_initialized(&self) -> bool {
            if self.keycode.is_none() {
                return false;
            }
            if self.value.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.keycode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.keycode {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.keycode {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Abs {
            Abs::new()
        }

        fn clear(&mut self) {
            self.keycode = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Abs {
            static instance: Abs = Abs {
                keycode: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Abs {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AbsoluteEvent.Abs").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Abs {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Abs {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:RelativeEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelativeEvent {
    // message fields
    // @@protoc_insertion_point(field:RelativeEvent.data)
    pub data: ::std::vec::Vec<relative_event::Rel>,
    // special fields
    // @@protoc_insertion_point(special_field:RelativeEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelativeEvent {
    fn default() -> &'a RelativeEvent {
        <RelativeEvent as ::protobuf::Message>::default_instance()
    }
}

impl RelativeEvent {
    pub fn new() -> RelativeEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &RelativeEvent| { &m.data },
            |m: &mut RelativeEvent| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelativeEvent>(
            "RelativeEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelativeEvent {
    const NAME: &'static str = "RelativeEvent";

    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelativeEvent {
        RelativeEvent::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelativeEvent {
        static instance: RelativeEvent = RelativeEvent {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelativeEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelativeEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelativeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelativeEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RelativeEvent`
pub mod relative_event {
    // @@protoc_insertion_point(message:RelativeEvent.Rel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Rel {
        // message fields
        // @@protoc_insertion_point(field:RelativeEvent.Rel.keycode)
        pub keycode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:RelativeEvent.Rel.delta)
        pub delta: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:RelativeEvent.Rel.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Rel {
        fn default() -> &'a Rel {
            <Rel as ::protobuf::Message>::default_instance()
        }
    }

    impl Rel {
        pub fn new() -> Rel {
            ::std::default::Default::default()
        }

        // required uint32 keycode = 1;

        pub fn keycode(&self) -> u32 {
            self.keycode.unwrap_or(0)
        }

        pub fn clear_keycode(&mut self) {
            self.keycode = ::std::option::Option::None;
        }

        pub fn has_keycode(&self) -> bool {
            self.keycode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_keycode(&mut self, v: u32) {
            self.keycode = ::std::option::Option::Some(v);
        }

        // required int32 delta = 2;

        pub fn delta(&self) -> i32 {
            self.delta.unwrap_or(0)
        }

        pub fn clear_delta(&mut self) {
            self.delta = ::std::option::Option::None;
        }

        pub fn has_delta(&self) -> bool {
            self.delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delta(&mut self, v: i32) {
            self.delta = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "keycode",
                |m: &Rel| { &m.keycode },
                |m: &mut Rel| { &mut m.keycode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delta",
                |m: &Rel| { &m.delta },
                |m: &mut Rel| { &mut m.delta },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rel>(
                "RelativeEvent.Rel",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Rel {
        const NAME: &'static str = "Rel";

        fn is_initialized(&self) -> bool {
            if self.keycode.is_none() {
                return false;
            }
            if self.delta.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.keycode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.delta = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.keycode {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.delta {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.keycode {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.delta {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Rel {
            Rel::new()
        }

        fn clear(&mut self) {
            self.keycode = ::std::option::Option::None;
            self.delta = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Rel {
            static instance: Rel = Rel {
                keycode: ::std::option::Option::None,
                delta: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Rel {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RelativeEvent.Rel").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Rel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Rel {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:InputFeedback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputFeedback {
    // message fields
    // @@protoc_insertion_point(field:InputFeedback.event)
    pub event: ::std::option::Option<::protobuf::EnumOrUnknown<FeedbackEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:InputFeedback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputFeedback {
    fn default() -> &'a InputFeedback {
        <InputFeedback as ::protobuf::Message>::default_instance()
    }
}

impl InputFeedback {
    pub fn new() -> InputFeedback {
        ::std::default::Default::default()
    }

    // optional .FeedbackEvent event = 1;

    pub fn event(&self) -> FeedbackEvent {
        match self.event {
            Some(e) => e.enum_value_or(FeedbackEvent::FEEDBACK_SELECT),
            None => FeedbackEvent::FEEDBACK_SELECT,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: FeedbackEvent) {
        self.event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event",
            |m: &InputFeedback| { &m.event },
            |m: &mut InputFeedback| { &mut m.event },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputFeedback>(
            "InputFeedback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputFeedback {
    const NAME: &'static str = "InputFeedback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputFeedback {
        InputFeedback::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputFeedback {
        static instance: InputFeedback = InputFeedback {
            event: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputFeedback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputFeedback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputFeedback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputFeedback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothPairingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothPairingRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothPairingRequest.phone_address)
    pub phone_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:BluetoothPairingRequest.pairing_method)
    pub pairing_method: ::std::option::Option<::protobuf::EnumOrUnknown<BluetoothPairingMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothPairingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothPairingRequest {
    fn default() -> &'a BluetoothPairingRequest {
        <BluetoothPairingRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothPairingRequest {
    pub fn new() -> BluetoothPairingRequest {
        ::std::default::Default::default()
    }

    // required string phone_address = 1;

    pub fn phone_address(&self) -> &str {
        match self.phone_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phone_address(&mut self) {
        self.phone_address = ::std::option::Option::None;
    }

    pub fn has_phone_address(&self) -> bool {
        self.phone_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_address(&mut self, v: ::std::string::String) {
        self.phone_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phone_address(&mut self) -> &mut ::std::string::String {
        if self.phone_address.is_none() {
            self.phone_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phone_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_phone_address(&mut self) -> ::std::string::String {
        self.phone_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .BluetoothPairingMethod pairing_method = 2;

    pub fn pairing_method(&self) -> BluetoothPairingMethod {
        match self.pairing_method {
            Some(e) => e.enum_value_or(BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE),
            None => BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE,
        }
    }

    pub fn clear_pairing_method(&mut self) {
        self.pairing_method = ::std::option::Option::None;
    }

    pub fn has_pairing_method(&self) -> bool {
        self.pairing_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pairing_method(&mut self, v: BluetoothPairingMethod) {
        self.pairing_method = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone_address",
            |m: &BluetoothPairingRequest| { &m.phone_address },
            |m: &mut BluetoothPairingRequest| { &mut m.phone_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pairing_method",
            |m: &BluetoothPairingRequest| { &m.pairing_method },
            |m: &mut BluetoothPairingRequest| { &mut m.pairing_method },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothPairingRequest>(
            "BluetoothPairingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothPairingRequest {
    const NAME: &'static str = "BluetoothPairingRequest";

    fn is_initialized(&self) -> bool {
        if self.phone_address.is_none() {
            return false;
        }
        if self.pairing_method.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phone_address = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.pairing_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phone_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pairing_method {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phone_address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pairing_method {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothPairingRequest {
        BluetoothPairingRequest::new()
    }

    fn clear(&mut self) {
        self.phone_address = ::std::option::Option::None;
        self.pairing_method = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothPairingRequest {
        static instance: BluetoothPairingRequest = BluetoothPairingRequest {
            phone_address: ::std::option::Option::None,
            pairing_method: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothPairingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothPairingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothPairingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothPairingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothPairingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothPairingResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothPairingResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:BluetoothPairingResponse.already_paired)
    pub already_paired: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothPairingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothPairingResponse {
    fn default() -> &'a BluetoothPairingResponse {
        <BluetoothPairingResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothPairingResponse {
    pub fn new() -> BluetoothPairingResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required bool already_paired = 2;

    pub fn already_paired(&self) -> bool {
        self.already_paired.unwrap_or(false)
    }

    pub fn clear_already_paired(&mut self) {
        self.already_paired = ::std::option::Option::None;
    }

    pub fn has_already_paired(&self) -> bool {
        self.already_paired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_already_paired(&mut self, v: bool) {
        self.already_paired = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &BluetoothPairingResponse| { &m.status },
            |m: &mut BluetoothPairingResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "already_paired",
            |m: &BluetoothPairingResponse| { &m.already_paired },
            |m: &mut BluetoothPairingResponse| { &mut m.already_paired },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothPairingResponse>(
            "BluetoothPairingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothPairingResponse {
    const NAME: &'static str = "BluetoothPairingResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.already_paired.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.already_paired = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.already_paired {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.already_paired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothPairingResponse {
        BluetoothPairingResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.already_paired = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothPairingResponse {
        static instance: BluetoothPairingResponse = BluetoothPairingResponse {
            status: ::std::option::Option::None,
            already_paired: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothPairingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothPairingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothPairingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothPairingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothAuthenticationData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothAuthenticationData {
    // message fields
    // @@protoc_insertion_point(field:BluetoothAuthenticationData.auth_data)
    pub auth_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:BluetoothAuthenticationData.pairing_method)
    pub pairing_method: ::std::option::Option<::protobuf::EnumOrUnknown<BluetoothPairingMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothAuthenticationData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothAuthenticationData {
    fn default() -> &'a BluetoothAuthenticationData {
        <BluetoothAuthenticationData as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothAuthenticationData {
    pub fn new() -> BluetoothAuthenticationData {
        ::std::default::Default::default()
    }

    // required string auth_data = 1;

    pub fn auth_data(&self) -> &str {
        match self.auth_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_auth_data(&mut self) {
        self.auth_data = ::std::option::Option::None;
    }

    pub fn has_auth_data(&self) -> bool {
        self.auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_data(&mut self, v: ::std::string::String) {
        self.auth_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_data(&mut self) -> &mut ::std::string::String {
        if self.auth_data.is_none() {
            self.auth_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_data(&mut self) -> ::std::string::String {
        self.auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .BluetoothPairingMethod pairing_method = 2;

    pub fn pairing_method(&self) -> BluetoothPairingMethod {
        match self.pairing_method {
            Some(e) => e.enum_value_or(BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE),
            None => BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE,
        }
    }

    pub fn clear_pairing_method(&mut self) {
        self.pairing_method = ::std::option::Option::None;
    }

    pub fn has_pairing_method(&self) -> bool {
        self.pairing_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pairing_method(&mut self, v: BluetoothPairingMethod) {
        self.pairing_method = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_data",
            |m: &BluetoothAuthenticationData| { &m.auth_data },
            |m: &mut BluetoothAuthenticationData| { &mut m.auth_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pairing_method",
            |m: &BluetoothAuthenticationData| { &m.pairing_method },
            |m: &mut BluetoothAuthenticationData| { &mut m.pairing_method },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothAuthenticationData>(
            "BluetoothAuthenticationData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothAuthenticationData {
    const NAME: &'static str = "BluetoothAuthenticationData";

    fn is_initialized(&self) -> bool {
        if self.auth_data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_data = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.pairing_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pairing_method {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.auth_data.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pairing_method {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothAuthenticationData {
        BluetoothAuthenticationData::new()
    }

    fn clear(&mut self) {
        self.auth_data = ::std::option::Option::None;
        self.pairing_method = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothAuthenticationData {
        static instance: BluetoothAuthenticationData = BluetoothAuthenticationData {
            auth_data: ::std::option::Option::None,
            pairing_method: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothAuthenticationData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothAuthenticationData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothAuthenticationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothAuthenticationData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothAuthenticationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothAuthenticationResult {
    // message fields
    // @@protoc_insertion_point(field:BluetoothAuthenticationResult.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothAuthenticationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothAuthenticationResult {
    fn default() -> &'a BluetoothAuthenticationResult {
        <BluetoothAuthenticationResult as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothAuthenticationResult {
    pub fn new() -> BluetoothAuthenticationResult {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &BluetoothAuthenticationResult| { &m.status },
            |m: &mut BluetoothAuthenticationResult| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothAuthenticationResult>(
            "BluetoothAuthenticationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothAuthenticationResult {
    const NAME: &'static str = "BluetoothAuthenticationResult";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothAuthenticationResult {
        BluetoothAuthenticationResult::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothAuthenticationResult {
        static instance: BluetoothAuthenticationResult = BluetoothAuthenticationResult {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothAuthenticationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothAuthenticationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothAuthenticationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothAuthenticationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:WifiProjectionService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WifiProjectionService {
    // message fields
    // @@protoc_insertion_point(field:WifiProjectionService.car_wifi_bssid)
    pub car_wifi_bssid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:WifiProjectionService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WifiProjectionService {
    fn default() -> &'a WifiProjectionService {
        <WifiProjectionService as ::protobuf::Message>::default_instance()
    }
}

impl WifiProjectionService {
    pub fn new() -> WifiProjectionService {
        ::std::default::Default::default()
    }

    // optional string car_wifi_bssid = 1;

    pub fn car_wifi_bssid(&self) -> &str {
        match self.car_wifi_bssid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_car_wifi_bssid(&mut self) {
        self.car_wifi_bssid = ::std::option::Option::None;
    }

    pub fn has_car_wifi_bssid(&self) -> bool {
        self.car_wifi_bssid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_car_wifi_bssid(&mut self, v: ::std::string::String) {
        self.car_wifi_bssid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_car_wifi_bssid(&mut self) -> &mut ::std::string::String {
        if self.car_wifi_bssid.is_none() {
            self.car_wifi_bssid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.car_wifi_bssid.as_mut().unwrap()
    }

    // Take field
    pub fn take_car_wifi_bssid(&mut self) -> ::std::string::String {
        self.car_wifi_bssid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "car_wifi_bssid",
            |m: &WifiProjectionService| { &m.car_wifi_bssid },
            |m: &mut WifiProjectionService| { &mut m.car_wifi_bssid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WifiProjectionService>(
            "WifiProjectionService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WifiProjectionService {
    const NAME: &'static str = "WifiProjectionService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.car_wifi_bssid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.car_wifi_bssid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.car_wifi_bssid.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WifiProjectionService {
        WifiProjectionService::new()
    }

    fn clear(&mut self) {
        self.car_wifi_bssid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WifiProjectionService {
        static instance: WifiProjectionService = WifiProjectionService {
            car_wifi_bssid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WifiProjectionService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WifiProjectionService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WifiProjectionService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WifiProjectionService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:WifiCredentialsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WifiCredentialsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:WifiCredentialsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WifiCredentialsRequest {
    fn default() -> &'a WifiCredentialsRequest {
        <WifiCredentialsRequest as ::protobuf::Message>::default_instance()
    }
}

impl WifiCredentialsRequest {
    pub fn new() -> WifiCredentialsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WifiCredentialsRequest>(
            "WifiCredentialsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WifiCredentialsRequest {
    const NAME: &'static str = "WifiCredentialsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WifiCredentialsRequest {
        WifiCredentialsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WifiCredentialsRequest {
        static instance: WifiCredentialsRequest = WifiCredentialsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WifiCredentialsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WifiCredentialsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WifiCredentialsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WifiCredentialsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:WifiCredentialsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WifiCredentialsResponse {
    // message fields
    // @@protoc_insertion_point(field:WifiCredentialsResponse.car_wifi_password)
    pub car_wifi_password: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WifiCredentialsResponse.car_wifi_security_mode)
    pub car_wifi_security_mode: ::std::option::Option<::protobuf::EnumOrUnknown<WifiSecurityMode>>,
    // @@protoc_insertion_point(field:WifiCredentialsResponse.car_wifi_ssid)
    pub car_wifi_ssid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WifiCredentialsResponse.supported_wifi_channels)
    pub supported_wifi_channels: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:WifiCredentialsResponse.access_point_type)
    pub access_point_type: ::std::option::Option<::protobuf::EnumOrUnknown<AccessPointType>>,
    // special fields
    // @@protoc_insertion_point(special_field:WifiCredentialsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WifiCredentialsResponse {
    fn default() -> &'a WifiCredentialsResponse {
        <WifiCredentialsResponse as ::protobuf::Message>::default_instance()
    }
}

impl WifiCredentialsResponse {
    pub fn new() -> WifiCredentialsResponse {
        ::std::default::Default::default()
    }

    // optional string car_wifi_password = 1;

    pub fn car_wifi_password(&self) -> &str {
        match self.car_wifi_password.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_car_wifi_password(&mut self) {
        self.car_wifi_password = ::std::option::Option::None;
    }

    pub fn has_car_wifi_password(&self) -> bool {
        self.car_wifi_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_car_wifi_password(&mut self, v: ::std::string::String) {
        self.car_wifi_password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_car_wifi_password(&mut self) -> &mut ::std::string::String {
        if self.car_wifi_password.is_none() {
            self.car_wifi_password = ::std::option::Option::Some(::std::string::String::new());
        }
        self.car_wifi_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_car_wifi_password(&mut self) -> ::std::string::String {
        self.car_wifi_password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .WifiSecurityMode car_wifi_security_mode = 2;

    pub fn car_wifi_security_mode(&self) -> WifiSecurityMode {
        match self.car_wifi_security_mode {
            Some(e) => e.enum_value_or(WifiSecurityMode::UNKNOWN_SECURITY_MODE),
            None => WifiSecurityMode::UNKNOWN_SECURITY_MODE,
        }
    }

    pub fn clear_car_wifi_security_mode(&mut self) {
        self.car_wifi_security_mode = ::std::option::Option::None;
    }

    pub fn has_car_wifi_security_mode(&self) -> bool {
        self.car_wifi_security_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_car_wifi_security_mode(&mut self, v: WifiSecurityMode) {
        self.car_wifi_security_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string car_wifi_ssid = 3;

    pub fn car_wifi_ssid(&self) -> &str {
        match self.car_wifi_ssid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_car_wifi_ssid(&mut self) {
        self.car_wifi_ssid = ::std::option::Option::None;
    }

    pub fn has_car_wifi_ssid(&self) -> bool {
        self.car_wifi_ssid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_car_wifi_ssid(&mut self, v: ::std::string::String) {
        self.car_wifi_ssid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_car_wifi_ssid(&mut self) -> &mut ::std::string::String {
        if self.car_wifi_ssid.is_none() {
            self.car_wifi_ssid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.car_wifi_ssid.as_mut().unwrap()
    }

    // Take field
    pub fn take_car_wifi_ssid(&mut self) -> ::std::string::String {
        self.car_wifi_ssid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .AccessPointType access_point_type = 5;

    pub fn access_point_type(&self) -> AccessPointType {
        match self.access_point_type {
            Some(e) => e.enum_value_or(AccessPointType::STATIC),
            None => AccessPointType::STATIC,
        }
    }

    pub fn clear_access_point_type(&mut self) {
        self.access_point_type = ::std::option::Option::None;
    }

    pub fn has_access_point_type(&self) -> bool {
        self.access_point_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_point_type(&mut self, v: AccessPointType) {
        self.access_point_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "car_wifi_password",
            |m: &WifiCredentialsResponse| { &m.car_wifi_password },
            |m: &mut WifiCredentialsResponse| { &mut m.car_wifi_password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "car_wifi_security_mode",
            |m: &WifiCredentialsResponse| { &m.car_wifi_security_mode },
            |m: &mut WifiCredentialsResponse| { &mut m.car_wifi_security_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "car_wifi_ssid",
            |m: &WifiCredentialsResponse| { &m.car_wifi_ssid },
            |m: &mut WifiCredentialsResponse| { &mut m.car_wifi_ssid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_wifi_channels",
            |m: &WifiCredentialsResponse| { &m.supported_wifi_channels },
            |m: &mut WifiCredentialsResponse| { &mut m.supported_wifi_channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_point_type",
            |m: &WifiCredentialsResponse| { &m.access_point_type },
            |m: &mut WifiCredentialsResponse| { &mut m.access_point_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WifiCredentialsResponse>(
            "WifiCredentialsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WifiCredentialsResponse {
    const NAME: &'static str = "WifiCredentialsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.car_wifi_password = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.car_wifi_security_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.car_wifi_ssid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.supported_wifi_channels)?;
                },
                32 => {
                    self.supported_wifi_channels.push(is.read_int32()?);
                },
                40 => {
                    self.access_point_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.car_wifi_password.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.car_wifi_security_mode {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.car_wifi_ssid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.supported_wifi_channels {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        if let Some(v) = self.access_point_type {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.car_wifi_password.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.car_wifi_security_mode {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.car_wifi_ssid.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.supported_wifi_channels {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.access_point_type {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WifiCredentialsResponse {
        WifiCredentialsResponse::new()
    }

    fn clear(&mut self) {
        self.car_wifi_password = ::std::option::Option::None;
        self.car_wifi_security_mode = ::std::option::Option::None;
        self.car_wifi_ssid = ::std::option::Option::None;
        self.supported_wifi_channels.clear();
        self.access_point_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WifiCredentialsResponse {
        static instance: WifiCredentialsResponse = WifiCredentialsResponse {
            car_wifi_password: ::std::option::Option::None,
            car_wifi_security_mode: ::std::option::Option::None,
            car_wifi_ssid: ::std::option::Option::None,
            supported_wifi_channels: ::std::vec::Vec::new(),
            access_point_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WifiCredentialsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WifiCredentialsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WifiCredentialsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WifiCredentialsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioStateNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioStateNotification {
    // message fields
    // @@protoc_insertion_point(field:RadioStateNotification.radio_source_enabled)
    pub radio_source_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioStateNotification.radio_muted)
    pub radio_muted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RadioStateNotification.active_radio_id)
    pub active_radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioStateNotification.station_info)
    pub station_info: ::protobuf::MessageField<RadioStationInfo>,
    // @@protoc_insertion_point(field:RadioStateNotification.program_list)
    pub program_list: ::std::vec::Vec<RadioStationInfo>,
    // @@protoc_insertion_point(field:RadioStateNotification.station_preset_lists)
    pub station_preset_lists: ::std::vec::Vec<StationPresetList>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioStateNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioStateNotification {
    fn default() -> &'a RadioStateNotification {
        <RadioStateNotification as ::protobuf::Message>::default_instance()
    }
}

impl RadioStateNotification {
    pub fn new() -> RadioStateNotification {
        ::std::default::Default::default()
    }

    // required bool radio_source_enabled = 1;

    pub fn radio_source_enabled(&self) -> bool {
        self.radio_source_enabled.unwrap_or(false)
    }

    pub fn clear_radio_source_enabled(&mut self) {
        self.radio_source_enabled = ::std::option::Option::None;
    }

    pub fn has_radio_source_enabled(&self) -> bool {
        self.radio_source_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_source_enabled(&mut self, v: bool) {
        self.radio_source_enabled = ::std::option::Option::Some(v);
    }

    // optional bool radio_muted = 2;

    pub fn radio_muted(&self) -> bool {
        self.radio_muted.unwrap_or(false)
    }

    pub fn clear_radio_muted(&mut self) {
        self.radio_muted = ::std::option::Option::None;
    }

    pub fn has_radio_muted(&self) -> bool {
        self.radio_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_muted(&mut self, v: bool) {
        self.radio_muted = ::std::option::Option::Some(v);
    }

    // required int32 active_radio_id = 3;

    pub fn active_radio_id(&self) -> i32 {
        self.active_radio_id.unwrap_or(0)
    }

    pub fn clear_active_radio_id(&mut self) {
        self.active_radio_id = ::std::option::Option::None;
    }

    pub fn has_active_radio_id(&self) -> bool {
        self.active_radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_radio_id(&mut self, v: i32) {
        self.active_radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_source_enabled",
            |m: &RadioStateNotification| { &m.radio_source_enabled },
            |m: &mut RadioStateNotification| { &mut m.radio_source_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_muted",
            |m: &RadioStateNotification| { &m.radio_muted },
            |m: &mut RadioStateNotification| { &mut m.radio_muted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_radio_id",
            |m: &RadioStateNotification| { &m.active_radio_id },
            |m: &mut RadioStateNotification| { &mut m.active_radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RadioStationInfo>(
            "station_info",
            |m: &RadioStateNotification| { &m.station_info },
            |m: &mut RadioStateNotification| { &mut m.station_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "program_list",
            |m: &RadioStateNotification| { &m.program_list },
            |m: &mut RadioStateNotification| { &mut m.program_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "station_preset_lists",
            |m: &RadioStateNotification| { &m.station_preset_lists },
            |m: &mut RadioStateNotification| { &mut m.station_preset_lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioStateNotification>(
            "RadioStateNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioStateNotification {
    const NAME: &'static str = "RadioStateNotification";

    fn is_initialized(&self) -> bool {
        if self.radio_source_enabled.is_none() {
            return false;
        }
        if self.active_radio_id.is_none() {
            return false;
        }
        if self.station_info.is_none() {
            return false;
        }
        for v in &self.station_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.program_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.station_preset_lists {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_source_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.radio_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.active_radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.station_info)?;
                },
                42 => {
                    self.program_list.push(is.read_message()?);
                },
                50 => {
                    self.station_preset_lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_source_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.radio_muted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.active_radio_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.station_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.program_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.station_preset_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_source_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.radio_muted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.active_radio_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.station_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.program_list {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.station_preset_lists {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioStateNotification {
        RadioStateNotification::new()
    }

    fn clear(&mut self) {
        self.radio_source_enabled = ::std::option::Option::None;
        self.radio_muted = ::std::option::Option::None;
        self.active_radio_id = ::std::option::Option::None;
        self.station_info.clear();
        self.program_list.clear();
        self.station_preset_lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioStateNotification {
        static instance: RadioStateNotification = RadioStateNotification {
            radio_source_enabled: ::std::option::Option::None,
            radio_muted: ::std::option::Option::None,
            active_radio_id: ::std::option::Option::None,
            station_info: ::protobuf::MessageField::none(),
            program_list: ::std::vec::Vec::new(),
            station_preset_lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioStateNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioStateNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioStateNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioStateNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioSourceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioSourceRequest {
    // special fields
    // @@protoc_insertion_point(special_field:RadioSourceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioSourceRequest {
    fn default() -> &'a RadioSourceRequest {
        <RadioSourceRequest as ::protobuf::Message>::default_instance()
    }
}

impl RadioSourceRequest {
    pub fn new() -> RadioSourceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioSourceRequest>(
            "RadioSourceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioSourceRequest {
    const NAME: &'static str = "RadioSourceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioSourceRequest {
        RadioSourceRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioSourceRequest {
        static instance: RadioSourceRequest = RadioSourceRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioSourceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioSourceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioSourceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioSourceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioSourceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioSourceResponse {
    // message fields
    // @@protoc_insertion_point(field:RadioSourceResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:RadioSourceResponse.radio_source_enabled)
    pub radio_source_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioSourceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioSourceResponse {
    fn default() -> &'a RadioSourceResponse {
        <RadioSourceResponse as ::protobuf::Message>::default_instance()
    }
}

impl RadioSourceResponse {
    pub fn new() -> RadioSourceResponse {
        ::std::default::Default::default()
    }

    // optional .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required bool radio_source_enabled = 2;

    pub fn radio_source_enabled(&self) -> bool {
        self.radio_source_enabled.unwrap_or(false)
    }

    pub fn clear_radio_source_enabled(&mut self) {
        self.radio_source_enabled = ::std::option::Option::None;
    }

    pub fn has_radio_source_enabled(&self) -> bool {
        self.radio_source_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_source_enabled(&mut self, v: bool) {
        self.radio_source_enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &RadioSourceResponse| { &m.status },
            |m: &mut RadioSourceResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_source_enabled",
            |m: &RadioSourceResponse| { &m.radio_source_enabled },
            |m: &mut RadioSourceResponse| { &mut m.radio_source_enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioSourceResponse>(
            "RadioSourceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioSourceResponse {
    const NAME: &'static str = "RadioSourceResponse";

    fn is_initialized(&self) -> bool {
        if self.radio_source_enabled.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_source_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_source_enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_source_enabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioSourceResponse {
        RadioSourceResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_source_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioSourceResponse {
        static instance: RadioSourceResponse = RadioSourceResponse {
            status: ::std::option::Option::None,
            radio_source_enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioSourceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioSourceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioSourceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioSourceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SelectActiveRadioRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectActiveRadioRequest {
    // message fields
    // @@protoc_insertion_point(field:SelectActiveRadioRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SelectActiveRadioRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectActiveRadioRequest {
    fn default() -> &'a SelectActiveRadioRequest {
        <SelectActiveRadioRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectActiveRadioRequest {
    pub fn new() -> SelectActiveRadioRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &SelectActiveRadioRequest| { &m.radio_id },
            |m: &mut SelectActiveRadioRequest| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectActiveRadioRequest>(
            "SelectActiveRadioRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectActiveRadioRequest {
    const NAME: &'static str = "SelectActiveRadioRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectActiveRadioRequest {
        SelectActiveRadioRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectActiveRadioRequest {
        static instance: SelectActiveRadioRequest = SelectActiveRadioRequest {
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectActiveRadioRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectActiveRadioRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectActiveRadioRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectActiveRadioRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ActiveRadioNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActiveRadioNotification {
    // message fields
    // @@protoc_insertion_point(field:ActiveRadioNotification.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:ActiveRadioNotification.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ActiveRadioNotification.station_info)
    pub station_info: ::protobuf::MessageField<RadioStationInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ActiveRadioNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActiveRadioNotification {
    fn default() -> &'a ActiveRadioNotification {
        <ActiveRadioNotification as ::protobuf::Message>::default_instance()
    }
}

impl ActiveRadioNotification {
    pub fn new() -> ActiveRadioNotification {
        ::std::default::Default::default()
    }

    // optional .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ActiveRadioNotification| { &m.status },
            |m: &mut ActiveRadioNotification| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &ActiveRadioNotification| { &m.radio_id },
            |m: &mut ActiveRadioNotification| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RadioStationInfo>(
            "station_info",
            |m: &ActiveRadioNotification| { &m.station_info },
            |m: &mut ActiveRadioNotification| { &mut m.station_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActiveRadioNotification>(
            "ActiveRadioNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActiveRadioNotification {
    const NAME: &'static str = "ActiveRadioNotification";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        for v in &self.station_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.station_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.station_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.station_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActiveRadioNotification {
        ActiveRadioNotification::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.station_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActiveRadioNotification {
        static instance: ActiveRadioNotification = ActiveRadioNotification {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            station_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActiveRadioNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActiveRadioNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActiveRadioNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActiveRadioNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StepChannelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StepChannelRequest {
    // message fields
    // @@protoc_insertion_point(field:StepChannelRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StepChannelRequest.up)
    pub up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StepChannelRequest.skip_sub_channel)
    pub skip_sub_channel: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:StepChannelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StepChannelRequest {
    fn default() -> &'a StepChannelRequest {
        <StepChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl StepChannelRequest {
    pub fn new() -> StepChannelRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required bool up = 2;

    pub fn up(&self) -> bool {
        self.up.unwrap_or(false)
    }

    pub fn clear_up(&mut self) {
        self.up = ::std::option::Option::None;
    }

    pub fn has_up(&self) -> bool {
        self.up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up(&mut self, v: bool) {
        self.up = ::std::option::Option::Some(v);
    }

    // required bool skip_sub_channel = 3;

    pub fn skip_sub_channel(&self) -> bool {
        self.skip_sub_channel.unwrap_or(false)
    }

    pub fn clear_skip_sub_channel(&mut self) {
        self.skip_sub_channel = ::std::option::Option::None;
    }

    pub fn has_skip_sub_channel(&self) -> bool {
        self.skip_sub_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_sub_channel(&mut self, v: bool) {
        self.skip_sub_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &StepChannelRequest| { &m.radio_id },
            |m: &mut StepChannelRequest| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "up",
            |m: &StepChannelRequest| { &m.up },
            |m: &mut StepChannelRequest| { &mut m.up },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_sub_channel",
            |m: &StepChannelRequest| { &m.skip_sub_channel },
            |m: &mut StepChannelRequest| { &mut m.skip_sub_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepChannelRequest>(
            "StepChannelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StepChannelRequest {
    const NAME: &'static str = "StepChannelRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.up.is_none() {
            return false;
        }
        if self.skip_sub_channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.up = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.skip_sub_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.skip_sub_channel {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.up {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.skip_sub_channel {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StepChannelRequest {
        StepChannelRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.up = ::std::option::Option::None;
        self.skip_sub_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StepChannelRequest {
        static instance: StepChannelRequest = StepChannelRequest {
            radio_id: ::std::option::Option::None,
            up: ::std::option::Option::None,
            skip_sub_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StepChannelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StepChannelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StepChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepChannelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StepChannelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StepChannelResponse {
    // message fields
    // @@protoc_insertion_point(field:StepChannelResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:StepChannelResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:StepChannelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StepChannelResponse {
    fn default() -> &'a StepChannelResponse {
        <StepChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl StepChannelResponse {
    pub fn new() -> StepChannelResponse {
        ::std::default::Default::default()
    }

    // optional .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &StepChannelResponse| { &m.status },
            |m: &mut StepChannelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &StepChannelResponse| { &m.radio_id },
            |m: &mut StepChannelResponse| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepChannelResponse>(
            "StepChannelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StepChannelResponse {
    const NAME: &'static str = "StepChannelResponse";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StepChannelResponse {
        StepChannelResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StepChannelResponse {
        static instance: StepChannelResponse = StepChannelResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StepChannelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StepChannelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StepChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepChannelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SeekStationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SeekStationRequest {
    // message fields
    // @@protoc_insertion_point(field:SeekStationRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SeekStationRequest.up)
    pub up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SeekStationRequest.skip_sub_channel)
    pub skip_sub_channel: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SeekStationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SeekStationRequest {
    fn default() -> &'a SeekStationRequest {
        <SeekStationRequest as ::protobuf::Message>::default_instance()
    }
}

impl SeekStationRequest {
    pub fn new() -> SeekStationRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required bool up = 2;

    pub fn up(&self) -> bool {
        self.up.unwrap_or(false)
    }

    pub fn clear_up(&mut self) {
        self.up = ::std::option::Option::None;
    }

    pub fn has_up(&self) -> bool {
        self.up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up(&mut self, v: bool) {
        self.up = ::std::option::Option::Some(v);
    }

    // required bool skip_sub_channel = 3;

    pub fn skip_sub_channel(&self) -> bool {
        self.skip_sub_channel.unwrap_or(false)
    }

    pub fn clear_skip_sub_channel(&mut self) {
        self.skip_sub_channel = ::std::option::Option::None;
    }

    pub fn has_skip_sub_channel(&self) -> bool {
        self.skip_sub_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_sub_channel(&mut self, v: bool) {
        self.skip_sub_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &SeekStationRequest| { &m.radio_id },
            |m: &mut SeekStationRequest| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "up",
            |m: &SeekStationRequest| { &m.up },
            |m: &mut SeekStationRequest| { &mut m.up },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_sub_channel",
            |m: &SeekStationRequest| { &m.skip_sub_channel },
            |m: &mut SeekStationRequest| { &mut m.skip_sub_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SeekStationRequest>(
            "SeekStationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SeekStationRequest {
    const NAME: &'static str = "SeekStationRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.up.is_none() {
            return false;
        }
        if self.skip_sub_channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.up = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.skip_sub_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.skip_sub_channel {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.up {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.skip_sub_channel {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SeekStationRequest {
        SeekStationRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.up = ::std::option::Option::None;
        self.skip_sub_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SeekStationRequest {
        static instance: SeekStationRequest = SeekStationRequest {
            radio_id: ::std::option::Option::None,
            up: ::std::option::Option::None,
            skip_sub_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SeekStationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SeekStationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SeekStationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekStationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SeekStationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SeekStationResponse {
    // message fields
    // @@protoc_insertion_point(field:SeekStationResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:SeekStationResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SeekStationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SeekStationResponse {
    fn default() -> &'a SeekStationResponse {
        <SeekStationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeekStationResponse {
    pub fn new() -> SeekStationResponse {
        ::std::default::Default::default()
    }

    // optional .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SeekStationResponse| { &m.status },
            |m: &mut SeekStationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &SeekStationResponse| { &m.radio_id },
            |m: &mut SeekStationResponse| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SeekStationResponse>(
            "SeekStationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SeekStationResponse {
    const NAME: &'static str = "SeekStationResponse";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SeekStationResponse {
        SeekStationResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SeekStationResponse {
        static instance: SeekStationResponse = SeekStationResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SeekStationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SeekStationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SeekStationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekStationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ScanStationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScanStationsRequest {
    // message fields
    // @@protoc_insertion_point(field:ScanStationsRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ScanStationsRequest.start)
    pub start: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ScanStationsRequest.up)
    pub up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ScanStationsRequest.skip_sub_channel)
    pub skip_sub_channel: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ScanStationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScanStationsRequest {
    fn default() -> &'a ScanStationsRequest {
        <ScanStationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ScanStationsRequest {
    pub fn new() -> ScanStationsRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required bool start = 2;

    pub fn start(&self) -> bool {
        self.start.unwrap_or(false)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: bool) {
        self.start = ::std::option::Option::Some(v);
    }

    // required bool up = 3;

    pub fn up(&self) -> bool {
        self.up.unwrap_or(false)
    }

    pub fn clear_up(&mut self) {
        self.up = ::std::option::Option::None;
    }

    pub fn has_up(&self) -> bool {
        self.up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up(&mut self, v: bool) {
        self.up = ::std::option::Option::Some(v);
    }

    // required bool skip_sub_channel = 4;

    pub fn skip_sub_channel(&self) -> bool {
        self.skip_sub_channel.unwrap_or(false)
    }

    pub fn clear_skip_sub_channel(&mut self) {
        self.skip_sub_channel = ::std::option::Option::None;
    }

    pub fn has_skip_sub_channel(&self) -> bool {
        self.skip_sub_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_sub_channel(&mut self, v: bool) {
        self.skip_sub_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &ScanStationsRequest| { &m.radio_id },
            |m: &mut ScanStationsRequest| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &ScanStationsRequest| { &m.start },
            |m: &mut ScanStationsRequest| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "up",
            |m: &ScanStationsRequest| { &m.up },
            |m: &mut ScanStationsRequest| { &mut m.up },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_sub_channel",
            |m: &ScanStationsRequest| { &m.skip_sub_channel },
            |m: &mut ScanStationsRequest| { &mut m.skip_sub_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScanStationsRequest>(
            "ScanStationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScanStationsRequest {
    const NAME: &'static str = "ScanStationsRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.start.is_none() {
            return false;
        }
        if self.up.is_none() {
            return false;
        }
        if self.skip_sub_channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.start = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.up = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.skip_sub_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.start {
            my_size += 1 + 1;
        }
        if let Some(v) = self.up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.skip_sub_channel {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.start {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.up {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.skip_sub_channel {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScanStationsRequest {
        ScanStationsRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.up = ::std::option::Option::None;
        self.skip_sub_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScanStationsRequest {
        static instance: ScanStationsRequest = ScanStationsRequest {
            radio_id: ::std::option::Option::None,
            start: ::std::option::Option::None,
            up: ::std::option::Option::None,
            skip_sub_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScanStationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScanStationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScanStationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanStationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ScanStationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScanStationsResponse {
    // message fields
    // @@protoc_insertion_point(field:ScanStationsResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:ScanStationsResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ScanStationsResponse.started)
    pub started: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ScanStationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScanStationsResponse {
    fn default() -> &'a ScanStationsResponse {
        <ScanStationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ScanStationsResponse {
    pub fn new() -> ScanStationsResponse {
        ::std::default::Default::default()
    }

    // optional .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // optional bool started = 3;

    pub fn started(&self) -> bool {
        self.started.unwrap_or(false)
    }

    pub fn clear_started(&mut self) {
        self.started = ::std::option::Option::None;
    }

    pub fn has_started(&self) -> bool {
        self.started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started(&mut self, v: bool) {
        self.started = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ScanStationsResponse| { &m.status },
            |m: &mut ScanStationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &ScanStationsResponse| { &m.radio_id },
            |m: &mut ScanStationsResponse| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "started",
            |m: &ScanStationsResponse| { &m.started },
            |m: &mut ScanStationsResponse| { &mut m.started },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScanStationsResponse>(
            "ScanStationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScanStationsResponse {
    const NAME: &'static str = "ScanStationsResponse";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.started = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.started {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.started {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScanStationsResponse {
        ScanStationsResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.started = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScanStationsResponse {
        static instance: ScanStationsResponse = ScanStationsResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            started: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScanStationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScanStationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScanStationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanStationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TuneToStationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TuneToStationRequest {
    // message fields
    // @@protoc_insertion_point(field:TuneToStationRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TuneToStationRequest.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TuneToStationRequest.sub_channel)
    pub sub_channel: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:TuneToStationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TuneToStationRequest {
    fn default() -> &'a TuneToStationRequest {
        <TuneToStationRequest as ::protobuf::Message>::default_instance()
    }
}

impl TuneToStationRequest {
    pub fn new() -> TuneToStationRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required int32 channel = 2;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional int32 sub_channel = 3;

    pub fn sub_channel(&self) -> i32 {
        self.sub_channel.unwrap_or(0)
    }

    pub fn clear_sub_channel(&mut self) {
        self.sub_channel = ::std::option::Option::None;
    }

    pub fn has_sub_channel(&self) -> bool {
        self.sub_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_channel(&mut self, v: i32) {
        self.sub_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &TuneToStationRequest| { &m.radio_id },
            |m: &mut TuneToStationRequest| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &TuneToStationRequest| { &m.channel },
            |m: &mut TuneToStationRequest| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sub_channel",
            |m: &TuneToStationRequest| { &m.sub_channel },
            |m: &mut TuneToStationRequest| { &mut m.sub_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TuneToStationRequest>(
            "TuneToStationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TuneToStationRequest {
    const NAME: &'static str = "TuneToStationRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.sub_channel = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.sub_channel {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.sub_channel {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TuneToStationRequest {
        TuneToStationRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.sub_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TuneToStationRequest {
        static instance: TuneToStationRequest = TuneToStationRequest {
            radio_id: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            sub_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TuneToStationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TuneToStationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TuneToStationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TuneToStationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TuneToStationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TuneToStationResponse {
    // message fields
    // @@protoc_insertion_point(field:TuneToStationResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:TuneToStationResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:TuneToStationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TuneToStationResponse {
    fn default() -> &'a TuneToStationResponse {
        <TuneToStationResponse as ::protobuf::Message>::default_instance()
    }
}

impl TuneToStationResponse {
    pub fn new() -> TuneToStationResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &TuneToStationResponse| { &m.status },
            |m: &mut TuneToStationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &TuneToStationResponse| { &m.radio_id },
            |m: &mut TuneToStationResponse| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TuneToStationResponse>(
            "TuneToStationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TuneToStationResponse {
    const NAME: &'static str = "TuneToStationResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TuneToStationResponse {
        TuneToStationResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TuneToStationResponse {
        static instance: TuneToStationResponse = TuneToStationResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TuneToStationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TuneToStationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TuneToStationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TuneToStationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioStationInfoNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioStationInfoNotification {
    // message fields
    // @@protoc_insertion_point(field:RadioStationInfoNotification.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioStationInfoNotification.station_info)
    pub station_info: ::protobuf::MessageField<RadioStationInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioStationInfoNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioStationInfoNotification {
    fn default() -> &'a RadioStationInfoNotification {
        <RadioStationInfoNotification as ::protobuf::Message>::default_instance()
    }
}

impl RadioStationInfoNotification {
    pub fn new() -> RadioStationInfoNotification {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &RadioStationInfoNotification| { &m.radio_id },
            |m: &mut RadioStationInfoNotification| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RadioStationInfo>(
            "station_info",
            |m: &RadioStationInfoNotification| { &m.station_info },
            |m: &mut RadioStationInfoNotification| { &mut m.station_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioStationInfoNotification>(
            "RadioStationInfoNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioStationInfoNotification {
    const NAME: &'static str = "RadioStationInfoNotification";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.station_info.is_none() {
            return false;
        }
        for v in &self.station_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.station_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.station_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.station_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioStationInfoNotification {
        RadioStationInfoNotification::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.station_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioStationInfoNotification {
        static instance: RadioStationInfoNotification = RadioStationInfoNotification {
            radio_id: ::std::option::Option::None,
            station_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioStationInfoNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioStationInfoNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioStationInfoNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioStationInfoNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioStationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioStationInfo {
    // message fields
    // @@protoc_insertion_point(field:RadioStationInfo.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<RadioType>>,
    // @@protoc_insertion_point(field:RadioStationInfo.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioStationInfo.sub_channel)
    pub sub_channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioStationInfo.meta_data)
    pub meta_data: ::protobuf::MessageField<RadioStationMetaData>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioStationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioStationInfo {
    fn default() -> &'a RadioStationInfo {
        <RadioStationInfo as ::protobuf::Message>::default_instance()
    }
}

impl RadioStationInfo {
    pub fn new() -> RadioStationInfo {
        ::std::default::Default::default()
    }

    // required .RadioType type = 1;

    pub fn type_(&self) -> RadioType {
        match self.type_ {
            Some(e) => e.enum_value_or(RadioType::AM_RADIO),
            None => RadioType::AM_RADIO,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: RadioType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 channel = 2;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional int32 sub_channel = 3;

    pub fn sub_channel(&self) -> i32 {
        self.sub_channel.unwrap_or(0)
    }

    pub fn clear_sub_channel(&mut self) {
        self.sub_channel = ::std::option::Option::None;
    }

    pub fn has_sub_channel(&self) -> bool {
        self.sub_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_channel(&mut self, v: i32) {
        self.sub_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &RadioStationInfo| { &m.type_ },
            |m: &mut RadioStationInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &RadioStationInfo| { &m.channel },
            |m: &mut RadioStationInfo| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sub_channel",
            |m: &RadioStationInfo| { &m.sub_channel },
            |m: &mut RadioStationInfo| { &mut m.sub_channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RadioStationMetaData>(
            "meta_data",
            |m: &RadioStationInfo| { &m.meta_data },
            |m: &mut RadioStationInfo| { &mut m.meta_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioStationInfo>(
            "RadioStationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioStationInfo {
    const NAME: &'static str = "RadioStationInfo";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.channel.is_none() {
            return false;
        }
        for v in &self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.sub_channel = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.sub_channel {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.meta_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.channel {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.sub_channel {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.meta_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioStationInfo {
        RadioStationInfo::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.sub_channel = ::std::option::Option::None;
        self.meta_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioStationInfo {
        static instance: RadioStationInfo = RadioStationInfo {
            type_: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            sub_channel: ::std::option::Option::None,
            meta_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioStationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioStationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioStationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioStationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RadioStationMetaData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RadioStationMetaData {
    // message fields
    // @@protoc_insertion_point(field:RadioStationMetaData.audio_channels)
    pub audio_channels: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioStationMetaData.signal_quality)
    pub signal_quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RadioStationMetaData.rds)
    pub rds: ::protobuf::MessageField<RdsData>,
    // @@protoc_insertion_point(field:RadioStationMetaData.hd_station_info)
    pub hd_station_info: ::protobuf::MessageField<HdRadioStationInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:RadioStationMetaData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadioStationMetaData {
    fn default() -> &'a RadioStationMetaData {
        <RadioStationMetaData as ::protobuf::Message>::default_instance()
    }
}

impl RadioStationMetaData {
    pub fn new() -> RadioStationMetaData {
        ::std::default::Default::default()
    }

    // optional int32 audio_channels = 1;

    pub fn audio_channels(&self) -> i32 {
        self.audio_channels.unwrap_or(0)
    }

    pub fn clear_audio_channels(&mut self) {
        self.audio_channels = ::std::option::Option::None;
    }

    pub fn has_audio_channels(&self) -> bool {
        self.audio_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: i32) {
        self.audio_channels = ::std::option::Option::Some(v);
    }

    // optional int32 signal_quality = 2;

    pub fn signal_quality(&self) -> i32 {
        self.signal_quality.unwrap_or(0)
    }

    pub fn clear_signal_quality(&mut self) {
        self.signal_quality = ::std::option::Option::None;
    }

    pub fn has_signal_quality(&self) -> bool {
        self.signal_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signal_quality(&mut self, v: i32) {
        self.signal_quality = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_channels",
            |m: &RadioStationMetaData| { &m.audio_channels },
            |m: &mut RadioStationMetaData| { &mut m.audio_channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signal_quality",
            |m: &RadioStationMetaData| { &m.signal_quality },
            |m: &mut RadioStationMetaData| { &mut m.signal_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RdsData>(
            "rds",
            |m: &RadioStationMetaData| { &m.rds },
            |m: &mut RadioStationMetaData| { &mut m.rds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HdRadioStationInfo>(
            "hd_station_info",
            |m: &RadioStationMetaData| { &m.hd_station_info },
            |m: &mut RadioStationMetaData| { &mut m.hd_station_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadioStationMetaData>(
            "RadioStationMetaData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadioStationMetaData {
    const NAME: &'static str = "RadioStationMetaData";

    fn is_initialized(&self) -> bool {
        for v in &self.rds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hd_station_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.audio_channels = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.signal_quality = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rds)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hd_station_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio_channels {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.signal_quality {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rds.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hd_station_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio_channels {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.signal_quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rds.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.hd_station_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadioStationMetaData {
        RadioStationMetaData::new()
    }

    fn clear(&mut self) {
        self.audio_channels = ::std::option::Option::None;
        self.signal_quality = ::std::option::Option::None;
        self.rds.clear();
        self.hd_station_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadioStationMetaData {
        static instance: RadioStationMetaData = RadioStationMetaData {
            audio_channels: ::std::option::Option::None,
            signal_quality: ::std::option::Option::None,
            rds: ::protobuf::MessageField::none(),
            hd_station_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadioStationMetaData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadioStationMetaData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadioStationMetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadioStationMetaData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RdsData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RdsData {
    // message fields
    // @@protoc_insertion_point(field:RdsData.alternative_frequencies)
    pub alternative_frequencies: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:RdsData.program_id)
    pub program_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RdsData.music_speech_switch)
    pub music_speech_switch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RdsData.program_service_name)
    pub program_service_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RdsData.program_type)
    pub program_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:RdsData.program_type_name)
    pub program_type_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RdsData.radio_text)
    pub radio_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RdsData.traffic_program_flag)
    pub traffic_program_flag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:RdsData.traffic_announcement_flag)
    pub traffic_announcement_flag: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RdsData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RdsData {
    fn default() -> &'a RdsData {
        <RdsData as ::protobuf::Message>::default_instance()
    }
}

impl RdsData {
    pub fn new() -> RdsData {
        ::std::default::Default::default()
    }

    // optional int32 program_id = 2;

    pub fn program_id(&self) -> i32 {
        self.program_id.unwrap_or(0)
    }

    pub fn clear_program_id(&mut self) {
        self.program_id = ::std::option::Option::None;
    }

    pub fn has_program_id(&self) -> bool {
        self.program_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_id(&mut self, v: i32) {
        self.program_id = ::std::option::Option::Some(v);
    }

    // optional int32 music_speech_switch = 3;

    pub fn music_speech_switch(&self) -> i32 {
        self.music_speech_switch.unwrap_or(0)
    }

    pub fn clear_music_speech_switch(&mut self) {
        self.music_speech_switch = ::std::option::Option::None;
    }

    pub fn has_music_speech_switch(&self) -> bool {
        self.music_speech_switch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_speech_switch(&mut self, v: i32) {
        self.music_speech_switch = ::std::option::Option::Some(v);
    }

    // optional string program_service_name = 4;

    pub fn program_service_name(&self) -> &str {
        match self.program_service_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_program_service_name(&mut self) {
        self.program_service_name = ::std::option::Option::None;
    }

    pub fn has_program_service_name(&self) -> bool {
        self.program_service_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_service_name(&mut self, v: ::std::string::String) {
        self.program_service_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_program_service_name(&mut self) -> &mut ::std::string::String {
        if self.program_service_name.is_none() {
            self.program_service_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.program_service_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_program_service_name(&mut self) -> ::std::string::String {
        self.program_service_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 program_type = 5;

    pub fn program_type(&self) -> i32 {
        self.program_type.unwrap_or(0)
    }

    pub fn clear_program_type(&mut self) {
        self.program_type = ::std::option::Option::None;
    }

    pub fn has_program_type(&self) -> bool {
        self.program_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_type(&mut self, v: i32) {
        self.program_type = ::std::option::Option::Some(v);
    }

    // optional string program_type_name = 6;

    pub fn program_type_name(&self) -> &str {
        match self.program_type_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_program_type_name(&mut self) {
        self.program_type_name = ::std::option::Option::None;
    }

    pub fn has_program_type_name(&self) -> bool {
        self.program_type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_type_name(&mut self, v: ::std::string::String) {
        self.program_type_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_program_type_name(&mut self) -> &mut ::std::string::String {
        if self.program_type_name.is_none() {
            self.program_type_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.program_type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_program_type_name(&mut self) -> ::std::string::String {
        self.program_type_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string radio_text = 7;

    pub fn radio_text(&self) -> &str {
        match self.radio_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radio_text(&mut self) {
        self.radio_text = ::std::option::Option::None;
    }

    pub fn has_radio_text(&self) -> bool {
        self.radio_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_text(&mut self, v: ::std::string::String) {
        self.radio_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radio_text(&mut self) -> &mut ::std::string::String {
        if self.radio_text.is_none() {
            self.radio_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radio_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_radio_text(&mut self) -> ::std::string::String {
        self.radio_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool traffic_program_flag = 8;

    pub fn traffic_program_flag(&self) -> bool {
        self.traffic_program_flag.unwrap_or(false)
    }

    pub fn clear_traffic_program_flag(&mut self) {
        self.traffic_program_flag = ::std::option::Option::None;
    }

    pub fn has_traffic_program_flag(&self) -> bool {
        self.traffic_program_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traffic_program_flag(&mut self, v: bool) {
        self.traffic_program_flag = ::std::option::Option::Some(v);
    }

    // optional bool traffic_announcement_flag = 9;

    pub fn traffic_announcement_flag(&self) -> bool {
        self.traffic_announcement_flag.unwrap_or(false)
    }

    pub fn clear_traffic_announcement_flag(&mut self) {
        self.traffic_announcement_flag = ::std::option::Option::None;
    }

    pub fn has_traffic_announcement_flag(&self) -> bool {
        self.traffic_announcement_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traffic_announcement_flag(&mut self, v: bool) {
        self.traffic_announcement_flag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alternative_frequencies",
            |m: &RdsData| { &m.alternative_frequencies },
            |m: &mut RdsData| { &mut m.alternative_frequencies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_id",
            |m: &RdsData| { &m.program_id },
            |m: &mut RdsData| { &mut m.program_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_speech_switch",
            |m: &RdsData| { &m.music_speech_switch },
            |m: &mut RdsData| { &mut m.music_speech_switch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_service_name",
            |m: &RdsData| { &m.program_service_name },
            |m: &mut RdsData| { &mut m.program_service_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_type",
            |m: &RdsData| { &m.program_type },
            |m: &mut RdsData| { &mut m.program_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_type_name",
            |m: &RdsData| { &m.program_type_name },
            |m: &mut RdsData| { &mut m.program_type_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_text",
            |m: &RdsData| { &m.radio_text },
            |m: &mut RdsData| { &mut m.radio_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "traffic_program_flag",
            |m: &RdsData| { &m.traffic_program_flag },
            |m: &mut RdsData| { &mut m.traffic_program_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "traffic_announcement_flag",
            |m: &RdsData| { &m.traffic_announcement_flag },
            |m: &mut RdsData| { &mut m.traffic_announcement_flag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RdsData>(
            "RdsData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RdsData {
    const NAME: &'static str = "RdsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.alternative_frequencies)?;
                },
                8 => {
                    self.alternative_frequencies.push(is.read_int32()?);
                },
                16 => {
                    self.program_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.music_speech_switch = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.program_service_name = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.program_type = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.program_type_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.radio_text = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.traffic_program_flag = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.traffic_announcement_flag = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.alternative_frequencies {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        if let Some(v) = self.program_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.music_speech_switch {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.program_service_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.program_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.program_type_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.radio_text.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.traffic_program_flag {
            my_size += 1 + 1;
        }
        if let Some(v) = self.traffic_announcement_flag {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.alternative_frequencies {
            os.write_int32(1, *v)?;
        };
        if let Some(v) = self.program_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.music_speech_switch {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.program_service_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.program_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.program_type_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.radio_text.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.traffic_program_flag {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.traffic_announcement_flag {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RdsData {
        RdsData::new()
    }

    fn clear(&mut self) {
        self.alternative_frequencies.clear();
        self.program_id = ::std::option::Option::None;
        self.music_speech_switch = ::std::option::Option::None;
        self.program_service_name = ::std::option::Option::None;
        self.program_type = ::std::option::Option::None;
        self.program_type_name = ::std::option::Option::None;
        self.radio_text = ::std::option::Option::None;
        self.traffic_program_flag = ::std::option::Option::None;
        self.traffic_announcement_flag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RdsData {
        static instance: RdsData = RdsData {
            alternative_frequencies: ::std::vec::Vec::new(),
            program_id: ::std::option::Option::None,
            music_speech_switch: ::std::option::Option::None,
            program_service_name: ::std::option::Option::None,
            program_type: ::std::option::Option::None,
            program_type_name: ::std::option::Option::None,
            radio_text: ::std::option::Option::None,
            traffic_program_flag: ::std::option::Option::None,
            traffic_announcement_flag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RdsData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RdsData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RdsData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RdsData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HdRadioStationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HdRadioStationInfo {
    // message fields
    // @@protoc_insertion_point(field:HdRadioStationInfo.acquisition_state)
    pub acquisition_state: ::std::option::Option<::protobuf::EnumOrUnknown<HdAcquisionState>>,
    // @@protoc_insertion_point(field:HdRadioStationInfo.digital_signal_strength)
    pub digital_signal_strength: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:HdRadioStationInfo.psd)
    pub psd: ::protobuf::MessageField<HdRadioPsdData>,
    // @@protoc_insertion_point(field:HdRadioStationInfo.sis)
    pub sis: ::protobuf::MessageField<HdRadioSisData>,
    // special fields
    // @@protoc_insertion_point(special_field:HdRadioStationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HdRadioStationInfo {
    fn default() -> &'a HdRadioStationInfo {
        <HdRadioStationInfo as ::protobuf::Message>::default_instance()
    }
}

impl HdRadioStationInfo {
    pub fn new() -> HdRadioStationInfo {
        ::std::default::Default::default()
    }

    // optional .HdAcquisionState acquisition_state = 1;

    pub fn acquisition_state(&self) -> HdAcquisionState {
        match self.acquisition_state {
            Some(e) => e.enum_value_or(HdAcquisionState::ANALOG),
            None => HdAcquisionState::ANALOG,
        }
    }

    pub fn clear_acquisition_state(&mut self) {
        self.acquisition_state = ::std::option::Option::None;
    }

    pub fn has_acquisition_state(&self) -> bool {
        self.acquisition_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acquisition_state(&mut self, v: HdAcquisionState) {
        self.acquisition_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 digital_signal_strength = 2;

    pub fn digital_signal_strength(&self) -> i32 {
        self.digital_signal_strength.unwrap_or(0)
    }

    pub fn clear_digital_signal_strength(&mut self) {
        self.digital_signal_strength = ::std::option::Option::None;
    }

    pub fn has_digital_signal_strength(&self) -> bool {
        self.digital_signal_strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digital_signal_strength(&mut self, v: i32) {
        self.digital_signal_strength = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acquisition_state",
            |m: &HdRadioStationInfo| { &m.acquisition_state },
            |m: &mut HdRadioStationInfo| { &mut m.acquisition_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digital_signal_strength",
            |m: &HdRadioStationInfo| { &m.digital_signal_strength },
            |m: &mut HdRadioStationInfo| { &mut m.digital_signal_strength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HdRadioPsdData>(
            "psd",
            |m: &HdRadioStationInfo| { &m.psd },
            |m: &mut HdRadioStationInfo| { &mut m.psd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HdRadioSisData>(
            "sis",
            |m: &HdRadioStationInfo| { &m.sis },
            |m: &mut HdRadioStationInfo| { &mut m.sis },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HdRadioStationInfo>(
            "HdRadioStationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HdRadioStationInfo {
    const NAME: &'static str = "HdRadioStationInfo";

    fn is_initialized(&self) -> bool {
        for v in &self.psd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.acquisition_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.digital_signal_strength = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.psd)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sis)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.acquisition_state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.digital_signal_strength {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.psd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.acquisition_state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.digital_signal_strength {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.psd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.sis.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HdRadioStationInfo {
        HdRadioStationInfo::new()
    }

    fn clear(&mut self) {
        self.acquisition_state = ::std::option::Option::None;
        self.digital_signal_strength = ::std::option::Option::None;
        self.psd.clear();
        self.sis.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HdRadioStationInfo {
        static instance: HdRadioStationInfo = HdRadioStationInfo {
            acquisition_state: ::std::option::Option::None,
            digital_signal_strength: ::std::option::Option::None,
            psd: ::protobuf::MessageField::none(),
            sis: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HdRadioStationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HdRadioStationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HdRadioStationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdRadioStationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HdRadioPsdData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HdRadioPsdData {
    // message fields
    // @@protoc_insertion_point(field:HdRadioPsdData.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioPsdData.artist)
    pub artist: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioPsdData.album)
    pub album: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioPsdData.genre)
    pub genre: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioPsdData.comment)
    pub comment: ::protobuf::MessageField<HdRadioComment>,
    // @@protoc_insertion_point(field:HdRadioPsdData.commercial)
    pub commercial: ::protobuf::MessageField<HdRadioCommercial>,
    // @@protoc_insertion_point(field:HdRadioPsdData.artist_experience)
    pub artist_experience: ::protobuf::MessageField<HdRadioArtistExperience>,
    // special fields
    // @@protoc_insertion_point(special_field:HdRadioPsdData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HdRadioPsdData {
    fn default() -> &'a HdRadioPsdData {
        <HdRadioPsdData as ::protobuf::Message>::default_instance()
    }
}

impl HdRadioPsdData {
    pub fn new() -> HdRadioPsdData {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string artist = 2;

    pub fn artist(&self) -> &str {
        match self.artist.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_artist(&mut self) {
        self.artist = ::std::option::Option::None;
    }

    pub fn has_artist(&self) -> bool {
        self.artist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::std::string::String) {
        self.artist = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist(&mut self) -> &mut ::std::string::String {
        if self.artist.is_none() {
            self.artist = ::std::option::Option::Some(::std::string::String::new());
        }
        self.artist.as_mut().unwrap()
    }

    // Take field
    pub fn take_artist(&mut self) -> ::std::string::String {
        self.artist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string album = 3;

    pub fn album(&self) -> &str {
        match self.album.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_album(&mut self) {
        self.album = ::std::option::Option::None;
    }

    pub fn has_album(&self) -> bool {
        self.album.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album(&mut self, v: ::std::string::String) {
        self.album = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album(&mut self) -> &mut ::std::string::String {
        if self.album.is_none() {
            self.album = ::std::option::Option::Some(::std::string::String::new());
        }
        self.album.as_mut().unwrap()
    }

    // Take field
    pub fn take_album(&mut self) -> ::std::string::String {
        self.album.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string genre = 4;

    pub fn genre(&self) -> &str {
        match self.genre.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_genre(&mut self) {
        self.genre = ::std::option::Option::None;
    }

    pub fn has_genre(&self) -> bool {
        self.genre.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genre(&mut self, v: ::std::string::String) {
        self.genre = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_genre(&mut self) -> &mut ::std::string::String {
        if self.genre.is_none() {
            self.genre = ::std::option::Option::Some(::std::string::String::new());
        }
        self.genre.as_mut().unwrap()
    }

    // Take field
    pub fn take_genre(&mut self) -> ::std::string::String {
        self.genre.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &HdRadioPsdData| { &m.title },
            |m: &mut HdRadioPsdData| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "artist",
            |m: &HdRadioPsdData| { &m.artist },
            |m: &mut HdRadioPsdData| { &mut m.artist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album",
            |m: &HdRadioPsdData| { &m.album },
            |m: &mut HdRadioPsdData| { &mut m.album },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "genre",
            |m: &HdRadioPsdData| { &m.genre },
            |m: &mut HdRadioPsdData| { &mut m.genre },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HdRadioComment>(
            "comment",
            |m: &HdRadioPsdData| { &m.comment },
            |m: &mut HdRadioPsdData| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HdRadioCommercial>(
            "commercial",
            |m: &HdRadioPsdData| { &m.commercial },
            |m: &mut HdRadioPsdData| { &mut m.commercial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HdRadioArtistExperience>(
            "artist_experience",
            |m: &HdRadioPsdData| { &m.artist_experience },
            |m: &mut HdRadioPsdData| { &mut m.artist_experience },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HdRadioPsdData>(
            "HdRadioPsdData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HdRadioPsdData {
    const NAME: &'static str = "HdRadioPsdData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.artist = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.album = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.genre = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.comment)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commercial)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.artist_experience)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.artist.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.album.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.genre.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.comment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.commercial.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.artist_experience.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.artist.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.album.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.genre.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.commercial.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.artist_experience.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HdRadioPsdData {
        HdRadioPsdData::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.artist = ::std::option::Option::None;
        self.album = ::std::option::Option::None;
        self.genre = ::std::option::Option::None;
        self.comment.clear();
        self.commercial.clear();
        self.artist_experience.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HdRadioPsdData {
        static instance: HdRadioPsdData = HdRadioPsdData {
            title: ::std::option::Option::None,
            artist: ::std::option::Option::None,
            album: ::std::option::Option::None,
            genre: ::std::option::Option::None,
            comment: ::protobuf::MessageField::none(),
            commercial: ::protobuf::MessageField::none(),
            artist_experience: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HdRadioPsdData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HdRadioPsdData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HdRadioPsdData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdRadioPsdData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HdRadioComment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HdRadioComment {
    // message fields
    // @@protoc_insertion_point(field:HdRadioComment.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioComment.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HdRadioComment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HdRadioComment {
    fn default() -> &'a HdRadioComment {
        <HdRadioComment as ::protobuf::Message>::default_instance()
    }
}

impl HdRadioComment {
    pub fn new() -> HdRadioComment {
        ::std::default::Default::default()
    }

    // optional string description = 1;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &HdRadioComment| { &m.description },
            |m: &mut HdRadioComment| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &HdRadioComment| { &m.text },
            |m: &mut HdRadioComment| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HdRadioComment>(
            "HdRadioComment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HdRadioComment {
    const NAME: &'static str = "HdRadioComment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HdRadioComment {
        HdRadioComment::new()
    }

    fn clear(&mut self) {
        self.description = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HdRadioComment {
        static instance: HdRadioComment = HdRadioComment {
            description: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HdRadioComment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HdRadioComment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HdRadioComment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdRadioComment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HdRadioCommercial)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HdRadioCommercial {
    // message fields
    // @@protoc_insertion_point(field:HdRadioCommercial.encoding)
    pub encoding: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:HdRadioCommercial.price)
    pub price: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioCommercial.valid)
    pub valid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioCommercial.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioCommercial.received)
    pub received: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:HdRadioCommercial.seller)
    pub seller: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioCommercial.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HdRadioCommercial.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HdRadioCommercial {
    fn default() -> &'a HdRadioCommercial {
        <HdRadioCommercial as ::protobuf::Message>::default_instance()
    }
}

impl HdRadioCommercial {
    pub fn new() -> HdRadioCommercial {
        ::std::default::Default::default()
    }

    // optional int32 encoding = 1;

    pub fn encoding(&self) -> i32 {
        self.encoding.unwrap_or(0)
    }

    pub fn clear_encoding(&mut self) {
        self.encoding = ::std::option::Option::None;
    }

    pub fn has_encoding(&self) -> bool {
        self.encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: i32) {
        self.encoding = ::std::option::Option::Some(v);
    }

    // optional string price = 2;

    pub fn price(&self) -> &str {
        match self.price.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_price(&mut self) {
        self.price = ::std::option::Option::None;
    }

    pub fn has_price(&self) -> bool {
        self.price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        if self.price.is_none() {
            self.price = ::std::option::Option::Some(::std::string::String::new());
        }
        self.price.as_mut().unwrap()
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        self.price.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string valid = 3;

    pub fn valid(&self) -> &str {
        match self.valid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_valid(&mut self) {
        self.valid = ::std::option::Option::None;
    }

    pub fn has_valid(&self) -> bool {
        self.valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: ::std::string::String) {
        self.valid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valid(&mut self) -> &mut ::std::string::String {
        if self.valid.is_none() {
            self.valid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.valid.as_mut().unwrap()
    }

    // Take field
    pub fn take_valid(&mut self) -> ::std::string::String {
        self.valid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 4;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 received = 5;

    pub fn received(&self) -> i32 {
        self.received.unwrap_or(0)
    }

    pub fn clear_received(&mut self) {
        self.received = ::std::option::Option::None;
    }

    pub fn has_received(&self) -> bool {
        self.received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_received(&mut self, v: i32) {
        self.received = ::std::option::Option::Some(v);
    }

    // optional string seller = 6;

    pub fn seller(&self) -> &str {
        match self.seller.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_seller(&mut self) {
        self.seller = ::std::option::Option::None;
    }

    pub fn has_seller(&self) -> bool {
        self.seller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seller(&mut self, v: ::std::string::String) {
        self.seller = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seller(&mut self) -> &mut ::std::string::String {
        if self.seller.is_none() {
            self.seller = ::std::option::Option::Some(::std::string::String::new());
        }
        self.seller.as_mut().unwrap()
    }

    // Take field
    pub fn take_seller(&mut self) -> ::std::string::String {
        self.seller.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 7;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encoding",
            |m: &HdRadioCommercial| { &m.encoding },
            |m: &mut HdRadioCommercial| { &mut m.encoding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price",
            |m: &HdRadioCommercial| { &m.price },
            |m: &mut HdRadioCommercial| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "valid",
            |m: &HdRadioCommercial| { &m.valid },
            |m: &mut HdRadioCommercial| { &mut m.valid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &HdRadioCommercial| { &m.url },
            |m: &mut HdRadioCommercial| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "received",
            |m: &HdRadioCommercial| { &m.received },
            |m: &mut HdRadioCommercial| { &mut m.received },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seller",
            |m: &HdRadioCommercial| { &m.seller },
            |m: &mut HdRadioCommercial| { &mut m.seller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &HdRadioCommercial| { &m.description },
            |m: &mut HdRadioCommercial| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HdRadioCommercial>(
            "HdRadioCommercial",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HdRadioCommercial {
    const NAME: &'static str = "HdRadioCommercial";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.encoding = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.price = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.valid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.received = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.seller = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encoding {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.price.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.valid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.received {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.seller.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encoding {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.price.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.valid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.received {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.seller.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HdRadioCommercial {
        HdRadioCommercial::new()
    }

    fn clear(&mut self) {
        self.encoding = ::std::option::Option::None;
        self.price = ::std::option::Option::None;
        self.valid = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.received = ::std::option::Option::None;
        self.seller = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HdRadioCommercial {
        static instance: HdRadioCommercial = HdRadioCommercial {
            encoding: ::std::option::Option::None,
            price: ::std::option::Option::None,
            valid: ::std::option::Option::None,
            url: ::std::option::Option::None,
            received: ::std::option::Option::None,
            seller: ::std::option::Option::None,
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HdRadioCommercial {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HdRadioCommercial").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HdRadioCommercial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdRadioCommercial {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HdRadioArtistExperience)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HdRadioArtistExperience {
    // message fields
    // @@protoc_insertion_point(field:HdRadioArtistExperience.image)
    pub image: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:HdRadioArtistExperience.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HdRadioArtistExperience {
    fn default() -> &'a HdRadioArtistExperience {
        <HdRadioArtistExperience as ::protobuf::Message>::default_instance()
    }
}

impl HdRadioArtistExperience {
    pub fn new() -> HdRadioArtistExperience {
        ::std::default::Default::default()
    }

    // optional bytes image = 1;

    pub fn image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &HdRadioArtistExperience| { &m.image },
            |m: &mut HdRadioArtistExperience| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HdRadioArtistExperience>(
            "HdRadioArtistExperience",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HdRadioArtistExperience {
    const NAME: &'static str = "HdRadioArtistExperience";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.image = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HdRadioArtistExperience {
        HdRadioArtistExperience::new()
    }

    fn clear(&mut self) {
        self.image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HdRadioArtistExperience {
        static instance: HdRadioArtistExperience = HdRadioArtistExperience {
            image: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HdRadioArtistExperience {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HdRadioArtistExperience").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HdRadioArtistExperience {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdRadioArtistExperience {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HdRadioSisData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HdRadioSisData {
    // message fields
    // @@protoc_insertion_point(field:HdRadioSisData.station_id)
    pub station_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:HdRadioSisData.station_name_short)
    pub station_name_short: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioSisData.station_name_long)
    pub station_name_long: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioSisData.station_location)
    pub station_location: ::protobuf::MessageField<Location>,
    // @@protoc_insertion_point(field:HdRadioSisData.station_message)
    pub station_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioSisData.service_info_message)
    pub service_info_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HdRadioSisData.universal_short_station_name_slogan)
    pub universal_short_station_name_slogan: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HdRadioSisData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HdRadioSisData {
    fn default() -> &'a HdRadioSisData {
        <HdRadioSisData as ::protobuf::Message>::default_instance()
    }
}

impl HdRadioSisData {
    pub fn new() -> HdRadioSisData {
        ::std::default::Default::default()
    }

    // optional int32 station_id = 1;

    pub fn station_id(&self) -> i32 {
        self.station_id.unwrap_or(0)
    }

    pub fn clear_station_id(&mut self) {
        self.station_id = ::std::option::Option::None;
    }

    pub fn has_station_id(&self) -> bool {
        self.station_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_id(&mut self, v: i32) {
        self.station_id = ::std::option::Option::Some(v);
    }

    // optional string station_name_short = 2;

    pub fn station_name_short(&self) -> &str {
        match self.station_name_short.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_station_name_short(&mut self) {
        self.station_name_short = ::std::option::Option::None;
    }

    pub fn has_station_name_short(&self) -> bool {
        self.station_name_short.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_name_short(&mut self, v: ::std::string::String) {
        self.station_name_short = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_name_short(&mut self) -> &mut ::std::string::String {
        if self.station_name_short.is_none() {
            self.station_name_short = ::std::option::Option::Some(::std::string::String::new());
        }
        self.station_name_short.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_name_short(&mut self) -> ::std::string::String {
        self.station_name_short.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string station_name_long = 3;

    pub fn station_name_long(&self) -> &str {
        match self.station_name_long.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_station_name_long(&mut self) {
        self.station_name_long = ::std::option::Option::None;
    }

    pub fn has_station_name_long(&self) -> bool {
        self.station_name_long.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_name_long(&mut self, v: ::std::string::String) {
        self.station_name_long = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_name_long(&mut self) -> &mut ::std::string::String {
        if self.station_name_long.is_none() {
            self.station_name_long = ::std::option::Option::Some(::std::string::String::new());
        }
        self.station_name_long.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_name_long(&mut self) -> ::std::string::String {
        self.station_name_long.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string station_message = 5;

    pub fn station_message(&self) -> &str {
        match self.station_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_station_message(&mut self) {
        self.station_message = ::std::option::Option::None;
    }

    pub fn has_station_message(&self) -> bool {
        self.station_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_station_message(&mut self, v: ::std::string::String) {
        self.station_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_station_message(&mut self) -> &mut ::std::string::String {
        if self.station_message.is_none() {
            self.station_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.station_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_station_message(&mut self) -> ::std::string::String {
        self.station_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string service_info_message = 6;

    pub fn service_info_message(&self) -> &str {
        match self.service_info_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_service_info_message(&mut self) {
        self.service_info_message = ::std::option::Option::None;
    }

    pub fn has_service_info_message(&self) -> bool {
        self.service_info_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_info_message(&mut self, v: ::std::string::String) {
        self.service_info_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_info_message(&mut self) -> &mut ::std::string::String {
        if self.service_info_message.is_none() {
            self.service_info_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.service_info_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_info_message(&mut self) -> ::std::string::String {
        self.service_info_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string universal_short_station_name_slogan = 7;

    pub fn universal_short_station_name_slogan(&self) -> &str {
        match self.universal_short_station_name_slogan.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_universal_short_station_name_slogan(&mut self) {
        self.universal_short_station_name_slogan = ::std::option::Option::None;
    }

    pub fn has_universal_short_station_name_slogan(&self) -> bool {
        self.universal_short_station_name_slogan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_universal_short_station_name_slogan(&mut self, v: ::std::string::String) {
        self.universal_short_station_name_slogan = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_universal_short_station_name_slogan(&mut self) -> &mut ::std::string::String {
        if self.universal_short_station_name_slogan.is_none() {
            self.universal_short_station_name_slogan = ::std::option::Option::Some(::std::string::String::new());
        }
        self.universal_short_station_name_slogan.as_mut().unwrap()
    }

    // Take field
    pub fn take_universal_short_station_name_slogan(&mut self) -> ::std::string::String {
        self.universal_short_station_name_slogan.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_id",
            |m: &HdRadioSisData| { &m.station_id },
            |m: &mut HdRadioSisData| { &mut m.station_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_name_short",
            |m: &HdRadioSisData| { &m.station_name_short },
            |m: &mut HdRadioSisData| { &mut m.station_name_short },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_name_long",
            |m: &HdRadioSisData| { &m.station_name_long },
            |m: &mut HdRadioSisData| { &mut m.station_name_long },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Location>(
            "station_location",
            |m: &HdRadioSisData| { &m.station_location },
            |m: &mut HdRadioSisData| { &mut m.station_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "station_message",
            |m: &HdRadioSisData| { &m.station_message },
            |m: &mut HdRadioSisData| { &mut m.station_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service_info_message",
            |m: &HdRadioSisData| { &m.service_info_message },
            |m: &mut HdRadioSisData| { &mut m.service_info_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "universal_short_station_name_slogan",
            |m: &HdRadioSisData| { &m.universal_short_station_name_slogan },
            |m: &mut HdRadioSisData| { &mut m.universal_short_station_name_slogan },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HdRadioSisData>(
            "HdRadioSisData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HdRadioSisData {
    const NAME: &'static str = "HdRadioSisData";

    fn is_initialized(&self) -> bool {
        for v in &self.station_location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.station_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.station_name_short = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.station_name_long = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.station_location)?;
                },
                42 => {
                    self.station_message = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.service_info_message = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.universal_short_station_name_slogan = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.station_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.station_name_short.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.station_name_long.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.station_location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.station_message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.service_info_message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.universal_short_station_name_slogan.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.station_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.station_name_short.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.station_name_long.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.station_location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.station_message.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.service_info_message.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.universal_short_station_name_slogan.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HdRadioSisData {
        HdRadioSisData::new()
    }

    fn clear(&mut self) {
        self.station_id = ::std::option::Option::None;
        self.station_name_short = ::std::option::Option::None;
        self.station_name_long = ::std::option::Option::None;
        self.station_location.clear();
        self.station_message = ::std::option::Option::None;
        self.service_info_message = ::std::option::Option::None;
        self.universal_short_station_name_slogan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HdRadioSisData {
        static instance: HdRadioSisData = HdRadioSisData {
            station_id: ::std::option::Option::None,
            station_name_short: ::std::option::Option::None,
            station_name_long: ::std::option::Option::None,
            station_location: ::protobuf::MessageField::none(),
            station_message: ::std::option::Option::None,
            service_info_message: ::std::option::Option::None,
            universal_short_station_name_slogan: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HdRadioSisData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HdRadioSisData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HdRadioSisData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdRadioSisData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Location)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Location {
    // message fields
    // @@protoc_insertion_point(field:Location.longitude)
    pub longitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:Location.latitude)
    pub latitude: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:Location.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // required double longitude = 1;

    pub fn longitude(&self) -> f64 {
        self.longitude.unwrap_or(0.)
    }

    pub fn clear_longitude(&mut self) {
        self.longitude = ::std::option::Option::None;
    }

    pub fn has_longitude(&self) -> bool {
        self.longitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f64) {
        self.longitude = ::std::option::Option::Some(v);
    }

    // required double latitude = 2;

    pub fn latitude(&self) -> f64 {
        self.latitude.unwrap_or(0.)
    }

    pub fn clear_latitude(&mut self) {
        self.latitude = ::std::option::Option::None;
    }

    pub fn has_latitude(&self) -> bool {
        self.latitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f64) {
        self.latitude = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "longitude",
            |m: &Location| { &m.longitude },
            |m: &mut Location| { &mut m.longitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "latitude",
            |m: &Location| { &m.latitude },
            |m: &mut Location| { &mut m.latitude },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
            "Location",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Location {
    const NAME: &'static str = "Location";

    fn is_initialized(&self) -> bool {
        if self.longitude.is_none() {
            return false;
        }
        if self.latitude.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.longitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.latitude = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.longitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.latitude {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.longitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.latitude {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Location {
        Location::new()
    }

    fn clear(&mut self) {
        self.longitude = ::std::option::Option::None;
        self.latitude = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Location {
        static instance: Location = Location {
            longitude: ::std::option::Option::None,
            latitude: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Location {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Location").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetProgramListRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetProgramListRequest {
    // message fields
    // @@protoc_insertion_point(field:GetProgramListRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GetProgramListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetProgramListRequest {
    fn default() -> &'a GetProgramListRequest {
        <GetProgramListRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProgramListRequest {
    pub fn new() -> GetProgramListRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &GetProgramListRequest| { &m.radio_id },
            |m: &mut GetProgramListRequest| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProgramListRequest>(
            "GetProgramListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetProgramListRequest {
    const NAME: &'static str = "GetProgramListRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetProgramListRequest {
        GetProgramListRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetProgramListRequest {
        static instance: GetProgramListRequest = GetProgramListRequest {
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetProgramListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetProgramListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetProgramListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProgramListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetProgramListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetProgramListResponse {
    // message fields
    // @@protoc_insertion_point(field:GetProgramListResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:GetProgramListResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GetProgramListResponse.completed)
    pub completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetProgramListResponse.program_list)
    pub program_list: ::std::vec::Vec<RadioStationInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:GetProgramListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetProgramListResponse {
    fn default() -> &'a GetProgramListResponse {
        <GetProgramListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetProgramListResponse {
    pub fn new() -> GetProgramListResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required bool completed = 3;

    pub fn completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GetProgramListResponse| { &m.status },
            |m: &mut GetProgramListResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &GetProgramListResponse| { &m.radio_id },
            |m: &mut GetProgramListResponse| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "completed",
            |m: &GetProgramListResponse| { &m.completed },
            |m: &mut GetProgramListResponse| { &mut m.completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "program_list",
            |m: &GetProgramListResponse| { &m.program_list },
            |m: &mut GetProgramListResponse| { &mut m.program_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProgramListResponse>(
            "GetProgramListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetProgramListResponse {
    const NAME: &'static str = "GetProgramListResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.radio_id.is_none() {
            return false;
        }
        if self.completed.is_none() {
            return false;
        }
        for v in &self.program_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.completed = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.program_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.completed {
            my_size += 1 + 1;
        }
        for value in &self.program_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(3, v)?;
        }
        for v in &self.program_list {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetProgramListResponse {
        GetProgramListResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.completed = ::std::option::Option::None;
        self.program_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetProgramListResponse {
        static instance: GetProgramListResponse = GetProgramListResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            completed: ::std::option::Option::None,
            program_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetProgramListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetProgramListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetProgramListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProgramListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CancelRadioOperationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelRadioOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:CancelRadioOperationsRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CancelRadioOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelRadioOperationsRequest {
    fn default() -> &'a CancelRadioOperationsRequest {
        <CancelRadioOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelRadioOperationsRequest {
    pub fn new() -> CancelRadioOperationsRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &CancelRadioOperationsRequest| { &m.radio_id },
            |m: &mut CancelRadioOperationsRequest| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelRadioOperationsRequest>(
            "CancelRadioOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelRadioOperationsRequest {
    const NAME: &'static str = "CancelRadioOperationsRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelRadioOperationsRequest {
        CancelRadioOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelRadioOperationsRequest {
        static instance: CancelRadioOperationsRequest = CancelRadioOperationsRequest {
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelRadioOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelRadioOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelRadioOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelRadioOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CancelRadioOperationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelRadioOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:CancelRadioOperationsResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:CancelRadioOperationsResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CancelRadioOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelRadioOperationsResponse {
    fn default() -> &'a CancelRadioOperationsResponse {
        <CancelRadioOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CancelRadioOperationsResponse {
    pub fn new() -> CancelRadioOperationsResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CancelRadioOperationsResponse| { &m.status },
            |m: &mut CancelRadioOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &CancelRadioOperationsResponse| { &m.radio_id },
            |m: &mut CancelRadioOperationsResponse| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelRadioOperationsResponse>(
            "CancelRadioOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelRadioOperationsResponse {
    const NAME: &'static str = "CancelRadioOperationsResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelRadioOperationsResponse {
        CancelRadioOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelRadioOperationsResponse {
        static instance: CancelRadioOperationsResponse = CancelRadioOperationsResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelRadioOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelRadioOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelRadioOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelRadioOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ConfigureChannelSpacingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigureChannelSpacingRequest {
    // message fields
    // @@protoc_insertion_point(field:ConfigureChannelSpacingRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ConfigureChannelSpacingRequest.channel_spacing)
    pub channel_spacing: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ConfigureChannelSpacingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigureChannelSpacingRequest {
    fn default() -> &'a ConfigureChannelSpacingRequest {
        <ConfigureChannelSpacingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureChannelSpacingRequest {
    pub fn new() -> ConfigureChannelSpacingRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required int32 channel_spacing = 2;

    pub fn channel_spacing(&self) -> i32 {
        self.channel_spacing.unwrap_or(0)
    }

    pub fn clear_channel_spacing(&mut self) {
        self.channel_spacing = ::std::option::Option::None;
    }

    pub fn has_channel_spacing(&self) -> bool {
        self.channel_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_spacing(&mut self, v: i32) {
        self.channel_spacing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &ConfigureChannelSpacingRequest| { &m.radio_id },
            |m: &mut ConfigureChannelSpacingRequest| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_spacing",
            |m: &ConfigureChannelSpacingRequest| { &m.channel_spacing },
            |m: &mut ConfigureChannelSpacingRequest| { &mut m.channel_spacing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigureChannelSpacingRequest>(
            "ConfigureChannelSpacingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigureChannelSpacingRequest {
    const NAME: &'static str = "ConfigureChannelSpacingRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        if self.channel_spacing.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_spacing {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_spacing {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigureChannelSpacingRequest {
        ConfigureChannelSpacingRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.channel_spacing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigureChannelSpacingRequest {
        static instance: ConfigureChannelSpacingRequest = ConfigureChannelSpacingRequest {
            radio_id: ::std::option::Option::None,
            channel_spacing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigureChannelSpacingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigureChannelSpacingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigureChannelSpacingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureChannelSpacingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ConfigureChannelSpacingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigureChannelSpacingResponse {
    // message fields
    // @@protoc_insertion_point(field:ConfigureChannelSpacingResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:ConfigureChannelSpacingResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ConfigureChannelSpacingResponse.channel_spacing)
    pub channel_spacing: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ConfigureChannelSpacingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigureChannelSpacingResponse {
    fn default() -> &'a ConfigureChannelSpacingResponse {
        <ConfigureChannelSpacingResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureChannelSpacingResponse {
    pub fn new() -> ConfigureChannelSpacingResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required int32 channel_spacing = 3;

    pub fn channel_spacing(&self) -> i32 {
        self.channel_spacing.unwrap_or(0)
    }

    pub fn clear_channel_spacing(&mut self) {
        self.channel_spacing = ::std::option::Option::None;
    }

    pub fn has_channel_spacing(&self) -> bool {
        self.channel_spacing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_spacing(&mut self, v: i32) {
        self.channel_spacing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ConfigureChannelSpacingResponse| { &m.status },
            |m: &mut ConfigureChannelSpacingResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &ConfigureChannelSpacingResponse| { &m.radio_id },
            |m: &mut ConfigureChannelSpacingResponse| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_spacing",
            |m: &ConfigureChannelSpacingResponse| { &m.channel_spacing },
            |m: &mut ConfigureChannelSpacingResponse| { &mut m.channel_spacing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigureChannelSpacingResponse>(
            "ConfigureChannelSpacingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigureChannelSpacingResponse {
    const NAME: &'static str = "ConfigureChannelSpacingResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.radio_id.is_none() {
            return false;
        }
        if self.channel_spacing.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.channel_spacing = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.channel_spacing {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.channel_spacing {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigureChannelSpacingResponse {
        ConfigureChannelSpacingResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.channel_spacing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigureChannelSpacingResponse {
        static instance: ConfigureChannelSpacingResponse = ConfigureChannelSpacingResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            channel_spacing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigureChannelSpacingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigureChannelSpacingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigureChannelSpacingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureChannelSpacingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StationPresetsNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StationPresetsNotification {
    // message fields
    // @@protoc_insertion_point(field:StationPresetsNotification.preset_lists)
    pub preset_lists: ::std::vec::Vec<StationPresetList>,
    // special fields
    // @@protoc_insertion_point(special_field:StationPresetsNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationPresetsNotification {
    fn default() -> &'a StationPresetsNotification {
        <StationPresetsNotification as ::protobuf::Message>::default_instance()
    }
}

impl StationPresetsNotification {
    pub fn new() -> StationPresetsNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preset_lists",
            |m: &StationPresetsNotification| { &m.preset_lists },
            |m: &mut StationPresetsNotification| { &mut m.preset_lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationPresetsNotification>(
            "StationPresetsNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationPresetsNotification {
    const NAME: &'static str = "StationPresetsNotification";

    fn is_initialized(&self) -> bool {
        for v in &self.preset_lists {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.preset_lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.preset_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.preset_lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationPresetsNotification {
        StationPresetsNotification::new()
    }

    fn clear(&mut self) {
        self.preset_lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationPresetsNotification {
        static instance: StationPresetsNotification = StationPresetsNotification {
            preset_lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationPresetsNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationPresetsNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationPresetsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationPresetsNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StationPresetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StationPresetList {
    // message fields
    // @@protoc_insertion_point(field:StationPresetList.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StationPresetList.restricted_station_types)
    pub restricted_station_types: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:StationPresetList.presets)
    pub presets: ::std::vec::Vec<StationPreset>,
    // special fields
    // @@protoc_insertion_point(special_field:StationPresetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationPresetList {
    fn default() -> &'a StationPresetList {
        <StationPresetList as ::protobuf::Message>::default_instance()
    }
}

impl StationPresetList {
    pub fn new() -> StationPresetList {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &StationPresetList| { &m.name },
            |m: &mut StationPresetList| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restricted_station_types",
            |m: &StationPresetList| { &m.restricted_station_types },
            |m: &mut StationPresetList| { &mut m.restricted_station_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "presets",
            |m: &StationPresetList| { &m.presets },
            |m: &mut StationPresetList| { &mut m.presets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationPresetList>(
            "StationPresetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationPresetList {
    const NAME: &'static str = "StationPresetList";

    fn is_initialized(&self) -> bool {
        for v in &self.presets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.restricted_station_types)?;
                },
                16 => {
                    self.restricted_station_types.push(is.read_int32()?);
                },
                26 => {
                    self.presets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.restricted_station_types {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        for value in &self.presets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.restricted_station_types {
            os.write_int32(2, *v)?;
        };
        for v in &self.presets {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationPresetList {
        StationPresetList::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.restricted_station_types.clear();
        self.presets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationPresetList {
        static instance: StationPresetList = StationPresetList {
            name: ::std::option::Option::None,
            restricted_station_types: ::std::vec::Vec::new(),
            presets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationPresetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationPresetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationPresetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationPresetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StationPreset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StationPreset {
    // message fields
    // @@protoc_insertion_point(field:StationPreset.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<RadioType>>,
    // @@protoc_insertion_point(field:StationPreset.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StationPreset.sub_channel)
    pub sub_channel: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:StationPreset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StationPreset {
    fn default() -> &'a StationPreset {
        <StationPreset as ::protobuf::Message>::default_instance()
    }
}

impl StationPreset {
    pub fn new() -> StationPreset {
        ::std::default::Default::default()
    }

    // required .RadioType type = 1;

    pub fn type_(&self) -> RadioType {
        match self.type_ {
            Some(e) => e.enum_value_or(RadioType::AM_RADIO),
            None => RadioType::AM_RADIO,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: RadioType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 channel = 2;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional int32 sub_channel = 3;

    pub fn sub_channel(&self) -> i32 {
        self.sub_channel.unwrap_or(0)
    }

    pub fn clear_sub_channel(&mut self) {
        self.sub_channel = ::std::option::Option::None;
    }

    pub fn has_sub_channel(&self) -> bool {
        self.sub_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_channel(&mut self, v: i32) {
        self.sub_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StationPreset| { &m.type_ },
            |m: &mut StationPreset| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &StationPreset| { &m.channel },
            |m: &mut StationPreset| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sub_channel",
            |m: &StationPreset| { &m.sub_channel },
            |m: &mut StationPreset| { &mut m.sub_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StationPreset>(
            "StationPreset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StationPreset {
    const NAME: &'static str = "StationPreset";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.sub_channel = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.sub_channel {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.channel {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.sub_channel {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StationPreset {
        StationPreset::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.sub_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StationPreset {
        static instance: StationPreset = StationPreset {
            type_: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            sub_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StationPreset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StationPreset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StationPreset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StationPreset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetTrafficUpdateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTrafficUpdateRequest {
    // message fields
    // @@protoc_insertion_point(field:GetTrafficUpdateRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GetTrafficUpdateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTrafficUpdateRequest {
    fn default() -> &'a GetTrafficUpdateRequest {
        <GetTrafficUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTrafficUpdateRequest {
    pub fn new() -> GetTrafficUpdateRequest {
        ::std::default::Default::default()
    }

    // required int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &GetTrafficUpdateRequest| { &m.radio_id },
            |m: &mut GetTrafficUpdateRequest| { &mut m.radio_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTrafficUpdateRequest>(
            "GetTrafficUpdateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTrafficUpdateRequest {
    const NAME: &'static str = "GetTrafficUpdateRequest";

    fn is_initialized(&self) -> bool {
        if self.radio_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTrafficUpdateRequest {
        GetTrafficUpdateRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTrafficUpdateRequest {
        static instance: GetTrafficUpdateRequest = GetTrafficUpdateRequest {
            radio_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTrafficUpdateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTrafficUpdateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTrafficUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTrafficUpdateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetTrafficUpdateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTrafficUpdateResponse {
    // message fields
    // @@protoc_insertion_point(field:GetTrafficUpdateResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:GetTrafficUpdateResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GetTrafficUpdateResponse.incidents)
    pub incidents: ::std::vec::Vec<TrafficIncident>,
    // special fields
    // @@protoc_insertion_point(special_field:GetTrafficUpdateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTrafficUpdateResponse {
    fn default() -> &'a GetTrafficUpdateResponse {
        <GetTrafficUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTrafficUpdateResponse {
    pub fn new() -> GetTrafficUpdateResponse {
        ::std::default::Default::default()
    }

    // required .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GetTrafficUpdateResponse| { &m.status },
            |m: &mut GetTrafficUpdateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &GetTrafficUpdateResponse| { &m.radio_id },
            |m: &mut GetTrafficUpdateResponse| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "incidents",
            |m: &GetTrafficUpdateResponse| { &m.incidents },
            |m: &mut GetTrafficUpdateResponse| { &mut m.incidents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTrafficUpdateResponse>(
            "GetTrafficUpdateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTrafficUpdateResponse {
    const NAME: &'static str = "GetTrafficUpdateResponse";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.radio_id.is_none() {
            return false;
        }
        for v in &self.incidents {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.incidents.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.incidents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        for v in &self.incidents {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTrafficUpdateResponse {
        GetTrafficUpdateResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.incidents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTrafficUpdateResponse {
        static instance: GetTrafficUpdateResponse = GetTrafficUpdateResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            incidents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTrafficUpdateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTrafficUpdateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTrafficUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTrafficUpdateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrafficIncident)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrafficIncident {
    // message fields
    // @@protoc_insertion_point(field:TrafficIncident.event_code)
    pub event_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TrafficIncident.location)
    pub location: ::protobuf::MessageField<Location>,
    // @@protoc_insertion_point(field:TrafficIncident.expected_incident_duration)
    pub expected_incident_duration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:TrafficIncident.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrafficIncident {
    fn default() -> &'a TrafficIncident {
        <TrafficIncident as ::protobuf::Message>::default_instance()
    }
}

impl TrafficIncident {
    pub fn new() -> TrafficIncident {
        ::std::default::Default::default()
    }

    // required int32 event_code = 1;

    pub fn event_code(&self) -> i32 {
        self.event_code.unwrap_or(0)
    }

    pub fn clear_event_code(&mut self) {
        self.event_code = ::std::option::Option::None;
    }

    pub fn has_event_code(&self) -> bool {
        self.event_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_code(&mut self, v: i32) {
        self.event_code = ::std::option::Option::Some(v);
    }

    // required int32 expected_incident_duration = 3;

    pub fn expected_incident_duration(&self) -> i32 {
        self.expected_incident_duration.unwrap_or(0)
    }

    pub fn clear_expected_incident_duration(&mut self) {
        self.expected_incident_duration = ::std::option::Option::None;
    }

    pub fn has_expected_incident_duration(&self) -> bool {
        self.expected_incident_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_incident_duration(&mut self, v: i32) {
        self.expected_incident_duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_code",
            |m: &TrafficIncident| { &m.event_code },
            |m: &mut TrafficIncident| { &mut m.event_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Location>(
            "location",
            |m: &TrafficIncident| { &m.location },
            |m: &mut TrafficIncident| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expected_incident_duration",
            |m: &TrafficIncident| { &m.expected_incident_duration },
            |m: &mut TrafficIncident| { &mut m.expected_incident_duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrafficIncident>(
            "TrafficIncident",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrafficIncident {
    const NAME: &'static str = "TrafficIncident";

    fn is_initialized(&self) -> bool {
        if self.event_code.is_none() {
            return false;
        }
        if self.location.is_none() {
            return false;
        }
        if self.expected_incident_duration.is_none() {
            return false;
        }
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_code = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                24 => {
                    self.expected_incident_duration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_code {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expected_incident_duration {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_code {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.expected_incident_duration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrafficIncident {
        TrafficIncident::new()
    }

    fn clear(&mut self) {
        self.event_code = ::std::option::Option::None;
        self.location.clear();
        self.expected_incident_duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrafficIncident {
        static instance: TrafficIncident = TrafficIncident {
            event_code: ::std::option::Option::None,
            location: ::protobuf::MessageField::none(),
            expected_incident_duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrafficIncident {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrafficIncident").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrafficIncident {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficIncident {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MuteRadioRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MuteRadioRequest {
    // message fields
    // @@protoc_insertion_point(field:MuteRadioRequest.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MuteRadioRequest.mute)
    pub mute: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MuteRadioRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MuteRadioRequest {
    fn default() -> &'a MuteRadioRequest {
        <MuteRadioRequest as ::protobuf::Message>::default_instance()
    }
}

impl MuteRadioRequest {
    pub fn new() -> MuteRadioRequest {
        ::std::default::Default::default()
    }

    // optional int32 radio_id = 1;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // required bool mute = 2;

    pub fn mute(&self) -> bool {
        self.mute.unwrap_or(false)
    }

    pub fn clear_mute(&mut self) {
        self.mute = ::std::option::Option::None;
    }

    pub fn has_mute(&self) -> bool {
        self.mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mute(&mut self, v: bool) {
        self.mute = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &MuteRadioRequest| { &m.radio_id },
            |m: &mut MuteRadioRequest| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mute",
            |m: &MuteRadioRequest| { &m.mute },
            |m: &mut MuteRadioRequest| { &mut m.mute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MuteRadioRequest>(
            "MuteRadioRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MuteRadioRequest {
    const NAME: &'static str = "MuteRadioRequest";

    fn is_initialized(&self) -> bool {
        if self.mute.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mute = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mute {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mute {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MuteRadioRequest {
        MuteRadioRequest::new()
    }

    fn clear(&mut self) {
        self.radio_id = ::std::option::Option::None;
        self.mute = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MuteRadioRequest {
        static instance: MuteRadioRequest = MuteRadioRequest {
            radio_id: ::std::option::Option::None,
            mute: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MuteRadioRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MuteRadioRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MuteRadioRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MuteRadioRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MuteRadioResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MuteRadioResponse {
    // message fields
    // @@protoc_insertion_point(field:MuteRadioResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<MessageStatus>>,
    // @@protoc_insertion_point(field:MuteRadioResponse.radio_id)
    pub radio_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MuteRadioResponse.muted)
    pub muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MuteRadioResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MuteRadioResponse {
    fn default() -> &'a MuteRadioResponse {
        <MuteRadioResponse as ::protobuf::Message>::default_instance()
    }
}

impl MuteRadioResponse {
    pub fn new() -> MuteRadioResponse {
        ::std::default::Default::default()
    }

    // optional .MessageStatus status = 1;

    pub fn status(&self) -> MessageStatus {
        match self.status {
            Some(e) => e.enum_value_or(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            None => MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 radio_id = 2;

    pub fn radio_id(&self) -> i32 {
        self.radio_id.unwrap_or(0)
    }

    pub fn clear_radio_id(&mut self) {
        self.radio_id = ::std::option::Option::None;
    }

    pub fn has_radio_id(&self) -> bool {
        self.radio_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_id(&mut self, v: i32) {
        self.radio_id = ::std::option::Option::Some(v);
    }

    // optional bool muted = 3;

    pub fn muted(&self) -> bool {
        self.muted.unwrap_or(false)
    }

    pub fn clear_muted(&mut self) {
        self.muted = ::std::option::Option::None;
    }

    pub fn has_muted(&self) -> bool {
        self.muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muted(&mut self, v: bool) {
        self.muted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &MuteRadioResponse| { &m.status },
            |m: &mut MuteRadioResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_id",
            |m: &MuteRadioResponse| { &m.radio_id },
            |m: &mut MuteRadioResponse| { &mut m.radio_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muted",
            |m: &MuteRadioResponse| { &m.muted },
            |m: &mut MuteRadioResponse| { &mut m.muted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MuteRadioResponse>(
            "MuteRadioResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MuteRadioResponse {
    const NAME: &'static str = "MuteRadioResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.radio_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.radio_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.muted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radio_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.muted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MuteRadioResponse {
        MuteRadioResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.radio_id = ::std::option::Option::None;
        self.muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MuteRadioResponse {
        static instance: MuteRadioResponse = MuteRadioResponse {
            status: ::std::option::Option::None,
            radio_id: ::std::option::Option::None,
            muted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MuteRadioResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MuteRadioResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MuteRadioResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MuteRadioResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationStatusStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationStatusStart {
    // special fields
    // @@protoc_insertion_point(special_field:NavigationStatusStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationStatusStart {
    fn default() -> &'a NavigationStatusStart {
        <NavigationStatusStart as ::protobuf::Message>::default_instance()
    }
}

impl NavigationStatusStart {
    pub fn new() -> NavigationStatusStart {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationStatusStart>(
            "NavigationStatusStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationStatusStart {
    const NAME: &'static str = "NavigationStatusStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationStatusStart {
        NavigationStatusStart::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationStatusStart {
        static instance: NavigationStatusStart = NavigationStatusStart {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationStatusStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationStatusStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationStatusStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationStatusStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationStatusStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationStatusStop {
    // special fields
    // @@protoc_insertion_point(special_field:NavigationStatusStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationStatusStop {
    fn default() -> &'a NavigationStatusStop {
        <NavigationStatusStop as ::protobuf::Message>::default_instance()
    }
}

impl NavigationStatusStop {
    pub fn new() -> NavigationStatusStop {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationStatusStop>(
            "NavigationStatusStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationStatusStop {
    const NAME: &'static str = "NavigationStatusStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationStatusStop {
        NavigationStatusStop::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationStatusStop {
        static instance: NavigationStatusStop = NavigationStatusStop {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationStatusStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationStatusStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationStatusStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationStatusStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationStatus {
    // message fields
    // @@protoc_insertion_point(field:NavigationStatus.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_status::NavigationStatusEnum>>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationStatus {
    fn default() -> &'a NavigationStatus {
        <NavigationStatus as ::protobuf::Message>::default_instance()
    }
}

impl NavigationStatus {
    pub fn new() -> NavigationStatus {
        ::std::default::Default::default()
    }

    // required .NavigationStatus.NavigationStatusEnum status = 1;

    pub fn status(&self) -> navigation_status::NavigationStatusEnum {
        match self.status {
            Some(e) => e.enum_value_or(navigation_status::NavigationStatusEnum::UNAVAILABLE),
            None => navigation_status::NavigationStatusEnum::UNAVAILABLE,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: navigation_status::NavigationStatusEnum) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &NavigationStatus| { &m.status },
            |m: &mut NavigationStatus| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationStatus>(
            "NavigationStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationStatus {
    const NAME: &'static str = "NavigationStatus";

    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationStatus {
        NavigationStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationStatus {
        static instance: NavigationStatus = NavigationStatus {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationStatus`
pub mod navigation_status {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationStatus.NavigationStatusEnum)
    pub enum NavigationStatusEnum {
        // @@protoc_insertion_point(enum_value:NavigationStatus.NavigationStatusEnum.UNAVAILABLE)
        UNAVAILABLE = 0,
        // @@protoc_insertion_point(enum_value:NavigationStatus.NavigationStatusEnum.ACTIVE)
        ACTIVE = 1,
        // @@protoc_insertion_point(enum_value:NavigationStatus.NavigationStatusEnum.INACTIVE)
        INACTIVE = 2,
        // @@protoc_insertion_point(enum_value:NavigationStatus.NavigationStatusEnum.REROUTING)
        REROUTING = 3,
    }

    impl ::protobuf::Enum for NavigationStatusEnum {
        const NAME: &'static str = "NavigationStatusEnum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NavigationStatusEnum> {
            match value {
                0 => ::std::option::Option::Some(NavigationStatusEnum::UNAVAILABLE),
                1 => ::std::option::Option::Some(NavigationStatusEnum::ACTIVE),
                2 => ::std::option::Option::Some(NavigationStatusEnum::INACTIVE),
                3 => ::std::option::Option::Some(NavigationStatusEnum::REROUTING),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<NavigationStatusEnum> {
            match str {
                "UNAVAILABLE" => ::std::option::Option::Some(NavigationStatusEnum::UNAVAILABLE),
                "ACTIVE" => ::std::option::Option::Some(NavigationStatusEnum::ACTIVE),
                "INACTIVE" => ::std::option::Option::Some(NavigationStatusEnum::INACTIVE),
                "REROUTING" => ::std::option::Option::Some(NavigationStatusEnum::REROUTING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NavigationStatusEnum] = &[
            NavigationStatusEnum::UNAVAILABLE,
            NavigationStatusEnum::ACTIVE,
            NavigationStatusEnum::INACTIVE,
            NavigationStatusEnum::REROUTING,
        ];
    }

    impl ::protobuf::EnumFull for NavigationStatusEnum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationStatus.NavigationStatusEnum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NavigationStatusEnum {
        fn default() -> Self {
            NavigationStatusEnum::UNAVAILABLE
        }
    }

    impl NavigationStatusEnum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NavigationStatusEnum>("NavigationStatus.NavigationStatusEnum")
        }
    }
}

// @@protoc_insertion_point(message:NavigationNextTurnEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationNextTurnEvent {
    // message fields
    // @@protoc_insertion_point(field:NavigationNextTurnEvent.road)
    pub road: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NavigationNextTurnEvent.turn_side)
    pub turn_side: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_next_turn_event::TurnSide>>,
    // @@protoc_insertion_point(field:NavigationNextTurnEvent.event)
    pub event: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_next_turn_event::NextTurnEnum>>,
    // @@protoc_insertion_point(field:NavigationNextTurnEvent.image)
    pub image: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:NavigationNextTurnEvent.turn_number)
    pub turn_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationNextTurnEvent.turn_angle)
    pub turn_angle: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationNextTurnEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationNextTurnEvent {
    fn default() -> &'a NavigationNextTurnEvent {
        <NavigationNextTurnEvent as ::protobuf::Message>::default_instance()
    }
}

impl NavigationNextTurnEvent {
    pub fn new() -> NavigationNextTurnEvent {
        ::std::default::Default::default()
    }

    // required string road = 1;

    pub fn road(&self) -> &str {
        match self.road.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_road(&mut self) {
        self.road = ::std::option::Option::None;
    }

    pub fn has_road(&self) -> bool {
        self.road.is_some()
    }

    // Param is passed by value, moved
    pub fn set_road(&mut self, v: ::std::string::String) {
        self.road = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_road(&mut self) -> &mut ::std::string::String {
        if self.road.is_none() {
            self.road = ::std::option::Option::Some(::std::string::String::new());
        }
        self.road.as_mut().unwrap()
    }

    // Take field
    pub fn take_road(&mut self) -> ::std::string::String {
        self.road.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .NavigationNextTurnEvent.TurnSide turn_side = 2;

    pub fn turn_side(&self) -> navigation_next_turn_event::TurnSide {
        match self.turn_side {
            Some(e) => e.enum_value_or(navigation_next_turn_event::TurnSide::LEFT),
            None => navigation_next_turn_event::TurnSide::LEFT,
        }
    }

    pub fn clear_turn_side(&mut self) {
        self.turn_side = ::std::option::Option::None;
    }

    pub fn has_turn_side(&self) -> bool {
        self.turn_side.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_side(&mut self, v: navigation_next_turn_event::TurnSide) {
        self.turn_side = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .NavigationNextTurnEvent.NextTurnEnum event = 3;

    pub fn event(&self) -> navigation_next_turn_event::NextTurnEnum {
        match self.event {
            Some(e) => e.enum_value_or(navigation_next_turn_event::NextTurnEnum::UNKNOWN),
            None => navigation_next_turn_event::NextTurnEnum::UNKNOWN,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: navigation_next_turn_event::NextTurnEnum) {
        self.event = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes image = 4;

    pub fn image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 turn_number = 5;

    pub fn turn_number(&self) -> i32 {
        self.turn_number.unwrap_or(0)
    }

    pub fn clear_turn_number(&mut self) {
        self.turn_number = ::std::option::Option::None;
    }

    pub fn has_turn_number(&self) -> bool {
        self.turn_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_number(&mut self, v: i32) {
        self.turn_number = ::std::option::Option::Some(v);
    }

    // optional int32 turn_angle = 6;

    pub fn turn_angle(&self) -> i32 {
        self.turn_angle.unwrap_or(0)
    }

    pub fn clear_turn_angle(&mut self) {
        self.turn_angle = ::std::option::Option::None;
    }

    pub fn has_turn_angle(&self) -> bool {
        self.turn_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_angle(&mut self, v: i32) {
        self.turn_angle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "road",
            |m: &NavigationNextTurnEvent| { &m.road },
            |m: &mut NavigationNextTurnEvent| { &mut m.road },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turn_side",
            |m: &NavigationNextTurnEvent| { &m.turn_side },
            |m: &mut NavigationNextTurnEvent| { &mut m.turn_side },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event",
            |m: &NavigationNextTurnEvent| { &m.event },
            |m: &mut NavigationNextTurnEvent| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &NavigationNextTurnEvent| { &m.image },
            |m: &mut NavigationNextTurnEvent| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turn_number",
            |m: &NavigationNextTurnEvent| { &m.turn_number },
            |m: &mut NavigationNextTurnEvent| { &mut m.turn_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "turn_angle",
            |m: &NavigationNextTurnEvent| { &m.turn_angle },
            |m: &mut NavigationNextTurnEvent| { &mut m.turn_angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationNextTurnEvent>(
            "NavigationNextTurnEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationNextTurnEvent {
    const NAME: &'static str = "NavigationNextTurnEvent";

    fn is_initialized(&self) -> bool {
        if self.road.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.road = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.turn_side = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.image = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.turn_number = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.turn_angle = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.road.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.turn_side {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.turn_number {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.turn_angle {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.road.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.turn_side {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.turn_number {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.turn_angle {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationNextTurnEvent {
        NavigationNextTurnEvent::new()
    }

    fn clear(&mut self) {
        self.road = ::std::option::Option::None;
        self.turn_side = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.turn_number = ::std::option::Option::None;
        self.turn_angle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationNextTurnEvent {
        static instance: NavigationNextTurnEvent = NavigationNextTurnEvent {
            road: ::std::option::Option::None,
            turn_side: ::std::option::Option::None,
            event: ::std::option::Option::None,
            image: ::std::option::Option::None,
            turn_number: ::std::option::Option::None,
            turn_angle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationNextTurnEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationNextTurnEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationNextTurnEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationNextTurnEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationNextTurnEvent`
pub mod navigation_next_turn_event {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationNextTurnEvent.TurnSide)
    pub enum TurnSide {
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.TurnSide.LEFT)
        LEFT = 1,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.TurnSide.RIGHT)
        RIGHT = 2,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.TurnSide.UNSPECIFIED)
        UNSPECIFIED = 3,
    }

    impl ::protobuf::Enum for TurnSide {
        const NAME: &'static str = "TurnSide";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TurnSide> {
            match value {
                1 => ::std::option::Option::Some(TurnSide::LEFT),
                2 => ::std::option::Option::Some(TurnSide::RIGHT),
                3 => ::std::option::Option::Some(TurnSide::UNSPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TurnSide> {
            match str {
                "LEFT" => ::std::option::Option::Some(TurnSide::LEFT),
                "RIGHT" => ::std::option::Option::Some(TurnSide::RIGHT),
                "UNSPECIFIED" => ::std::option::Option::Some(TurnSide::UNSPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TurnSide] = &[
            TurnSide::LEFT,
            TurnSide::RIGHT,
            TurnSide::UNSPECIFIED,
        ];
    }

    impl ::protobuf::EnumFull for TurnSide {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationNextTurnEvent.TurnSide").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                TurnSide::LEFT => 0,
                TurnSide::RIGHT => 1,
                TurnSide::UNSPECIFIED => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for TurnSide {
        fn default() -> Self {
            TurnSide::LEFT
        }
    }

    impl TurnSide {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TurnSide>("NavigationNextTurnEvent.TurnSide")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationNextTurnEvent.NextTurnEnum)
    pub enum NextTurnEnum {
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.DEPART)
        DEPART = 1,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.NAME_CHANGE)
        NAME_CHANGE = 2,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.SLIGHT_TURN)
        SLIGHT_TURN = 3,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.TURN)
        TURN = 4,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.SHARP_TURN)
        SHARP_TURN = 5,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.U_TURN)
        U_TURN = 6,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.ON_RAMP)
        ON_RAMP = 7,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.OFF_RAMP)
        OFF_RAMP = 8,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.FORK)
        FORK = 9,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.MERGE)
        MERGE = 10,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.ROUNDABOUT_ENTER)
        ROUNDABOUT_ENTER = 11,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.ROUNDABOUT_EXIT)
        ROUNDABOUT_EXIT = 12,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.ROUNDABOUT_ENTER_AND_EXIT)
        ROUNDABOUT_ENTER_AND_EXIT = 13,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.STRAIGHT)
        STRAIGHT = 14,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.FERRY_BOAT)
        FERRY_BOAT = 16,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.FERRY_TRAIN)
        FERRY_TRAIN = 17,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnEvent.NextTurnEnum.DESTINATION)
        DESTINATION = 19,
    }

    impl ::protobuf::Enum for NextTurnEnum {
        const NAME: &'static str = "NextTurnEnum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NextTurnEnum> {
            match value {
                0 => ::std::option::Option::Some(NextTurnEnum::UNKNOWN),
                1 => ::std::option::Option::Some(NextTurnEnum::DEPART),
                2 => ::std::option::Option::Some(NextTurnEnum::NAME_CHANGE),
                3 => ::std::option::Option::Some(NextTurnEnum::SLIGHT_TURN),
                4 => ::std::option::Option::Some(NextTurnEnum::TURN),
                5 => ::std::option::Option::Some(NextTurnEnum::SHARP_TURN),
                6 => ::std::option::Option::Some(NextTurnEnum::U_TURN),
                7 => ::std::option::Option::Some(NextTurnEnum::ON_RAMP),
                8 => ::std::option::Option::Some(NextTurnEnum::OFF_RAMP),
                9 => ::std::option::Option::Some(NextTurnEnum::FORK),
                10 => ::std::option::Option::Some(NextTurnEnum::MERGE),
                11 => ::std::option::Option::Some(NextTurnEnum::ROUNDABOUT_ENTER),
                12 => ::std::option::Option::Some(NextTurnEnum::ROUNDABOUT_EXIT),
                13 => ::std::option::Option::Some(NextTurnEnum::ROUNDABOUT_ENTER_AND_EXIT),
                14 => ::std::option::Option::Some(NextTurnEnum::STRAIGHT),
                16 => ::std::option::Option::Some(NextTurnEnum::FERRY_BOAT),
                17 => ::std::option::Option::Some(NextTurnEnum::FERRY_TRAIN),
                19 => ::std::option::Option::Some(NextTurnEnum::DESTINATION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<NextTurnEnum> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(NextTurnEnum::UNKNOWN),
                "DEPART" => ::std::option::Option::Some(NextTurnEnum::DEPART),
                "NAME_CHANGE" => ::std::option::Option::Some(NextTurnEnum::NAME_CHANGE),
                "SLIGHT_TURN" => ::std::option::Option::Some(NextTurnEnum::SLIGHT_TURN),
                "TURN" => ::std::option::Option::Some(NextTurnEnum::TURN),
                "SHARP_TURN" => ::std::option::Option::Some(NextTurnEnum::SHARP_TURN),
                "U_TURN" => ::std::option::Option::Some(NextTurnEnum::U_TURN),
                "ON_RAMP" => ::std::option::Option::Some(NextTurnEnum::ON_RAMP),
                "OFF_RAMP" => ::std::option::Option::Some(NextTurnEnum::OFF_RAMP),
                "FORK" => ::std::option::Option::Some(NextTurnEnum::FORK),
                "MERGE" => ::std::option::Option::Some(NextTurnEnum::MERGE),
                "ROUNDABOUT_ENTER" => ::std::option::Option::Some(NextTurnEnum::ROUNDABOUT_ENTER),
                "ROUNDABOUT_EXIT" => ::std::option::Option::Some(NextTurnEnum::ROUNDABOUT_EXIT),
                "ROUNDABOUT_ENTER_AND_EXIT" => ::std::option::Option::Some(NextTurnEnum::ROUNDABOUT_ENTER_AND_EXIT),
                "STRAIGHT" => ::std::option::Option::Some(NextTurnEnum::STRAIGHT),
                "FERRY_BOAT" => ::std::option::Option::Some(NextTurnEnum::FERRY_BOAT),
                "FERRY_TRAIN" => ::std::option::Option::Some(NextTurnEnum::FERRY_TRAIN),
                "DESTINATION" => ::std::option::Option::Some(NextTurnEnum::DESTINATION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NextTurnEnum] = &[
            NextTurnEnum::UNKNOWN,
            NextTurnEnum::DEPART,
            NextTurnEnum::NAME_CHANGE,
            NextTurnEnum::SLIGHT_TURN,
            NextTurnEnum::TURN,
            NextTurnEnum::SHARP_TURN,
            NextTurnEnum::U_TURN,
            NextTurnEnum::ON_RAMP,
            NextTurnEnum::OFF_RAMP,
            NextTurnEnum::FORK,
            NextTurnEnum::MERGE,
            NextTurnEnum::ROUNDABOUT_ENTER,
            NextTurnEnum::ROUNDABOUT_EXIT,
            NextTurnEnum::ROUNDABOUT_ENTER_AND_EXIT,
            NextTurnEnum::STRAIGHT,
            NextTurnEnum::FERRY_BOAT,
            NextTurnEnum::FERRY_TRAIN,
            NextTurnEnum::DESTINATION,
        ];
    }

    impl ::protobuf::EnumFull for NextTurnEnum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationNextTurnEvent.NextTurnEnum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                NextTurnEnum::UNKNOWN => 0,
                NextTurnEnum::DEPART => 1,
                NextTurnEnum::NAME_CHANGE => 2,
                NextTurnEnum::SLIGHT_TURN => 3,
                NextTurnEnum::TURN => 4,
                NextTurnEnum::SHARP_TURN => 5,
                NextTurnEnum::U_TURN => 6,
                NextTurnEnum::ON_RAMP => 7,
                NextTurnEnum::OFF_RAMP => 8,
                NextTurnEnum::FORK => 9,
                NextTurnEnum::MERGE => 10,
                NextTurnEnum::ROUNDABOUT_ENTER => 11,
                NextTurnEnum::ROUNDABOUT_EXIT => 12,
                NextTurnEnum::ROUNDABOUT_ENTER_AND_EXIT => 13,
                NextTurnEnum::STRAIGHT => 14,
                NextTurnEnum::FERRY_BOAT => 15,
                NextTurnEnum::FERRY_TRAIN => 16,
                NextTurnEnum::DESTINATION => 17,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NextTurnEnum {
        fn default() -> Self {
            NextTurnEnum::UNKNOWN
        }
    }

    impl NextTurnEnum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NextTurnEnum>("NavigationNextTurnEvent.NextTurnEnum")
        }
    }
}

// @@protoc_insertion_point(message:NavigationNextTurnDistanceEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationNextTurnDistanceEvent {
    // message fields
    // @@protoc_insertion_point(field:NavigationNextTurnDistanceEvent.distance_meters)
    pub distance_meters: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationNextTurnDistanceEvent.time_to_turn_seconds)
    pub time_to_turn_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationNextTurnDistanceEvent.display_distance_e3)
    pub display_distance_e3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationNextTurnDistanceEvent.display_distance_unit)
    pub display_distance_unit: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_next_turn_distance_event::DistanceUnits>>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationNextTurnDistanceEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationNextTurnDistanceEvent {
    fn default() -> &'a NavigationNextTurnDistanceEvent {
        <NavigationNextTurnDistanceEvent as ::protobuf::Message>::default_instance()
    }
}

impl NavigationNextTurnDistanceEvent {
    pub fn new() -> NavigationNextTurnDistanceEvent {
        ::std::default::Default::default()
    }

    // required int32 distance_meters = 1;

    pub fn distance_meters(&self) -> i32 {
        self.distance_meters.unwrap_or(0)
    }

    pub fn clear_distance_meters(&mut self) {
        self.distance_meters = ::std::option::Option::None;
    }

    pub fn has_distance_meters(&self) -> bool {
        self.distance_meters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance_meters(&mut self, v: i32) {
        self.distance_meters = ::std::option::Option::Some(v);
    }

    // required int32 time_to_turn_seconds = 2;

    pub fn time_to_turn_seconds(&self) -> i32 {
        self.time_to_turn_seconds.unwrap_or(0)
    }

    pub fn clear_time_to_turn_seconds(&mut self) {
        self.time_to_turn_seconds = ::std::option::Option::None;
    }

    pub fn has_time_to_turn_seconds(&self) -> bool {
        self.time_to_turn_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_turn_seconds(&mut self, v: i32) {
        self.time_to_turn_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 display_distance_e3 = 3;

    pub fn display_distance_e3(&self) -> i32 {
        self.display_distance_e3.unwrap_or(0)
    }

    pub fn clear_display_distance_e3(&mut self) {
        self.display_distance_e3 = ::std::option::Option::None;
    }

    pub fn has_display_distance_e3(&self) -> bool {
        self.display_distance_e3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_distance_e3(&mut self, v: i32) {
        self.display_distance_e3 = ::std::option::Option::Some(v);
    }

    // optional .NavigationNextTurnDistanceEvent.DistanceUnits display_distance_unit = 4;

    pub fn display_distance_unit(&self) -> navigation_next_turn_distance_event::DistanceUnits {
        match self.display_distance_unit {
            Some(e) => e.enum_value_or(navigation_next_turn_distance_event::DistanceUnits::UNKNOWN_DISTANCE_UNIT),
            None => navigation_next_turn_distance_event::DistanceUnits::UNKNOWN_DISTANCE_UNIT,
        }
    }

    pub fn clear_display_distance_unit(&mut self) {
        self.display_distance_unit = ::std::option::Option::None;
    }

    pub fn has_display_distance_unit(&self) -> bool {
        self.display_distance_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_distance_unit(&mut self, v: navigation_next_turn_distance_event::DistanceUnits) {
        self.display_distance_unit = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance_meters",
            |m: &NavigationNextTurnDistanceEvent| { &m.distance_meters },
            |m: &mut NavigationNextTurnDistanceEvent| { &mut m.distance_meters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_to_turn_seconds",
            |m: &NavigationNextTurnDistanceEvent| { &m.time_to_turn_seconds },
            |m: &mut NavigationNextTurnDistanceEvent| { &mut m.time_to_turn_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_distance_e3",
            |m: &NavigationNextTurnDistanceEvent| { &m.display_distance_e3 },
            |m: &mut NavigationNextTurnDistanceEvent| { &mut m.display_distance_e3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_distance_unit",
            |m: &NavigationNextTurnDistanceEvent| { &m.display_distance_unit },
            |m: &mut NavigationNextTurnDistanceEvent| { &mut m.display_distance_unit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationNextTurnDistanceEvent>(
            "NavigationNextTurnDistanceEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationNextTurnDistanceEvent {
    const NAME: &'static str = "NavigationNextTurnDistanceEvent";

    fn is_initialized(&self) -> bool {
        if self.distance_meters.is_none() {
            return false;
        }
        if self.time_to_turn_seconds.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.distance_meters = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.time_to_turn_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.display_distance_e3 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.display_distance_unit = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.distance_meters {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.time_to_turn_seconds {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.display_distance_e3 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.display_distance_unit {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.distance_meters {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time_to_turn_seconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.display_distance_e3 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.display_distance_unit {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationNextTurnDistanceEvent {
        NavigationNextTurnDistanceEvent::new()
    }

    fn clear(&mut self) {
        self.distance_meters = ::std::option::Option::None;
        self.time_to_turn_seconds = ::std::option::Option::None;
        self.display_distance_e3 = ::std::option::Option::None;
        self.display_distance_unit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationNextTurnDistanceEvent {
        static instance: NavigationNextTurnDistanceEvent = NavigationNextTurnDistanceEvent {
            distance_meters: ::std::option::Option::None,
            time_to_turn_seconds: ::std::option::Option::None,
            display_distance_e3: ::std::option::Option::None,
            display_distance_unit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationNextTurnDistanceEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationNextTurnDistanceEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationNextTurnDistanceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationNextTurnDistanceEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationNextTurnDistanceEvent`
pub mod navigation_next_turn_distance_event {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationNextTurnDistanceEvent.DistanceUnits)
    pub enum DistanceUnits {
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.UNKNOWN_DISTANCE_UNIT)
        UNKNOWN_DISTANCE_UNIT = 0,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.METERS)
        METERS = 1,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.KILOMETERS)
        KILOMETERS = 2,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.KILOMETERS_P1)
        KILOMETERS_P1 = 3,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.MILES)
        MILES = 4,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.MILES_P1)
        MILES_P1 = 5,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.FEET)
        FEET = 6,
        // @@protoc_insertion_point(enum_value:NavigationNextTurnDistanceEvent.DistanceUnits.YARDS)
        YARDS = 7,
    }

    impl ::protobuf::Enum for DistanceUnits {
        const NAME: &'static str = "DistanceUnits";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DistanceUnits> {
            match value {
                0 => ::std::option::Option::Some(DistanceUnits::UNKNOWN_DISTANCE_UNIT),
                1 => ::std::option::Option::Some(DistanceUnits::METERS),
                2 => ::std::option::Option::Some(DistanceUnits::KILOMETERS),
                3 => ::std::option::Option::Some(DistanceUnits::KILOMETERS_P1),
                4 => ::std::option::Option::Some(DistanceUnits::MILES),
                5 => ::std::option::Option::Some(DistanceUnits::MILES_P1),
                6 => ::std::option::Option::Some(DistanceUnits::FEET),
                7 => ::std::option::Option::Some(DistanceUnits::YARDS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<DistanceUnits> {
            match str {
                "UNKNOWN_DISTANCE_UNIT" => ::std::option::Option::Some(DistanceUnits::UNKNOWN_DISTANCE_UNIT),
                "METERS" => ::std::option::Option::Some(DistanceUnits::METERS),
                "KILOMETERS" => ::std::option::Option::Some(DistanceUnits::KILOMETERS),
                "KILOMETERS_P1" => ::std::option::Option::Some(DistanceUnits::KILOMETERS_P1),
                "MILES" => ::std::option::Option::Some(DistanceUnits::MILES),
                "MILES_P1" => ::std::option::Option::Some(DistanceUnits::MILES_P1),
                "FEET" => ::std::option::Option::Some(DistanceUnits::FEET),
                "YARDS" => ::std::option::Option::Some(DistanceUnits::YARDS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DistanceUnits] = &[
            DistanceUnits::UNKNOWN_DISTANCE_UNIT,
            DistanceUnits::METERS,
            DistanceUnits::KILOMETERS,
            DistanceUnits::KILOMETERS_P1,
            DistanceUnits::MILES,
            DistanceUnits::MILES_P1,
            DistanceUnits::FEET,
            DistanceUnits::YARDS,
        ];
    }

    impl ::protobuf::EnumFull for DistanceUnits {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationNextTurnDistanceEvent.DistanceUnits").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DistanceUnits {
        fn default() -> Self {
            DistanceUnits::UNKNOWN_DISTANCE_UNIT
        }
    }

    impl DistanceUnits {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DistanceUnits>("NavigationNextTurnDistanceEvent.DistanceUnits")
        }
    }
}

// @@protoc_insertion_point(message:NavigationState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationState {
    // message fields
    // @@protoc_insertion_point(field:NavigationState.steps)
    pub steps: ::std::vec::Vec<NavigationStep>,
    // @@protoc_insertion_point(field:NavigationState.destinations)
    pub destinations: ::std::vec::Vec<NavigationDestination>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationState {
    fn default() -> &'a NavigationState {
        <NavigationState as ::protobuf::Message>::default_instance()
    }
}

impl NavigationState {
    pub fn new() -> NavigationState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &NavigationState| { &m.steps },
            |m: &mut NavigationState| { &mut m.steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "destinations",
            |m: &NavigationState| { &m.destinations },
            |m: &mut NavigationState| { &mut m.destinations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationState>(
            "NavigationState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationState {
    const NAME: &'static str = "NavigationState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.steps.push(is.read_message()?);
                },
                18 => {
                    self.destinations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.destinations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.destinations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationState {
        NavigationState::new()
    }

    fn clear(&mut self) {
        self.steps.clear();
        self.destinations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationState {
        static instance: NavigationState = NavigationState {
            steps: ::std::vec::Vec::new(),
            destinations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationStep)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationStep {
    // message fields
    // @@protoc_insertion_point(field:NavigationStep.maneuver)
    pub maneuver: ::protobuf::MessageField<NavigationManeuver>,
    // @@protoc_insertion_point(field:NavigationStep.road)
    pub road: ::protobuf::MessageField<NavigationRoad>,
    // @@protoc_insertion_point(field:NavigationStep.lanes)
    pub lanes: ::std::vec::Vec<NavigationLane>,
    // @@protoc_insertion_point(field:NavigationStep.cue)
    pub cue: ::protobuf::MessageField<NavigationCue>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationStep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationStep {
    fn default() -> &'a NavigationStep {
        <NavigationStep as ::protobuf::Message>::default_instance()
    }
}

impl NavigationStep {
    pub fn new() -> NavigationStep {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationManeuver>(
            "maneuver",
            |m: &NavigationStep| { &m.maneuver },
            |m: &mut NavigationStep| { &mut m.maneuver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationRoad>(
            "road",
            |m: &NavigationStep| { &m.road },
            |m: &mut NavigationStep| { &mut m.road },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lanes",
            |m: &NavigationStep| { &m.lanes },
            |m: &mut NavigationStep| { &mut m.lanes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationCue>(
            "cue",
            |m: &NavigationStep| { &m.cue },
            |m: &mut NavigationStep| { &mut m.cue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationStep>(
            "NavigationStep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationStep {
    const NAME: &'static str = "NavigationStep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maneuver)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.road)?;
                },
                26 => {
                    self.lanes.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cue)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maneuver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.road.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.lanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maneuver.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.road.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.lanes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.cue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationStep {
        NavigationStep::new()
    }

    fn clear(&mut self) {
        self.maneuver.clear();
        self.road.clear();
        self.lanes.clear();
        self.cue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationStep {
        static instance: NavigationStep = NavigationStep {
            maneuver: ::protobuf::MessageField::none(),
            road: ::protobuf::MessageField::none(),
            lanes: ::std::vec::Vec::new(),
            cue: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationStep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationStep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationStep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationManeuver)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationManeuver {
    // message fields
    // @@protoc_insertion_point(field:NavigationManeuver.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_maneuver::NavigationType>>,
    // @@protoc_insertion_point(field:NavigationManeuver.roundabout_exit_number)
    pub roundabout_exit_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationManeuver.roundabout_exit_angle)
    pub roundabout_exit_angle: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationManeuver.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationManeuver {
    fn default() -> &'a NavigationManeuver {
        <NavigationManeuver as ::protobuf::Message>::default_instance()
    }
}

impl NavigationManeuver {
    pub fn new() -> NavigationManeuver {
        ::std::default::Default::default()
    }

    // optional .NavigationManeuver.NavigationType type = 1;

    pub fn type_(&self) -> navigation_maneuver::NavigationType {
        match self.type_ {
            Some(e) => e.enum_value_or(navigation_maneuver::NavigationType::UNKNOWN),
            None => navigation_maneuver::NavigationType::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: navigation_maneuver::NavigationType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 roundabout_exit_number = 2;

    pub fn roundabout_exit_number(&self) -> i32 {
        self.roundabout_exit_number.unwrap_or(0)
    }

    pub fn clear_roundabout_exit_number(&mut self) {
        self.roundabout_exit_number = ::std::option::Option::None;
    }

    pub fn has_roundabout_exit_number(&self) -> bool {
        self.roundabout_exit_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roundabout_exit_number(&mut self, v: i32) {
        self.roundabout_exit_number = ::std::option::Option::Some(v);
    }

    // optional int32 roundabout_exit_angle = 3;

    pub fn roundabout_exit_angle(&self) -> i32 {
        self.roundabout_exit_angle.unwrap_or(0)
    }

    pub fn clear_roundabout_exit_angle(&mut self) {
        self.roundabout_exit_angle = ::std::option::Option::None;
    }

    pub fn has_roundabout_exit_angle(&self) -> bool {
        self.roundabout_exit_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roundabout_exit_angle(&mut self, v: i32) {
        self.roundabout_exit_angle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &NavigationManeuver| { &m.type_ },
            |m: &mut NavigationManeuver| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roundabout_exit_number",
            |m: &NavigationManeuver| { &m.roundabout_exit_number },
            |m: &mut NavigationManeuver| { &mut m.roundabout_exit_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "roundabout_exit_angle",
            |m: &NavigationManeuver| { &m.roundabout_exit_angle },
            |m: &mut NavigationManeuver| { &mut m.roundabout_exit_angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationManeuver>(
            "NavigationManeuver",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationManeuver {
    const NAME: &'static str = "NavigationManeuver";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.roundabout_exit_number = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.roundabout_exit_angle = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.roundabout_exit_number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.roundabout_exit_angle {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.roundabout_exit_number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.roundabout_exit_angle {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationManeuver {
        NavigationManeuver::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.roundabout_exit_number = ::std::option::Option::None;
        self.roundabout_exit_angle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationManeuver {
        static instance: NavigationManeuver = NavigationManeuver {
            type_: ::std::option::Option::None,
            roundabout_exit_number: ::std::option::Option::None,
            roundabout_exit_angle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationManeuver {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationManeuver").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationManeuver {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationManeuver {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationManeuver`
pub mod navigation_maneuver {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationManeuver.NavigationType)
    pub enum NavigationType {
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.DEPART)
        DEPART = 1,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.NAME_CHANGE)
        NAME_CHANGE = 2,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.KEEP_LEFT)
        KEEP_LEFT = 3,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.KEEP_RIGHT)
        KEEP_RIGHT = 4,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.TURN_SLIGHT_LEFT)
        TURN_SLIGHT_LEFT = 5,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.TURN_SLIGHT_RIGHT)
        TURN_SLIGHT_RIGHT = 6,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.TURN_NORMAL_LEFT)
        TURN_NORMAL_LEFT = 7,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.TURN_NORMAL_RIGHT)
        TURN_NORMAL_RIGHT = 8,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.TURN_SHARP_LEFT)
        TURN_SHARP_LEFT = 9,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.TURN_SHARP_RIGHT)
        TURN_SHARP_RIGHT = 10,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.U_TURN_LEFT)
        U_TURN_LEFT = 11,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.U_TURN_RIGHT)
        U_TURN_RIGHT = 12,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_SLIGHT_LEFT)
        ON_RAMP_SLIGHT_LEFT = 13,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_SLIGHT_RIGHT)
        ON_RAMP_SLIGHT_RIGHT = 14,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_NORMAL_LEFT)
        ON_RAMP_NORMAL_LEFT = 15,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_NORMAL_RIGHT)
        ON_RAMP_NORMAL_RIGHT = 16,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_SHARP_LEFT)
        ON_RAMP_SHARP_LEFT = 17,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_SHARP_RIGHT)
        ON_RAMP_SHARP_RIGHT = 18,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_U_TURN_LEFT)
        ON_RAMP_U_TURN_LEFT = 19,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ON_RAMP_U_TURN_RIGHT)
        ON_RAMP_U_TURN_RIGHT = 20,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.OFF_RAMP_SLIGHT_LEFT)
        OFF_RAMP_SLIGHT_LEFT = 21,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.OFF_RAMP_SLIGHT_RIGHT)
        OFF_RAMP_SLIGHT_RIGHT = 22,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.OFF_RAMP_NORMAL_LEFT)
        OFF_RAMP_NORMAL_LEFT = 23,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.OFF_RAMP_NORMAL_RIGHT)
        OFF_RAMP_NORMAL_RIGHT = 24,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.FORK_LEFT)
        FORK_LEFT = 25,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.FORK_RIGHT)
        FORK_RIGHT = 26,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.MERGE_LEFT)
        MERGE_LEFT = 27,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.MERGE_RIGHT)
        MERGE_RIGHT = 28,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.MERGE_SIDE_UNSPECIFIED)
        MERGE_SIDE_UNSPECIFIED = 29,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ROUNDABOUT_ENTER)
        ROUNDABOUT_ENTER = 30,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ROUNDABOUT_EXIT)
        ROUNDABOUT_EXIT = 31,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ROUNDABOUT_ENTER_AND_EXIT_CW)
        ROUNDABOUT_ENTER_AND_EXIT_CW = 32,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ROUNDABOUT_ENTER_AND_EXIT_CW_WITH_ANGLE)
        ROUNDABOUT_ENTER_AND_EXIT_CW_WITH_ANGLE = 33,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ROUNDABOUT_ENTER_AND_EXIT_CCW)
        ROUNDABOUT_ENTER_AND_EXIT_CCW = 34,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE)
        ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE = 35,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.STRAIGHT)
        STRAIGHT = 36,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.FERRY_BOAT)
        FERRY_BOAT = 37,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.FERRY_TRAIN)
        FERRY_TRAIN = 38,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.DESTINATION)
        DESTINATION = 39,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.DESTINATION_STRAIGHT)
        DESTINATION_STRAIGHT = 40,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.DESTINATION_LEFT)
        DESTINATION_LEFT = 41,
        // @@protoc_insertion_point(enum_value:NavigationManeuver.NavigationType.DESTINATION_RIGHT)
        DESTINATION_RIGHT = 42,
    }

    impl ::protobuf::Enum for NavigationType {
        const NAME: &'static str = "NavigationType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NavigationType> {
            match value {
                0 => ::std::option::Option::Some(NavigationType::UNKNOWN),
                1 => ::std::option::Option::Some(NavigationType::DEPART),
                2 => ::std::option::Option::Some(NavigationType::NAME_CHANGE),
                3 => ::std::option::Option::Some(NavigationType::KEEP_LEFT),
                4 => ::std::option::Option::Some(NavigationType::KEEP_RIGHT),
                5 => ::std::option::Option::Some(NavigationType::TURN_SLIGHT_LEFT),
                6 => ::std::option::Option::Some(NavigationType::TURN_SLIGHT_RIGHT),
                7 => ::std::option::Option::Some(NavigationType::TURN_NORMAL_LEFT),
                8 => ::std::option::Option::Some(NavigationType::TURN_NORMAL_RIGHT),
                9 => ::std::option::Option::Some(NavigationType::TURN_SHARP_LEFT),
                10 => ::std::option::Option::Some(NavigationType::TURN_SHARP_RIGHT),
                11 => ::std::option::Option::Some(NavigationType::U_TURN_LEFT),
                12 => ::std::option::Option::Some(NavigationType::U_TURN_RIGHT),
                13 => ::std::option::Option::Some(NavigationType::ON_RAMP_SLIGHT_LEFT),
                14 => ::std::option::Option::Some(NavigationType::ON_RAMP_SLIGHT_RIGHT),
                15 => ::std::option::Option::Some(NavigationType::ON_RAMP_NORMAL_LEFT),
                16 => ::std::option::Option::Some(NavigationType::ON_RAMP_NORMAL_RIGHT),
                17 => ::std::option::Option::Some(NavigationType::ON_RAMP_SHARP_LEFT),
                18 => ::std::option::Option::Some(NavigationType::ON_RAMP_SHARP_RIGHT),
                19 => ::std::option::Option::Some(NavigationType::ON_RAMP_U_TURN_LEFT),
                20 => ::std::option::Option::Some(NavigationType::ON_RAMP_U_TURN_RIGHT),
                21 => ::std::option::Option::Some(NavigationType::OFF_RAMP_SLIGHT_LEFT),
                22 => ::std::option::Option::Some(NavigationType::OFF_RAMP_SLIGHT_RIGHT),
                23 => ::std::option::Option::Some(NavigationType::OFF_RAMP_NORMAL_LEFT),
                24 => ::std::option::Option::Some(NavigationType::OFF_RAMP_NORMAL_RIGHT),
                25 => ::std::option::Option::Some(NavigationType::FORK_LEFT),
                26 => ::std::option::Option::Some(NavigationType::FORK_RIGHT),
                27 => ::std::option::Option::Some(NavigationType::MERGE_LEFT),
                28 => ::std::option::Option::Some(NavigationType::MERGE_RIGHT),
                29 => ::std::option::Option::Some(NavigationType::MERGE_SIDE_UNSPECIFIED),
                30 => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER),
                31 => ::std::option::Option::Some(NavigationType::ROUNDABOUT_EXIT),
                32 => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CW),
                33 => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CW_WITH_ANGLE),
                34 => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CCW),
                35 => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE),
                36 => ::std::option::Option::Some(NavigationType::STRAIGHT),
                37 => ::std::option::Option::Some(NavigationType::FERRY_BOAT),
                38 => ::std::option::Option::Some(NavigationType::FERRY_TRAIN),
                39 => ::std::option::Option::Some(NavigationType::DESTINATION),
                40 => ::std::option::Option::Some(NavigationType::DESTINATION_STRAIGHT),
                41 => ::std::option::Option::Some(NavigationType::DESTINATION_LEFT),
                42 => ::std::option::Option::Some(NavigationType::DESTINATION_RIGHT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<NavigationType> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(NavigationType::UNKNOWN),
                "DEPART" => ::std::option::Option::Some(NavigationType::DEPART),
                "NAME_CHANGE" => ::std::option::Option::Some(NavigationType::NAME_CHANGE),
                "KEEP_LEFT" => ::std::option::Option::Some(NavigationType::KEEP_LEFT),
                "KEEP_RIGHT" => ::std::option::Option::Some(NavigationType::KEEP_RIGHT),
                "TURN_SLIGHT_LEFT" => ::std::option::Option::Some(NavigationType::TURN_SLIGHT_LEFT),
                "TURN_SLIGHT_RIGHT" => ::std::option::Option::Some(NavigationType::TURN_SLIGHT_RIGHT),
                "TURN_NORMAL_LEFT" => ::std::option::Option::Some(NavigationType::TURN_NORMAL_LEFT),
                "TURN_NORMAL_RIGHT" => ::std::option::Option::Some(NavigationType::TURN_NORMAL_RIGHT),
                "TURN_SHARP_LEFT" => ::std::option::Option::Some(NavigationType::TURN_SHARP_LEFT),
                "TURN_SHARP_RIGHT" => ::std::option::Option::Some(NavigationType::TURN_SHARP_RIGHT),
                "U_TURN_LEFT" => ::std::option::Option::Some(NavigationType::U_TURN_LEFT),
                "U_TURN_RIGHT" => ::std::option::Option::Some(NavigationType::U_TURN_RIGHT),
                "ON_RAMP_SLIGHT_LEFT" => ::std::option::Option::Some(NavigationType::ON_RAMP_SLIGHT_LEFT),
                "ON_RAMP_SLIGHT_RIGHT" => ::std::option::Option::Some(NavigationType::ON_RAMP_SLIGHT_RIGHT),
                "ON_RAMP_NORMAL_LEFT" => ::std::option::Option::Some(NavigationType::ON_RAMP_NORMAL_LEFT),
                "ON_RAMP_NORMAL_RIGHT" => ::std::option::Option::Some(NavigationType::ON_RAMP_NORMAL_RIGHT),
                "ON_RAMP_SHARP_LEFT" => ::std::option::Option::Some(NavigationType::ON_RAMP_SHARP_LEFT),
                "ON_RAMP_SHARP_RIGHT" => ::std::option::Option::Some(NavigationType::ON_RAMP_SHARP_RIGHT),
                "ON_RAMP_U_TURN_LEFT" => ::std::option::Option::Some(NavigationType::ON_RAMP_U_TURN_LEFT),
                "ON_RAMP_U_TURN_RIGHT" => ::std::option::Option::Some(NavigationType::ON_RAMP_U_TURN_RIGHT),
                "OFF_RAMP_SLIGHT_LEFT" => ::std::option::Option::Some(NavigationType::OFF_RAMP_SLIGHT_LEFT),
                "OFF_RAMP_SLIGHT_RIGHT" => ::std::option::Option::Some(NavigationType::OFF_RAMP_SLIGHT_RIGHT),
                "OFF_RAMP_NORMAL_LEFT" => ::std::option::Option::Some(NavigationType::OFF_RAMP_NORMAL_LEFT),
                "OFF_RAMP_NORMAL_RIGHT" => ::std::option::Option::Some(NavigationType::OFF_RAMP_NORMAL_RIGHT),
                "FORK_LEFT" => ::std::option::Option::Some(NavigationType::FORK_LEFT),
                "FORK_RIGHT" => ::std::option::Option::Some(NavigationType::FORK_RIGHT),
                "MERGE_LEFT" => ::std::option::Option::Some(NavigationType::MERGE_LEFT),
                "MERGE_RIGHT" => ::std::option::Option::Some(NavigationType::MERGE_RIGHT),
                "MERGE_SIDE_UNSPECIFIED" => ::std::option::Option::Some(NavigationType::MERGE_SIDE_UNSPECIFIED),
                "ROUNDABOUT_ENTER" => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER),
                "ROUNDABOUT_EXIT" => ::std::option::Option::Some(NavigationType::ROUNDABOUT_EXIT),
                "ROUNDABOUT_ENTER_AND_EXIT_CW" => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CW),
                "ROUNDABOUT_ENTER_AND_EXIT_CW_WITH_ANGLE" => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CW_WITH_ANGLE),
                "ROUNDABOUT_ENTER_AND_EXIT_CCW" => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CCW),
                "ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE" => ::std::option::Option::Some(NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE),
                "STRAIGHT" => ::std::option::Option::Some(NavigationType::STRAIGHT),
                "FERRY_BOAT" => ::std::option::Option::Some(NavigationType::FERRY_BOAT),
                "FERRY_TRAIN" => ::std::option::Option::Some(NavigationType::FERRY_TRAIN),
                "DESTINATION" => ::std::option::Option::Some(NavigationType::DESTINATION),
                "DESTINATION_STRAIGHT" => ::std::option::Option::Some(NavigationType::DESTINATION_STRAIGHT),
                "DESTINATION_LEFT" => ::std::option::Option::Some(NavigationType::DESTINATION_LEFT),
                "DESTINATION_RIGHT" => ::std::option::Option::Some(NavigationType::DESTINATION_RIGHT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NavigationType] = &[
            NavigationType::UNKNOWN,
            NavigationType::DEPART,
            NavigationType::NAME_CHANGE,
            NavigationType::KEEP_LEFT,
            NavigationType::KEEP_RIGHT,
            NavigationType::TURN_SLIGHT_LEFT,
            NavigationType::TURN_SLIGHT_RIGHT,
            NavigationType::TURN_NORMAL_LEFT,
            NavigationType::TURN_NORMAL_RIGHT,
            NavigationType::TURN_SHARP_LEFT,
            NavigationType::TURN_SHARP_RIGHT,
            NavigationType::U_TURN_LEFT,
            NavigationType::U_TURN_RIGHT,
            NavigationType::ON_RAMP_SLIGHT_LEFT,
            NavigationType::ON_RAMP_SLIGHT_RIGHT,
            NavigationType::ON_RAMP_NORMAL_LEFT,
            NavigationType::ON_RAMP_NORMAL_RIGHT,
            NavigationType::ON_RAMP_SHARP_LEFT,
            NavigationType::ON_RAMP_SHARP_RIGHT,
            NavigationType::ON_RAMP_U_TURN_LEFT,
            NavigationType::ON_RAMP_U_TURN_RIGHT,
            NavigationType::OFF_RAMP_SLIGHT_LEFT,
            NavigationType::OFF_RAMP_SLIGHT_RIGHT,
            NavigationType::OFF_RAMP_NORMAL_LEFT,
            NavigationType::OFF_RAMP_NORMAL_RIGHT,
            NavigationType::FORK_LEFT,
            NavigationType::FORK_RIGHT,
            NavigationType::MERGE_LEFT,
            NavigationType::MERGE_RIGHT,
            NavigationType::MERGE_SIDE_UNSPECIFIED,
            NavigationType::ROUNDABOUT_ENTER,
            NavigationType::ROUNDABOUT_EXIT,
            NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CW,
            NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CW_WITH_ANGLE,
            NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CCW,
            NavigationType::ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE,
            NavigationType::STRAIGHT,
            NavigationType::FERRY_BOAT,
            NavigationType::FERRY_TRAIN,
            NavigationType::DESTINATION,
            NavigationType::DESTINATION_STRAIGHT,
            NavigationType::DESTINATION_LEFT,
            NavigationType::DESTINATION_RIGHT,
        ];
    }

    impl ::protobuf::EnumFull for NavigationType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationManeuver.NavigationType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NavigationType {
        fn default() -> Self {
            NavigationType::UNKNOWN
        }
    }

    impl NavigationType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NavigationType>("NavigationManeuver.NavigationType")
        }
    }
}

// @@protoc_insertion_point(message:NavigationCue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationCue {
    // message fields
    // @@protoc_insertion_point(field:NavigationCue.alternate_text)
    pub alternate_text: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationCue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationCue {
    fn default() -> &'a NavigationCue {
        <NavigationCue as ::protobuf::Message>::default_instance()
    }
}

impl NavigationCue {
    pub fn new() -> NavigationCue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alternate_text",
            |m: &NavigationCue| { &m.alternate_text },
            |m: &mut NavigationCue| { &mut m.alternate_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationCue>(
            "NavigationCue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationCue {
    const NAME: &'static str = "NavigationCue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.alternate_text.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.alternate_text {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.alternate_text {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationCue {
        NavigationCue::new()
    }

    fn clear(&mut self) {
        self.alternate_text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationCue {
        static instance: NavigationCue = NavigationCue {
            alternate_text: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationCue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationCue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationCue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationCue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationLane)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationLane {
    // message fields
    // @@protoc_insertion_point(field:NavigationLane.lane_directions)
    pub lane_directions: ::std::vec::Vec<navigation_lane::LaneDirection>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationLane.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationLane {
    fn default() -> &'a NavigationLane {
        <NavigationLane as ::protobuf::Message>::default_instance()
    }
}

impl NavigationLane {
    pub fn new() -> NavigationLane {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lane_directions",
            |m: &NavigationLane| { &m.lane_directions },
            |m: &mut NavigationLane| { &mut m.lane_directions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationLane>(
            "NavigationLane",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationLane {
    const NAME: &'static str = "NavigationLane";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lane_directions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lane_directions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.lane_directions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationLane {
        NavigationLane::new()
    }

    fn clear(&mut self) {
        self.lane_directions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationLane {
        static instance: NavigationLane = NavigationLane {
            lane_directions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationLane {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationLane").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationLane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationLane {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationLane`
pub mod navigation_lane {
    // @@protoc_insertion_point(message:NavigationLane.LaneDirection)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LaneDirection {
        // message fields
        // @@protoc_insertion_point(field:NavigationLane.LaneDirection.shape)
        pub shape: ::std::option::Option<::protobuf::EnumOrUnknown<lane_direction::Shape>>,
        // @@protoc_insertion_point(field:NavigationLane.LaneDirection.is_highlighted)
        pub is_highlighted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:NavigationLane.LaneDirection.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LaneDirection {
        fn default() -> &'a LaneDirection {
            <LaneDirection as ::protobuf::Message>::default_instance()
        }
    }

    impl LaneDirection {
        pub fn new() -> LaneDirection {
            ::std::default::Default::default()
        }

        // optional .NavigationLane.LaneDirection.Shape shape = 1;

        pub fn shape(&self) -> lane_direction::Shape {
            match self.shape {
                Some(e) => e.enum_value_or(lane_direction::Shape::UNKNOWN),
                None => lane_direction::Shape::UNKNOWN,
            }
        }

        pub fn clear_shape(&mut self) {
            self.shape = ::std::option::Option::None;
        }

        pub fn has_shape(&self) -> bool {
            self.shape.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shape(&mut self, v: lane_direction::Shape) {
            self.shape = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool is_highlighted = 2;

        pub fn is_highlighted(&self) -> bool {
            self.is_highlighted.unwrap_or(false)
        }

        pub fn clear_is_highlighted(&mut self) {
            self.is_highlighted = ::std::option::Option::None;
        }

        pub fn has_is_highlighted(&self) -> bool {
            self.is_highlighted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_highlighted(&mut self, v: bool) {
            self.is_highlighted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "shape",
                |m: &LaneDirection| { &m.shape },
                |m: &mut LaneDirection| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_highlighted",
                |m: &LaneDirection| { &m.is_highlighted },
                |m: &mut LaneDirection| { &mut m.is_highlighted },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LaneDirection>(
                "NavigationLane.LaneDirection",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LaneDirection {
        const NAME: &'static str = "LaneDirection";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.shape = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.is_highlighted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.shape {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.is_highlighted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.shape {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.is_highlighted {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LaneDirection {
            LaneDirection::new()
        }

        fn clear(&mut self) {
            self.shape = ::std::option::Option::None;
            self.is_highlighted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LaneDirection {
            static instance: LaneDirection = LaneDirection {
                shape: ::std::option::Option::None,
                is_highlighted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LaneDirection {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NavigationLane.LaneDirection").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LaneDirection {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LaneDirection {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `LaneDirection`
    pub mod lane_direction {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:NavigationLane.LaneDirection.Shape)
        pub enum Shape {
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.UNKNOWN)
            UNKNOWN = 0,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.STRAIGHT)
            STRAIGHT = 1,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.SLIGHT_LEFT)
            SLIGHT_LEFT = 2,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.SLIGHT_RIGHT)
            SLIGHT_RIGHT = 3,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.NORMAL_LEFT)
            NORMAL_LEFT = 4,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.NORMAL_RIGHT)
            NORMAL_RIGHT = 5,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.SHARP_LEFT)
            SHARP_LEFT = 6,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.SHARP_RIGHT)
            SHARP_RIGHT = 7,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.U_TURN_LEFT)
            U_TURN_LEFT = 8,
            // @@protoc_insertion_point(enum_value:NavigationLane.LaneDirection.Shape.U_TURN_RIGHT)
            U_TURN_RIGHT = 9,
        }

        impl ::protobuf::Enum for Shape {
            const NAME: &'static str = "Shape";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Shape> {
                match value {
                    0 => ::std::option::Option::Some(Shape::UNKNOWN),
                    1 => ::std::option::Option::Some(Shape::STRAIGHT),
                    2 => ::std::option::Option::Some(Shape::SLIGHT_LEFT),
                    3 => ::std::option::Option::Some(Shape::SLIGHT_RIGHT),
                    4 => ::std::option::Option::Some(Shape::NORMAL_LEFT),
                    5 => ::std::option::Option::Some(Shape::NORMAL_RIGHT),
                    6 => ::std::option::Option::Some(Shape::SHARP_LEFT),
                    7 => ::std::option::Option::Some(Shape::SHARP_RIGHT),
                    8 => ::std::option::Option::Some(Shape::U_TURN_LEFT),
                    9 => ::std::option::Option::Some(Shape::U_TURN_RIGHT),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Shape> {
                match str {
                    "UNKNOWN" => ::std::option::Option::Some(Shape::UNKNOWN),
                    "STRAIGHT" => ::std::option::Option::Some(Shape::STRAIGHT),
                    "SLIGHT_LEFT" => ::std::option::Option::Some(Shape::SLIGHT_LEFT),
                    "SLIGHT_RIGHT" => ::std::option::Option::Some(Shape::SLIGHT_RIGHT),
                    "NORMAL_LEFT" => ::std::option::Option::Some(Shape::NORMAL_LEFT),
                    "NORMAL_RIGHT" => ::std::option::Option::Some(Shape::NORMAL_RIGHT),
                    "SHARP_LEFT" => ::std::option::Option::Some(Shape::SHARP_LEFT),
                    "SHARP_RIGHT" => ::std::option::Option::Some(Shape::SHARP_RIGHT),
                    "U_TURN_LEFT" => ::std::option::Option::Some(Shape::U_TURN_LEFT),
                    "U_TURN_RIGHT" => ::std::option::Option::Some(Shape::U_TURN_RIGHT),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Shape] = &[
                Shape::UNKNOWN,
                Shape::STRAIGHT,
                Shape::SLIGHT_LEFT,
                Shape::SLIGHT_RIGHT,
                Shape::NORMAL_LEFT,
                Shape::NORMAL_RIGHT,
                Shape::SHARP_LEFT,
                Shape::SHARP_RIGHT,
                Shape::U_TURN_LEFT,
                Shape::U_TURN_RIGHT,
            ];
        }

        impl ::protobuf::EnumFull for Shape {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("NavigationLane.LaneDirection.Shape").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Shape {
            fn default() -> Self {
                Shape::UNKNOWN
            }
        }

        impl Shape {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Shape>("NavigationLane.LaneDirection.Shape")
            }
        }
    }
}

// @@protoc_insertion_point(message:NavigationDestination)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationDestination {
    // message fields
    // @@protoc_insertion_point(field:NavigationDestination.address)
    pub address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationDestination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationDestination {
    fn default() -> &'a NavigationDestination {
        <NavigationDestination as ::protobuf::Message>::default_instance()
    }
}

impl NavigationDestination {
    pub fn new() -> NavigationDestination {
        ::std::default::Default::default()
    }

    // optional string address = 1;

    pub fn address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &NavigationDestination| { &m.address },
            |m: &mut NavigationDestination| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationDestination>(
            "NavigationDestination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationDestination {
    const NAME: &'static str = "NavigationDestination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.address.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationDestination {
        NavigationDestination::new()
    }

    fn clear(&mut self) {
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationDestination {
        static instance: NavigationDestination = NavigationDestination {
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationDestination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationDestination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationDestination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationCurrentPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationCurrentPosition {
    // message fields
    // @@protoc_insertion_point(field:NavigationCurrentPosition.step_distance)
    pub step_distance: ::protobuf::MessageField<NavigationStepDistance>,
    // @@protoc_insertion_point(field:NavigationCurrentPosition.destination_distances)
    pub destination_distances: ::std::vec::Vec<NavigationDestinationDistance>,
    // @@protoc_insertion_point(field:NavigationCurrentPosition.current_road)
    pub current_road: ::protobuf::MessageField<NavigationRoad>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationCurrentPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationCurrentPosition {
    fn default() -> &'a NavigationCurrentPosition {
        <NavigationCurrentPosition as ::protobuf::Message>::default_instance()
    }
}

impl NavigationCurrentPosition {
    pub fn new() -> NavigationCurrentPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationStepDistance>(
            "step_distance",
            |m: &NavigationCurrentPosition| { &m.step_distance },
            |m: &mut NavigationCurrentPosition| { &mut m.step_distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "destination_distances",
            |m: &NavigationCurrentPosition| { &m.destination_distances },
            |m: &mut NavigationCurrentPosition| { &mut m.destination_distances },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationRoad>(
            "current_road",
            |m: &NavigationCurrentPosition| { &m.current_road },
            |m: &mut NavigationCurrentPosition| { &mut m.current_road },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationCurrentPosition>(
            "NavigationCurrentPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationCurrentPosition {
    const NAME: &'static str = "NavigationCurrentPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.step_distance)?;
                },
                18 => {
                    self.destination_distances.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.current_road)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.step_distance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.destination_distances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.current_road.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.step_distance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.destination_distances {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.current_road.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationCurrentPosition {
        NavigationCurrentPosition::new()
    }

    fn clear(&mut self) {
        self.step_distance.clear();
        self.destination_distances.clear();
        self.current_road.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationCurrentPosition {
        static instance: NavigationCurrentPosition = NavigationCurrentPosition {
            step_distance: ::protobuf::MessageField::none(),
            destination_distances: ::std::vec::Vec::new(),
            current_road: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationCurrentPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationCurrentPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationCurrentPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationCurrentPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationStepDistance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationStepDistance {
    // message fields
    // @@protoc_insertion_point(field:NavigationStepDistance.distance)
    pub distance: ::protobuf::MessageField<NavigationDistance>,
    // @@protoc_insertion_point(field:NavigationStepDistance.time_to_step_seconds)
    pub time_to_step_seconds: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationStepDistance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationStepDistance {
    fn default() -> &'a NavigationStepDistance {
        <NavigationStepDistance as ::protobuf::Message>::default_instance()
    }
}

impl NavigationStepDistance {
    pub fn new() -> NavigationStepDistance {
        ::std::default::Default::default()
    }

    // optional int64 time_to_step_seconds = 2;

    pub fn time_to_step_seconds(&self) -> i64 {
        self.time_to_step_seconds.unwrap_or(0)
    }

    pub fn clear_time_to_step_seconds(&mut self) {
        self.time_to_step_seconds = ::std::option::Option::None;
    }

    pub fn has_time_to_step_seconds(&self) -> bool {
        self.time_to_step_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_step_seconds(&mut self, v: i64) {
        self.time_to_step_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationDistance>(
            "distance",
            |m: &NavigationStepDistance| { &m.distance },
            |m: &mut NavigationStepDistance| { &mut m.distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_to_step_seconds",
            |m: &NavigationStepDistance| { &m.time_to_step_seconds },
            |m: &mut NavigationStepDistance| { &mut m.time_to_step_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationStepDistance>(
            "NavigationStepDistance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationStepDistance {
    const NAME: &'static str = "NavigationStepDistance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.distance)?;
                },
                16 => {
                    self.time_to_step_seconds = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.distance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_to_step_seconds {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.distance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.time_to_step_seconds {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationStepDistance {
        NavigationStepDistance::new()
    }

    fn clear(&mut self) {
        self.distance.clear();
        self.time_to_step_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationStepDistance {
        static instance: NavigationStepDistance = NavigationStepDistance {
            distance: ::protobuf::MessageField::none(),
            time_to_step_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationStepDistance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationStepDistance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationStepDistance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationStepDistance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationDestinationDistance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationDestinationDistance {
    // message fields
    // @@protoc_insertion_point(field:NavigationDestinationDistance.distance)
    pub distance: ::protobuf::MessageField<NavigationDistance>,
    // @@protoc_insertion_point(field:NavigationDestinationDistance.estimated_time_at_arrival)
    pub estimated_time_at_arrival: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NavigationDestinationDistance.time_to_arrival_seconds)
    pub time_to_arrival_seconds: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationDestinationDistance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationDestinationDistance {
    fn default() -> &'a NavigationDestinationDistance {
        <NavigationDestinationDistance as ::protobuf::Message>::default_instance()
    }
}

impl NavigationDestinationDistance {
    pub fn new() -> NavigationDestinationDistance {
        ::std::default::Default::default()
    }

    // optional string estimated_time_at_arrival = 2;

    pub fn estimated_time_at_arrival(&self) -> &str {
        match self.estimated_time_at_arrival.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_estimated_time_at_arrival(&mut self) {
        self.estimated_time_at_arrival = ::std::option::Option::None;
    }

    pub fn has_estimated_time_at_arrival(&self) -> bool {
        self.estimated_time_at_arrival.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_time_at_arrival(&mut self, v: ::std::string::String) {
        self.estimated_time_at_arrival = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_estimated_time_at_arrival(&mut self) -> &mut ::std::string::String {
        if self.estimated_time_at_arrival.is_none() {
            self.estimated_time_at_arrival = ::std::option::Option::Some(::std::string::String::new());
        }
        self.estimated_time_at_arrival.as_mut().unwrap()
    }

    // Take field
    pub fn take_estimated_time_at_arrival(&mut self) -> ::std::string::String {
        self.estimated_time_at_arrival.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 time_to_arrival_seconds = 3;

    pub fn time_to_arrival_seconds(&self) -> i64 {
        self.time_to_arrival_seconds.unwrap_or(0)
    }

    pub fn clear_time_to_arrival_seconds(&mut self) {
        self.time_to_arrival_seconds = ::std::option::Option::None;
    }

    pub fn has_time_to_arrival_seconds(&self) -> bool {
        self.time_to_arrival_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_arrival_seconds(&mut self, v: i64) {
        self.time_to_arrival_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NavigationDistance>(
            "distance",
            |m: &NavigationDestinationDistance| { &m.distance },
            |m: &mut NavigationDestinationDistance| { &mut m.distance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimated_time_at_arrival",
            |m: &NavigationDestinationDistance| { &m.estimated_time_at_arrival },
            |m: &mut NavigationDestinationDistance| { &mut m.estimated_time_at_arrival },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_to_arrival_seconds",
            |m: &NavigationDestinationDistance| { &m.time_to_arrival_seconds },
            |m: &mut NavigationDestinationDistance| { &mut m.time_to_arrival_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationDestinationDistance>(
            "NavigationDestinationDistance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationDestinationDistance {
    const NAME: &'static str = "NavigationDestinationDistance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.distance)?;
                },
                18 => {
                    self.estimated_time_at_arrival = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.time_to_arrival_seconds = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.distance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.estimated_time_at_arrival.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.time_to_arrival_seconds {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.distance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.estimated_time_at_arrival.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.time_to_arrival_seconds {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationDestinationDistance {
        NavigationDestinationDistance::new()
    }

    fn clear(&mut self) {
        self.distance.clear();
        self.estimated_time_at_arrival = ::std::option::Option::None;
        self.time_to_arrival_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationDestinationDistance {
        static instance: NavigationDestinationDistance = NavigationDestinationDistance {
            distance: ::protobuf::MessageField::none(),
            estimated_time_at_arrival: ::std::option::Option::None,
            time_to_arrival_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationDestinationDistance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationDestinationDistance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationDestinationDistance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationDestinationDistance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationRoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationRoad {
    // message fields
    // @@protoc_insertion_point(field:NavigationRoad.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationRoad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationRoad {
    fn default() -> &'a NavigationRoad {
        <NavigationRoad as ::protobuf::Message>::default_instance()
    }
}

impl NavigationRoad {
    pub fn new() -> NavigationRoad {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NavigationRoad| { &m.name },
            |m: &mut NavigationRoad| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationRoad>(
            "NavigationRoad",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationRoad {
    const NAME: &'static str = "NavigationRoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationRoad {
        NavigationRoad::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationRoad {
        static instance: NavigationRoad = NavigationRoad {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationRoad {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationRoad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationRoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationRoad {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NavigationDistance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NavigationDistance {
    // message fields
    // @@protoc_insertion_point(field:NavigationDistance.meters)
    pub meters: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:NavigationDistance.display_value)
    pub display_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NavigationDistance.display_units)
    pub display_units: ::std::option::Option<::protobuf::EnumOrUnknown<navigation_distance::DistanceUnits>>,
    // special fields
    // @@protoc_insertion_point(special_field:NavigationDistance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NavigationDistance {
    fn default() -> &'a NavigationDistance {
        <NavigationDistance as ::protobuf::Message>::default_instance()
    }
}

impl NavigationDistance {
    pub fn new() -> NavigationDistance {
        ::std::default::Default::default()
    }

    // optional int32 meters = 1;

    pub fn meters(&self) -> i32 {
        self.meters.unwrap_or(0)
    }

    pub fn clear_meters(&mut self) {
        self.meters = ::std::option::Option::None;
    }

    pub fn has_meters(&self) -> bool {
        self.meters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meters(&mut self, v: i32) {
        self.meters = ::std::option::Option::Some(v);
    }

    // optional string display_value = 2;

    pub fn display_value(&self) -> &str {
        match self.display_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_value(&mut self) {
        self.display_value = ::std::option::Option::None;
    }

    pub fn has_display_value(&self) -> bool {
        self.display_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_value(&mut self, v: ::std::string::String) {
        self.display_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_value(&mut self) -> &mut ::std::string::String {
        if self.display_value.is_none() {
            self.display_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_value(&mut self) -> ::std::string::String {
        self.display_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .NavigationDistance.DistanceUnits display_units = 3;

    pub fn display_units(&self) -> navigation_distance::DistanceUnits {
        match self.display_units {
            Some(e) => e.enum_value_or(navigation_distance::DistanceUnits::UNKNOWN_DISTANCE_UNIT),
            None => navigation_distance::DistanceUnits::UNKNOWN_DISTANCE_UNIT,
        }
    }

    pub fn clear_display_units(&mut self) {
        self.display_units = ::std::option::Option::None;
    }

    pub fn has_display_units(&self) -> bool {
        self.display_units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_units(&mut self, v: navigation_distance::DistanceUnits) {
        self.display_units = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "meters",
            |m: &NavigationDistance| { &m.meters },
            |m: &mut NavigationDistance| { &mut m.meters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_value",
            |m: &NavigationDistance| { &m.display_value },
            |m: &mut NavigationDistance| { &mut m.display_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_units",
            |m: &NavigationDistance| { &m.display_units },
            |m: &mut NavigationDistance| { &mut m.display_units },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NavigationDistance>(
            "NavigationDistance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NavigationDistance {
    const NAME: &'static str = "NavigationDistance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.meters = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.display_value = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.display_units = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.meters {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.display_value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.display_units {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.meters {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display_value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.display_units {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NavigationDistance {
        NavigationDistance::new()
    }

    fn clear(&mut self) {
        self.meters = ::std::option::Option::None;
        self.display_value = ::std::option::Option::None;
        self.display_units = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NavigationDistance {
        static instance: NavigationDistance = NavigationDistance {
            meters: ::std::option::Option::None,
            display_value: ::std::option::Option::None,
            display_units: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NavigationDistance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NavigationDistance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NavigationDistance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NavigationDistance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NavigationDistance`
pub mod navigation_distance {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:NavigationDistance.DistanceUnits)
    pub enum DistanceUnits {
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.UNKNOWN_DISTANCE_UNIT)
        UNKNOWN_DISTANCE_UNIT = 0,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.METERS)
        METERS = 1,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.KILOMETERS)
        KILOMETERS = 2,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.KILOMETERS_P1)
        KILOMETERS_P1 = 3,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.MILES)
        MILES = 4,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.MILES_P1)
        MILES_P1 = 5,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.FEET)
        FEET = 6,
        // @@protoc_insertion_point(enum_value:NavigationDistance.DistanceUnits.YARDS)
        YARDS = 7,
    }

    impl ::protobuf::Enum for DistanceUnits {
        const NAME: &'static str = "DistanceUnits";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DistanceUnits> {
            match value {
                0 => ::std::option::Option::Some(DistanceUnits::UNKNOWN_DISTANCE_UNIT),
                1 => ::std::option::Option::Some(DistanceUnits::METERS),
                2 => ::std::option::Option::Some(DistanceUnits::KILOMETERS),
                3 => ::std::option::Option::Some(DistanceUnits::KILOMETERS_P1),
                4 => ::std::option::Option::Some(DistanceUnits::MILES),
                5 => ::std::option::Option::Some(DistanceUnits::MILES_P1),
                6 => ::std::option::Option::Some(DistanceUnits::FEET),
                7 => ::std::option::Option::Some(DistanceUnits::YARDS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<DistanceUnits> {
            match str {
                "UNKNOWN_DISTANCE_UNIT" => ::std::option::Option::Some(DistanceUnits::UNKNOWN_DISTANCE_UNIT),
                "METERS" => ::std::option::Option::Some(DistanceUnits::METERS),
                "KILOMETERS" => ::std::option::Option::Some(DistanceUnits::KILOMETERS),
                "KILOMETERS_P1" => ::std::option::Option::Some(DistanceUnits::KILOMETERS_P1),
                "MILES" => ::std::option::Option::Some(DistanceUnits::MILES),
                "MILES_P1" => ::std::option::Option::Some(DistanceUnits::MILES_P1),
                "FEET" => ::std::option::Option::Some(DistanceUnits::FEET),
                "YARDS" => ::std::option::Option::Some(DistanceUnits::YARDS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DistanceUnits] = &[
            DistanceUnits::UNKNOWN_DISTANCE_UNIT,
            DistanceUnits::METERS,
            DistanceUnits::KILOMETERS,
            DistanceUnits::KILOMETERS_P1,
            DistanceUnits::MILES,
            DistanceUnits::MILES_P1,
            DistanceUnits::FEET,
            DistanceUnits::YARDS,
        ];
    }

    impl ::protobuf::EnumFull for DistanceUnits {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NavigationDistance.DistanceUnits").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DistanceUnits {
        fn default() -> Self {
            DistanceUnits::UNKNOWN_DISTANCE_UNIT
        }
    }

    impl DistanceUnits {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DistanceUnits>("NavigationDistance.DistanceUnits")
        }
    }
}

// @@protoc_insertion_point(message:InstrumentClusterInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstrumentClusterInput {
    // message fields
    // @@protoc_insertion_point(field:InstrumentClusterInput.action)
    pub action: ::std::option::Option<::protobuf::EnumOrUnknown<instrument_cluster_input::InstrumentClusterAction>>,
    // special fields
    // @@protoc_insertion_point(special_field:InstrumentClusterInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstrumentClusterInput {
    fn default() -> &'a InstrumentClusterInput {
        <InstrumentClusterInput as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentClusterInput {
    pub fn new() -> InstrumentClusterInput {
        ::std::default::Default::default()
    }

    // required .InstrumentClusterInput.InstrumentClusterAction action = 1;

    pub fn action(&self) -> instrument_cluster_input::InstrumentClusterAction {
        match self.action {
            Some(e) => e.enum_value_or(instrument_cluster_input::InstrumentClusterAction::UNKNOWN),
            None => instrument_cluster_input::InstrumentClusterAction::UNKNOWN,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: instrument_cluster_input::InstrumentClusterAction) {
        self.action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &InstrumentClusterInput| { &m.action },
            |m: &mut InstrumentClusterInput| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstrumentClusterInput>(
            "InstrumentClusterInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstrumentClusterInput {
    const NAME: &'static str = "InstrumentClusterInput";

    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstrumentClusterInput {
        InstrumentClusterInput::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstrumentClusterInput {
        static instance: InstrumentClusterInput = InstrumentClusterInput {
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstrumentClusterInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstrumentClusterInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstrumentClusterInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentClusterInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InstrumentClusterInput`
pub mod instrument_cluster_input {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:InstrumentClusterInput.InstrumentClusterAction)
    pub enum InstrumentClusterAction {
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.UP)
        UP = 1,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.DOWN)
        DOWN = 2,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.LEFT)
        LEFT = 3,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.RIGHT)
        RIGHT = 4,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.ENTER)
        ENTER = 5,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.BACK)
        BACK = 6,
        // @@protoc_insertion_point(enum_value:InstrumentClusterInput.InstrumentClusterAction.CALL)
        CALL = 7,
    }

    impl ::protobuf::Enum for InstrumentClusterAction {
        const NAME: &'static str = "InstrumentClusterAction";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<InstrumentClusterAction> {
            match value {
                0 => ::std::option::Option::Some(InstrumentClusterAction::UNKNOWN),
                1 => ::std::option::Option::Some(InstrumentClusterAction::UP),
                2 => ::std::option::Option::Some(InstrumentClusterAction::DOWN),
                3 => ::std::option::Option::Some(InstrumentClusterAction::LEFT),
                4 => ::std::option::Option::Some(InstrumentClusterAction::RIGHT),
                5 => ::std::option::Option::Some(InstrumentClusterAction::ENTER),
                6 => ::std::option::Option::Some(InstrumentClusterAction::BACK),
                7 => ::std::option::Option::Some(InstrumentClusterAction::CALL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<InstrumentClusterAction> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(InstrumentClusterAction::UNKNOWN),
                "UP" => ::std::option::Option::Some(InstrumentClusterAction::UP),
                "DOWN" => ::std::option::Option::Some(InstrumentClusterAction::DOWN),
                "LEFT" => ::std::option::Option::Some(InstrumentClusterAction::LEFT),
                "RIGHT" => ::std::option::Option::Some(InstrumentClusterAction::RIGHT),
                "ENTER" => ::std::option::Option::Some(InstrumentClusterAction::ENTER),
                "BACK" => ::std::option::Option::Some(InstrumentClusterAction::BACK),
                "CALL" => ::std::option::Option::Some(InstrumentClusterAction::CALL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [InstrumentClusterAction] = &[
            InstrumentClusterAction::UNKNOWN,
            InstrumentClusterAction::UP,
            InstrumentClusterAction::DOWN,
            InstrumentClusterAction::LEFT,
            InstrumentClusterAction::RIGHT,
            InstrumentClusterAction::ENTER,
            InstrumentClusterAction::BACK,
            InstrumentClusterAction::CALL,
        ];
    }

    impl ::protobuf::EnumFull for InstrumentClusterAction {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InstrumentClusterInput.InstrumentClusterAction").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for InstrumentClusterAction {
        fn default() -> Self {
            InstrumentClusterAction::UNKNOWN
        }
    }

    impl InstrumentClusterAction {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InstrumentClusterAction>("InstrumentClusterInput.InstrumentClusterAction")
        }
    }
}

// @@protoc_insertion_point(message:MediaPlaybackStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaPlaybackStatus {
    // message fields
    // @@protoc_insertion_point(field:MediaPlaybackStatus.state)
    pub state: ::std::option::Option<::protobuf::EnumOrUnknown<media_playback_status::State>>,
    // @@protoc_insertion_point(field:MediaPlaybackStatus.media_source)
    pub media_source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaPlaybackStatus.playback_seconds)
    pub playback_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MediaPlaybackStatus.shuffle)
    pub shuffle: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MediaPlaybackStatus.repeat)
    pub repeat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MediaPlaybackStatus.repeat_one)
    pub repeat_one: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlaybackStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaPlaybackStatus {
    fn default() -> &'a MediaPlaybackStatus {
        <MediaPlaybackStatus as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlaybackStatus {
    pub fn new() -> MediaPlaybackStatus {
        ::std::default::Default::default()
    }

    // optional .MediaPlaybackStatus.State state = 1;

    pub fn state(&self) -> media_playback_status::State {
        match self.state {
            Some(e) => e.enum_value_or(media_playback_status::State::STOPPED),
            None => media_playback_status::State::STOPPED,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: media_playback_status::State) {
        self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string media_source = 2;

    pub fn media_source(&self) -> &str {
        match self.media_source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_media_source(&mut self) {
        self.media_source = ::std::option::Option::None;
    }

    pub fn has_media_source(&self) -> bool {
        self.media_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media_source(&mut self, v: ::std::string::String) {
        self.media_source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media_source(&mut self) -> &mut ::std::string::String {
        if self.media_source.is_none() {
            self.media_source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.media_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_media_source(&mut self) -> ::std::string::String {
        self.media_source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 playback_seconds = 3;

    pub fn playback_seconds(&self) -> u32 {
        self.playback_seconds.unwrap_or(0)
    }

    pub fn clear_playback_seconds(&mut self) {
        self.playback_seconds = ::std::option::Option::None;
    }

    pub fn has_playback_seconds(&self) -> bool {
        self.playback_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_seconds(&mut self, v: u32) {
        self.playback_seconds = ::std::option::Option::Some(v);
    }

    // optional bool shuffle = 4;

    pub fn shuffle(&self) -> bool {
        self.shuffle.unwrap_or(false)
    }

    pub fn clear_shuffle(&mut self) {
        self.shuffle = ::std::option::Option::None;
    }

    pub fn has_shuffle(&self) -> bool {
        self.shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle(&mut self, v: bool) {
        self.shuffle = ::std::option::Option::Some(v);
    }

    // optional bool repeat = 5;

    pub fn repeat(&self) -> bool {
        self.repeat.unwrap_or(false)
    }

    pub fn clear_repeat(&mut self) {
        self.repeat = ::std::option::Option::None;
    }

    pub fn has_repeat(&self) -> bool {
        self.repeat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat(&mut self, v: bool) {
        self.repeat = ::std::option::Option::Some(v);
    }

    // optional bool repeat_one = 6;

    pub fn repeat_one(&self) -> bool {
        self.repeat_one.unwrap_or(false)
    }

    pub fn clear_repeat_one(&mut self) {
        self.repeat_one = ::std::option::Option::None;
    }

    pub fn has_repeat_one(&self) -> bool {
        self.repeat_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat_one(&mut self, v: bool) {
        self.repeat_one = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &MediaPlaybackStatus| { &m.state },
            |m: &mut MediaPlaybackStatus| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "media_source",
            |m: &MediaPlaybackStatus| { &m.media_source },
            |m: &mut MediaPlaybackStatus| { &mut m.media_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playback_seconds",
            |m: &MediaPlaybackStatus| { &m.playback_seconds },
            |m: &mut MediaPlaybackStatus| { &mut m.playback_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shuffle",
            |m: &MediaPlaybackStatus| { &m.shuffle },
            |m: &mut MediaPlaybackStatus| { &mut m.shuffle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repeat",
            |m: &MediaPlaybackStatus| { &m.repeat },
            |m: &mut MediaPlaybackStatus| { &mut m.repeat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repeat_one",
            |m: &MediaPlaybackStatus| { &m.repeat_one },
            |m: &mut MediaPlaybackStatus| { &mut m.repeat_one },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlaybackStatus>(
            "MediaPlaybackStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlaybackStatus {
    const NAME: &'static str = "MediaPlaybackStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.media_source = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.playback_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.shuffle = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.repeat = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.repeat_one = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.media_source.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.playback_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.shuffle {
            my_size += 1 + 1;
        }
        if let Some(v) = self.repeat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.repeat_one {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.media_source.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.playback_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.shuffle {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.repeat {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.repeat_one {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlaybackStatus {
        MediaPlaybackStatus::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.media_source = ::std::option::Option::None;
        self.playback_seconds = ::std::option::Option::None;
        self.shuffle = ::std::option::Option::None;
        self.repeat = ::std::option::Option::None;
        self.repeat_one = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlaybackStatus {
        static instance: MediaPlaybackStatus = MediaPlaybackStatus {
            state: ::std::option::Option::None,
            media_source: ::std::option::Option::None,
            playback_seconds: ::std::option::Option::None,
            shuffle: ::std::option::Option::None,
            repeat: ::std::option::Option::None,
            repeat_one: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlaybackStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlaybackStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaPlaybackStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlaybackStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MediaPlaybackStatus`
pub mod media_playback_status {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MediaPlaybackStatus.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:MediaPlaybackStatus.State.STOPPED)
        STOPPED = 1,
        // @@protoc_insertion_point(enum_value:MediaPlaybackStatus.State.PLAYING)
        PLAYING = 2,
        // @@protoc_insertion_point(enum_value:MediaPlaybackStatus.State.PAUSED)
        PAUSED = 3,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                1 => ::std::option::Option::Some(State::STOPPED),
                2 => ::std::option::Option::Some(State::PLAYING),
                3 => ::std::option::Option::Some(State::PAUSED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "STOPPED" => ::std::option::Option::Some(State::STOPPED),
                "PLAYING" => ::std::option::Option::Some(State::PLAYING),
                "PAUSED" => ::std::option::Option::Some(State::PAUSED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::STOPPED,
            State::PLAYING,
            State::PAUSED,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MediaPlaybackStatus.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                State::STOPPED => 0,
                State::PLAYING => 1,
                State::PAUSED => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for State {
        fn default() -> Self {
            State::STOPPED
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("MediaPlaybackStatus.State")
        }
    }
}

// @@protoc_insertion_point(message:MediaPlaybackMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaPlaybackMetadata {
    // message fields
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.song)
    pub song: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.artist)
    pub artist: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.album)
    pub album: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.album_art)
    pub album_art: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.playlist)
    pub playlist: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.duration_seconds)
    pub duration_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MediaPlaybackMetadata.rating)
    pub rating: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlaybackMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaPlaybackMetadata {
    fn default() -> &'a MediaPlaybackMetadata {
        <MediaPlaybackMetadata as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlaybackMetadata {
    pub fn new() -> MediaPlaybackMetadata {
        ::std::default::Default::default()
    }

    // optional string song = 1;

    pub fn song(&self) -> &str {
        match self.song.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_song(&mut self) {
        self.song = ::std::option::Option::None;
    }

    pub fn has_song(&self) -> bool {
        self.song.is_some()
    }

    // Param is passed by value, moved
    pub fn set_song(&mut self, v: ::std::string::String) {
        self.song = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_song(&mut self) -> &mut ::std::string::String {
        if self.song.is_none() {
            self.song = ::std::option::Option::Some(::std::string::String::new());
        }
        self.song.as_mut().unwrap()
    }

    // Take field
    pub fn take_song(&mut self) -> ::std::string::String {
        self.song.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string artist = 2;

    pub fn artist(&self) -> &str {
        match self.artist.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_artist(&mut self) {
        self.artist = ::std::option::Option::None;
    }

    pub fn has_artist(&self) -> bool {
        self.artist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::std::string::String) {
        self.artist = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist(&mut self) -> &mut ::std::string::String {
        if self.artist.is_none() {
            self.artist = ::std::option::Option::Some(::std::string::String::new());
        }
        self.artist.as_mut().unwrap()
    }

    // Take field
    pub fn take_artist(&mut self) -> ::std::string::String {
        self.artist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string album = 3;

    pub fn album(&self) -> &str {
        match self.album.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_album(&mut self) {
        self.album = ::std::option::Option::None;
    }

    pub fn has_album(&self) -> bool {
        self.album.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album(&mut self, v: ::std::string::String) {
        self.album = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album(&mut self) -> &mut ::std::string::String {
        if self.album.is_none() {
            self.album = ::std::option::Option::Some(::std::string::String::new());
        }
        self.album.as_mut().unwrap()
    }

    // Take field
    pub fn take_album(&mut self) -> ::std::string::String {
        self.album.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes album_art = 4;

    pub fn album_art(&self) -> &[u8] {
        match self.album_art.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_album_art(&mut self) {
        self.album_art = ::std::option::Option::None;
    }

    pub fn has_album_art(&self) -> bool {
        self.album_art.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album_art(&mut self, v: ::std::vec::Vec<u8>) {
        self.album_art = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album_art(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.album_art.is_none() {
            self.album_art = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.album_art.as_mut().unwrap()
    }

    // Take field
    pub fn take_album_art(&mut self) -> ::std::vec::Vec<u8> {
        self.album_art.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string playlist = 5;

    pub fn playlist(&self) -> &str {
        match self.playlist.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_playlist(&mut self) {
        self.playlist = ::std::option::Option::None;
    }

    pub fn has_playlist(&self) -> bool {
        self.playlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playlist(&mut self, v: ::std::string::String) {
        self.playlist = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playlist(&mut self) -> &mut ::std::string::String {
        if self.playlist.is_none() {
            self.playlist = ::std::option::Option::Some(::std::string::String::new());
        }
        self.playlist.as_mut().unwrap()
    }

    // Take field
    pub fn take_playlist(&mut self) -> ::std::string::String {
        self.playlist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 duration_seconds = 6;

    pub fn duration_seconds(&self) -> u32 {
        self.duration_seconds.unwrap_or(0)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: u32) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 rating = 7;

    pub fn rating(&self) -> i32 {
        self.rating.unwrap_or(0)
    }

    pub fn clear_rating(&mut self) {
        self.rating = ::std::option::Option::None;
    }

    pub fn has_rating(&self) -> bool {
        self.rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: i32) {
        self.rating = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "song",
            |m: &MediaPlaybackMetadata| { &m.song },
            |m: &mut MediaPlaybackMetadata| { &mut m.song },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "artist",
            |m: &MediaPlaybackMetadata| { &m.artist },
            |m: &mut MediaPlaybackMetadata| { &mut m.artist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album",
            |m: &MediaPlaybackMetadata| { &m.album },
            |m: &mut MediaPlaybackMetadata| { &mut m.album },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album_art",
            |m: &MediaPlaybackMetadata| { &m.album_art },
            |m: &mut MediaPlaybackMetadata| { &mut m.album_art },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playlist",
            |m: &MediaPlaybackMetadata| { &m.playlist },
            |m: &mut MediaPlaybackMetadata| { &mut m.playlist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_seconds",
            |m: &MediaPlaybackMetadata| { &m.duration_seconds },
            |m: &mut MediaPlaybackMetadata| { &mut m.duration_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating",
            |m: &MediaPlaybackMetadata| { &m.rating },
            |m: &mut MediaPlaybackMetadata| { &mut m.rating },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlaybackMetadata>(
            "MediaPlaybackMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlaybackMetadata {
    const NAME: &'static str = "MediaPlaybackMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.song = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.artist = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.album = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.album_art = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.playlist = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rating = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.song.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.artist.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.album.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.album_art.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.playlist.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.duration_seconds {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rating {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.song.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.artist.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.album.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.album_art.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.playlist.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rating {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlaybackMetadata {
        MediaPlaybackMetadata::new()
    }

    fn clear(&mut self) {
        self.song = ::std::option::Option::None;
        self.artist = ::std::option::Option::None;
        self.album = ::std::option::Option::None;
        self.album_art = ::std::option::Option::None;
        self.playlist = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.rating = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlaybackMetadata {
        static instance: MediaPlaybackMetadata = MediaPlaybackMetadata {
            song: ::std::option::Option::None,
            artist: ::std::option::Option::None,
            album: ::std::option::Option::None,
            album_art: ::std::option::Option::None,
            playlist: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            rating: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlaybackMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlaybackMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaPlaybackMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlaybackMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PhoneStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PhoneStatus {
    // message fields
    // @@protoc_insertion_point(field:PhoneStatus.calls)
    pub calls: ::std::vec::Vec<phone_status::Call>,
    // @@protoc_insertion_point(field:PhoneStatus.signal_strength)
    pub signal_strength: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PhoneStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhoneStatus {
    fn default() -> &'a PhoneStatus {
        <PhoneStatus as ::protobuf::Message>::default_instance()
    }
}

impl PhoneStatus {
    pub fn new() -> PhoneStatus {
        ::std::default::Default::default()
    }

    // optional uint32 signal_strength = 2;

    pub fn signal_strength(&self) -> u32 {
        self.signal_strength.unwrap_or(0)
    }

    pub fn clear_signal_strength(&mut self) {
        self.signal_strength = ::std::option::Option::None;
    }

    pub fn has_signal_strength(&self) -> bool {
        self.signal_strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signal_strength(&mut self, v: u32) {
        self.signal_strength = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "calls",
            |m: &PhoneStatus| { &m.calls },
            |m: &mut PhoneStatus| { &mut m.calls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signal_strength",
            |m: &PhoneStatus| { &m.signal_strength },
            |m: &mut PhoneStatus| { &mut m.signal_strength },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhoneStatus>(
            "PhoneStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhoneStatus {
    const NAME: &'static str = "PhoneStatus";

    fn is_initialized(&self) -> bool {
        for v in &self.calls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.calls.push(is.read_message()?);
                },
                16 => {
                    self.signal_strength = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.calls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.signal_strength {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.calls {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.signal_strength {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhoneStatus {
        PhoneStatus::new()
    }

    fn clear(&mut self) {
        self.calls.clear();
        self.signal_strength = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhoneStatus {
        static instance: PhoneStatus = PhoneStatus {
            calls: ::std::vec::Vec::new(),
            signal_strength: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhoneStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhoneStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhoneStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PhoneStatus`
pub mod phone_status {
    // @@protoc_insertion_point(message:PhoneStatus.Call)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Call {
        // message fields
        // @@protoc_insertion_point(field:PhoneStatus.Call.phone_state)
        pub phone_state: ::std::option::Option<::protobuf::EnumOrUnknown<State>>,
        // @@protoc_insertion_point(field:PhoneStatus.Call.call_duration_seconds)
        pub call_duration_seconds: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:PhoneStatus.Call.caller_number)
        pub caller_number: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:PhoneStatus.Call.caller_id)
        pub caller_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:PhoneStatus.Call.caller_number_type)
        pub caller_number_type: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:PhoneStatus.Call.caller_thumbnail)
        pub caller_thumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:PhoneStatus.Call.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Call {
        fn default() -> &'a Call {
            <Call as ::protobuf::Message>::default_instance()
        }
    }

    impl Call {
        pub fn new() -> Call {
            ::std::default::Default::default()
        }

        // required .PhoneStatus.State phone_state = 1;

        pub fn phone_state(&self) -> State {
            match self.phone_state {
                Some(e) => e.enum_value_or(State::UNKNOWN),
                None => State::UNKNOWN,
            }
        }

        pub fn clear_phone_state(&mut self) {
            self.phone_state = ::std::option::Option::None;
        }

        pub fn has_phone_state(&self) -> bool {
            self.phone_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phone_state(&mut self, v: State) {
            self.phone_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // required uint32 call_duration_seconds = 2;

        pub fn call_duration_seconds(&self) -> u32 {
            self.call_duration_seconds.unwrap_or(0)
        }

        pub fn clear_call_duration_seconds(&mut self) {
            self.call_duration_seconds = ::std::option::Option::None;
        }

        pub fn has_call_duration_seconds(&self) -> bool {
            self.call_duration_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_call_duration_seconds(&mut self, v: u32) {
            self.call_duration_seconds = ::std::option::Option::Some(v);
        }

        // optional string caller_number = 3;

        pub fn caller_number(&self) -> &str {
            match self.caller_number.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_caller_number(&mut self) {
            self.caller_number = ::std::option::Option::None;
        }

        pub fn has_caller_number(&self) -> bool {
            self.caller_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caller_number(&mut self, v: ::std::string::String) {
            self.caller_number = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_caller_number(&mut self) -> &mut ::std::string::String {
            if self.caller_number.is_none() {
                self.caller_number = ::std::option::Option::Some(::std::string::String::new());
            }
            self.caller_number.as_mut().unwrap()
        }

        // Take field
        pub fn take_caller_number(&mut self) -> ::std::string::String {
            self.caller_number.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string caller_id = 4;

        pub fn caller_id(&self) -> &str {
            match self.caller_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_caller_id(&mut self) {
            self.caller_id = ::std::option::Option::None;
        }

        pub fn has_caller_id(&self) -> bool {
            self.caller_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caller_id(&mut self, v: ::std::string::String) {
            self.caller_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_caller_id(&mut self) -> &mut ::std::string::String {
            if self.caller_id.is_none() {
                self.caller_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.caller_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_caller_id(&mut self) -> ::std::string::String {
            self.caller_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string caller_number_type = 5;

        pub fn caller_number_type(&self) -> &str {
            match self.caller_number_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_caller_number_type(&mut self) {
            self.caller_number_type = ::std::option::Option::None;
        }

        pub fn has_caller_number_type(&self) -> bool {
            self.caller_number_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caller_number_type(&mut self, v: ::std::string::String) {
            self.caller_number_type = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_caller_number_type(&mut self) -> &mut ::std::string::String {
            if self.caller_number_type.is_none() {
                self.caller_number_type = ::std::option::Option::Some(::std::string::String::new());
            }
            self.caller_number_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_caller_number_type(&mut self) -> ::std::string::String {
            self.caller_number_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes caller_thumbnail = 6;

        pub fn caller_thumbnail(&self) -> &[u8] {
            match self.caller_thumbnail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_caller_thumbnail(&mut self) {
            self.caller_thumbnail = ::std::option::Option::None;
        }

        pub fn has_caller_thumbnail(&self) -> bool {
            self.caller_thumbnail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caller_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
            self.caller_thumbnail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_caller_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.caller_thumbnail.is_none() {
                self.caller_thumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.caller_thumbnail.as_mut().unwrap()
        }

        // Take field
        pub fn take_caller_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
            self.caller_thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "phone_state",
                |m: &Call| { &m.phone_state },
                |m: &mut Call| { &mut m.phone_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "call_duration_seconds",
                |m: &Call| { &m.call_duration_seconds },
                |m: &mut Call| { &mut m.call_duration_seconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "caller_number",
                |m: &Call| { &m.caller_number },
                |m: &mut Call| { &mut m.caller_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "caller_id",
                |m: &Call| { &m.caller_id },
                |m: &mut Call| { &mut m.caller_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "caller_number_type",
                |m: &Call| { &m.caller_number_type },
                |m: &mut Call| { &mut m.caller_number_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "caller_thumbnail",
                |m: &Call| { &m.caller_thumbnail },
                |m: &mut Call| { &mut m.caller_thumbnail },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Call>(
                "PhoneStatus.Call",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Call {
        const NAME: &'static str = "Call";

        fn is_initialized(&self) -> bool {
            if self.phone_state.is_none() {
                return false;
            }
            if self.call_duration_seconds.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.phone_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.call_duration_seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.caller_number = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.caller_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.caller_number_type = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.caller_thumbnail = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.phone_state {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.call_duration_seconds {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.caller_number.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.caller_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.caller_number_type.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.caller_thumbnail.as_ref() {
                my_size += ::protobuf::rt::bytes_size(6, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.phone_state {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.call_duration_seconds {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.caller_number.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.caller_id.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.caller_number_type.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.caller_thumbnail.as_ref() {
                os.write_bytes(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Call {
            Call::new()
        }

        fn clear(&mut self) {
            self.phone_state = ::std::option::Option::None;
            self.call_duration_seconds = ::std::option::Option::None;
            self.caller_number = ::std::option::Option::None;
            self.caller_id = ::std::option::Option::None;
            self.caller_number_type = ::std::option::Option::None;
            self.caller_thumbnail = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Call {
            static instance: Call = Call {
                phone_state: ::std::option::Option::None,
                call_duration_seconds: ::std::option::Option::None,
                caller_number: ::std::option::Option::None,
                caller_id: ::std::option::Option::None,
                caller_number_type: ::std::option::Option::None,
                caller_thumbnail: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Call {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PhoneStatus.Call").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Call {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Call {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:PhoneStatus.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.IN_CALL)
        IN_CALL = 1,
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.ON_HOLD)
        ON_HOLD = 2,
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.INACTIVE)
        INACTIVE = 3,
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.INCOMING)
        INCOMING = 4,
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.CONFERENCED)
        CONFERENCED = 5,
        // @@protoc_insertion_point(enum_value:PhoneStatus.State.MUTED)
        MUTED = 6,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::UNKNOWN),
                1 => ::std::option::Option::Some(State::IN_CALL),
                2 => ::std::option::Option::Some(State::ON_HOLD),
                3 => ::std::option::Option::Some(State::INACTIVE),
                4 => ::std::option::Option::Some(State::INCOMING),
                5 => ::std::option::Option::Some(State::CONFERENCED),
                6 => ::std::option::Option::Some(State::MUTED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(State::UNKNOWN),
                "IN_CALL" => ::std::option::Option::Some(State::IN_CALL),
                "ON_HOLD" => ::std::option::Option::Some(State::ON_HOLD),
                "INACTIVE" => ::std::option::Option::Some(State::INACTIVE),
                "INCOMING" => ::std::option::Option::Some(State::INCOMING),
                "CONFERENCED" => ::std::option::Option::Some(State::CONFERENCED),
                "MUTED" => ::std::option::Option::Some(State::MUTED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::UNKNOWN,
            State::IN_CALL,
            State::ON_HOLD,
            State::INACTIVE,
            State::INCOMING,
            State::CONFERENCED,
            State::MUTED,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PhoneStatus.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::UNKNOWN
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("PhoneStatus.State")
        }
    }
}

// @@protoc_insertion_point(message:PhoneStatusInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PhoneStatusInput {
    // message fields
    // @@protoc_insertion_point(field:PhoneStatusInput.input)
    pub input: ::protobuf::MessageField<InstrumentClusterInput>,
    // @@protoc_insertion_point(field:PhoneStatusInput.caller_number)
    pub caller_number: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:PhoneStatusInput.caller_id)
    pub caller_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:PhoneStatusInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhoneStatusInput {
    fn default() -> &'a PhoneStatusInput {
        <PhoneStatusInput as ::protobuf::Message>::default_instance()
    }
}

impl PhoneStatusInput {
    pub fn new() -> PhoneStatusInput {
        ::std::default::Default::default()
    }

    // optional string caller_number = 2;

    pub fn caller_number(&self) -> &str {
        match self.caller_number.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caller_number(&mut self) {
        self.caller_number = ::std::option::Option::None;
    }

    pub fn has_caller_number(&self) -> bool {
        self.caller_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_number(&mut self, v: ::std::string::String) {
        self.caller_number = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller_number(&mut self) -> &mut ::std::string::String {
        if self.caller_number.is_none() {
            self.caller_number = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caller_number.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller_number(&mut self) -> ::std::string::String {
        self.caller_number.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caller_id = 3;

    pub fn caller_id(&self) -> &str {
        match self.caller_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: ::std::string::String) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller_id(&mut self) -> &mut ::std::string::String {
        if self.caller_id.is_none() {
            self.caller_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caller_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller_id(&mut self) -> ::std::string::String {
        self.caller_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InstrumentClusterInput>(
            "input",
            |m: &PhoneStatusInput| { &m.input },
            |m: &mut PhoneStatusInput| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_number",
            |m: &PhoneStatusInput| { &m.caller_number },
            |m: &mut PhoneStatusInput| { &mut m.caller_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caller_id",
            |m: &PhoneStatusInput| { &m.caller_id },
            |m: &mut PhoneStatusInput| { &mut m.caller_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhoneStatusInput>(
            "PhoneStatusInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhoneStatusInput {
    const NAME: &'static str = "PhoneStatusInput";

    fn is_initialized(&self) -> bool {
        if self.input.is_none() {
            return false;
        }
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                18 => {
                    self.caller_number = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caller_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.caller_number.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caller_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.caller_number.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caller_id.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhoneStatusInput {
        PhoneStatusInput::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.caller_number = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhoneStatusInput {
        static instance: PhoneStatusInput = PhoneStatusInput {
            input: ::protobuf::MessageField::none(),
            caller_number: ::std::option::Option::None,
            caller_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhoneStatusInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhoneStatusInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhoneStatusInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStatusInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaRootNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaRootNode {
    // message fields
    // @@protoc_insertion_point(field:MediaRootNode.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaRootNode.media_sources)
    pub media_sources: ::std::vec::Vec<MediaSource>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaRootNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaRootNode {
    fn default() -> &'a MediaRootNode {
        <MediaRootNode as ::protobuf::Message>::default_instance()
    }
}

impl MediaRootNode {
    pub fn new() -> MediaRootNode {
        ::std::default::Default::default()
    }

    // required string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &MediaRootNode| { &m.path },
            |m: &mut MediaRootNode| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "media_sources",
            |m: &MediaRootNode| { &m.media_sources },
            |m: &mut MediaRootNode| { &mut m.media_sources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaRootNode>(
            "MediaRootNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaRootNode {
    const NAME: &'static str = "MediaRootNode";

    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        for v in &self.media_sources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.media_sources.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.media_sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.media_sources {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaRootNode {
        MediaRootNode::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.media_sources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaRootNode {
        static instance: MediaRootNode = MediaRootNode {
            path: ::std::option::Option::None,
            media_sources: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaRootNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaRootNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaRootNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaRootNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaSource {
    // message fields
    // @@protoc_insertion_point(field:MediaSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaSource.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaSource.album_art)
    pub album_art: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaSource {
    fn default() -> &'a MediaSource {
        <MediaSource as ::protobuf::Message>::default_instance()
    }
}

impl MediaSource {
    pub fn new() -> MediaSource {
        ::std::default::Default::default()
    }

    // required string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes album_art = 3;

    pub fn album_art(&self) -> &[u8] {
        match self.album_art.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_album_art(&mut self) {
        self.album_art = ::std::option::Option::None;
    }

    pub fn has_album_art(&self) -> bool {
        self.album_art.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album_art(&mut self, v: ::std::vec::Vec<u8>) {
        self.album_art = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album_art(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.album_art.is_none() {
            self.album_art = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.album_art.as_mut().unwrap()
    }

    // Take field
    pub fn take_album_art(&mut self) -> ::std::vec::Vec<u8> {
        self.album_art.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &MediaSource| { &m.path },
            |m: &mut MediaSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MediaSource| { &m.name },
            |m: &mut MediaSource| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album_art",
            |m: &MediaSource| { &m.album_art },
            |m: &mut MediaSource| { &mut m.album_art },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaSource>(
            "MediaSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaSource {
    const NAME: &'static str = "MediaSource";

    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.album_art = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.album_art.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.album_art.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaSource {
        MediaSource::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.album_art = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaSource {
        static instance: MediaSource = MediaSource {
            path: ::std::option::Option::None,
            name: ::std::option::Option::None,
            album_art: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaSourceNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaSourceNode {
    // message fields
    // @@protoc_insertion_point(field:MediaSourceNode.source)
    pub source: ::protobuf::MessageField<MediaSource>,
    // @@protoc_insertion_point(field:MediaSourceNode.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MediaSourceNode.total)
    pub total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MediaSourceNode.lists)
    pub lists: ::std::vec::Vec<MediaList>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaSourceNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaSourceNode {
    fn default() -> &'a MediaSourceNode {
        <MediaSourceNode as ::protobuf::Message>::default_instance()
    }
}

impl MediaSourceNode {
    pub fn new() -> MediaSourceNode {
        ::std::default::Default::default()
    }

    // optional int32 start = 2;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 total = 3;

    pub fn total(&self) -> i32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaSource>(
            "source",
            |m: &MediaSourceNode| { &m.source },
            |m: &mut MediaSourceNode| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &MediaSourceNode| { &m.start },
            |m: &mut MediaSourceNode| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total",
            |m: &MediaSourceNode| { &m.total },
            |m: &mut MediaSourceNode| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &MediaSourceNode| { &m.lists },
            |m: &mut MediaSourceNode| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaSourceNode>(
            "MediaSourceNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaSourceNode {
    const NAME: &'static str = "MediaSourceNode";

    fn is_initialized(&self) -> bool {
        if self.source.is_none() {
            return false;
        }
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lists {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                16 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.total = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.total {
            os.write_int32(3, v)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaSourceNode {
        MediaSourceNode::new()
    }

    fn clear(&mut self) {
        self.source.clear();
        self.start = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaSourceNode {
        static instance: MediaSourceNode = MediaSourceNode {
            source: ::protobuf::MessageField::none(),
            start: ::std::option::Option::None,
            total: ::std::option::Option::None,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaSourceNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaSourceNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaSourceNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaSourceNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaList {
    // message fields
    // @@protoc_insertion_point(field:MediaList.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaList.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<media_list::Type>>,
    // @@protoc_insertion_point(field:MediaList.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaList.album_art)
    pub album_art: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaList {
    fn default() -> &'a MediaList {
        <MediaList as ::protobuf::Message>::default_instance()
    }
}

impl MediaList {
    pub fn new() -> MediaList {
        ::std::default::Default::default()
    }

    // required string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .MediaList.Type type = 2;

    pub fn type_(&self) -> media_list::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(media_list::Type::UNKNOWN),
            None => media_list::Type::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: media_list::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes album_art = 4;

    pub fn album_art(&self) -> &[u8] {
        match self.album_art.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_album_art(&mut self) {
        self.album_art = ::std::option::Option::None;
    }

    pub fn has_album_art(&self) -> bool {
        self.album_art.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album_art(&mut self, v: ::std::vec::Vec<u8>) {
        self.album_art = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album_art(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.album_art.is_none() {
            self.album_art = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.album_art.as_mut().unwrap()
    }

    // Take field
    pub fn take_album_art(&mut self) -> ::std::vec::Vec<u8> {
        self.album_art.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &MediaList| { &m.path },
            |m: &mut MediaList| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &MediaList| { &m.type_ },
            |m: &mut MediaList| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MediaList| { &m.name },
            |m: &mut MediaList| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album_art",
            |m: &MediaList| { &m.album_art },
            |m: &mut MediaList| { &mut m.album_art },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaList>(
            "MediaList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaList {
    const NAME: &'static str = "MediaList";

    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.album_art = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.album_art.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.album_art.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaList {
        MediaList::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.album_art = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaList {
        static instance: MediaList = MediaList {
            path: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            name: ::std::option::Option::None,
            album_art: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MediaList`
pub mod media_list {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MediaList.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:MediaList.Type.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:MediaList.Type.PLAYLIST)
        PLAYLIST = 1,
        // @@protoc_insertion_point(enum_value:MediaList.Type.ALBUM)
        ALBUM = 2,
        // @@protoc_insertion_point(enum_value:MediaList.Type.ARTIST)
        ARTIST = 3,
        // @@protoc_insertion_point(enum_value:MediaList.Type.STATION)
        STATION = 4,
        // @@protoc_insertion_point(enum_value:MediaList.Type.GENRE)
        GENRE = 5,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::UNKNOWN),
                1 => ::std::option::Option::Some(Type::PLAYLIST),
                2 => ::std::option::Option::Some(Type::ALBUM),
                3 => ::std::option::Option::Some(Type::ARTIST),
                4 => ::std::option::Option::Some(Type::STATION),
                5 => ::std::option::Option::Some(Type::GENRE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(Type::UNKNOWN),
                "PLAYLIST" => ::std::option::Option::Some(Type::PLAYLIST),
                "ALBUM" => ::std::option::Option::Some(Type::ALBUM),
                "ARTIST" => ::std::option::Option::Some(Type::ARTIST),
                "STATION" => ::std::option::Option::Some(Type::STATION),
                "GENRE" => ::std::option::Option::Some(Type::GENRE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::UNKNOWN,
            Type::PLAYLIST,
            Type::ALBUM,
            Type::ARTIST,
            Type::STATION,
            Type::GENRE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MediaList.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::UNKNOWN
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("MediaList.Type")
        }
    }
}

// @@protoc_insertion_point(message:MediaListNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaListNode {
    // message fields
    // @@protoc_insertion_point(field:MediaListNode.list)
    pub list: ::protobuf::MessageField<MediaList>,
    // @@protoc_insertion_point(field:MediaListNode.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MediaListNode.total)
    pub total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MediaListNode.songs)
    pub songs: ::std::vec::Vec<MediaSong>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaListNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaListNode {
    fn default() -> &'a MediaListNode {
        <MediaListNode as ::protobuf::Message>::default_instance()
    }
}

impl MediaListNode {
    pub fn new() -> MediaListNode {
        ::std::default::Default::default()
    }

    // optional int32 start = 2;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 total = 3;

    pub fn total(&self) -> i32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaList>(
            "list",
            |m: &MediaListNode| { &m.list },
            |m: &mut MediaListNode| { &mut m.list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &MediaListNode| { &m.start },
            |m: &mut MediaListNode| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total",
            |m: &MediaListNode| { &m.total },
            |m: &mut MediaListNode| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "songs",
            |m: &MediaListNode| { &m.songs },
            |m: &mut MediaListNode| { &mut m.songs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaListNode>(
            "MediaListNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaListNode {
    const NAME: &'static str = "MediaListNode";

    fn is_initialized(&self) -> bool {
        if self.list.is_none() {
            return false;
        }
        for v in &self.list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.songs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.list)?;
                },
                16 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.total = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.songs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.songs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.total {
            os.write_int32(3, v)?;
        }
        for v in &self.songs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaListNode {
        MediaListNode::new()
    }

    fn clear(&mut self) {
        self.list.clear();
        self.start = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.songs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaListNode {
        static instance: MediaListNode = MediaListNode {
            list: ::protobuf::MessageField::none(),
            start: ::std::option::Option::None,
            total: ::std::option::Option::None,
            songs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaListNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaListNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaListNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaListNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaSong)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaSong {
    // message fields
    // @@protoc_insertion_point(field:MediaSong.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaSong.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaSong.artist)
    pub artist: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaSong.album)
    pub album: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaSong.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaSong {
    fn default() -> &'a MediaSong {
        <MediaSong as ::protobuf::Message>::default_instance()
    }
}

impl MediaSong {
    pub fn new() -> MediaSong {
        ::std::default::Default::default()
    }

    // required string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string artist = 3;

    pub fn artist(&self) -> &str {
        match self.artist.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_artist(&mut self) {
        self.artist = ::std::option::Option::None;
    }

    pub fn has_artist(&self) -> bool {
        self.artist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::std::string::String) {
        self.artist = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist(&mut self) -> &mut ::std::string::String {
        if self.artist.is_none() {
            self.artist = ::std::option::Option::Some(::std::string::String::new());
        }
        self.artist.as_mut().unwrap()
    }

    // Take field
    pub fn take_artist(&mut self) -> ::std::string::String {
        self.artist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string album = 4;

    pub fn album(&self) -> &str {
        match self.album.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_album(&mut self) {
        self.album = ::std::option::Option::None;
    }

    pub fn has_album(&self) -> bool {
        self.album.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album(&mut self, v: ::std::string::String) {
        self.album = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album(&mut self) -> &mut ::std::string::String {
        if self.album.is_none() {
            self.album = ::std::option::Option::Some(::std::string::String::new());
        }
        self.album.as_mut().unwrap()
    }

    // Take field
    pub fn take_album(&mut self) -> ::std::string::String {
        self.album.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &MediaSong| { &m.path },
            |m: &mut MediaSong| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MediaSong| { &m.name },
            |m: &mut MediaSong| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "artist",
            |m: &MediaSong| { &m.artist },
            |m: &mut MediaSong| { &mut m.artist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album",
            |m: &MediaSong| { &m.album },
            |m: &mut MediaSong| { &mut m.album },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaSong>(
            "MediaSong",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaSong {
    const NAME: &'static str = "MediaSong";

    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.artist = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.album = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.artist.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.album.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.artist.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.album.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaSong {
        MediaSong::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.artist = ::std::option::Option::None;
        self.album = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaSong {
        static instance: MediaSong = MediaSong {
            path: ::std::option::Option::None,
            name: ::std::option::Option::None,
            artist: ::std::option::Option::None,
            album: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaSong {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaSong").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaSong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaSong {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaSongNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaSongNode {
    // message fields
    // @@protoc_insertion_point(field:MediaSongNode.song)
    pub song: ::protobuf::MessageField<MediaSong>,
    // @@protoc_insertion_point(field:MediaSongNode.album_art)
    pub album_art: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MediaSongNode.duration_seconds)
    pub duration_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaSongNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaSongNode {
    fn default() -> &'a MediaSongNode {
        <MediaSongNode as ::protobuf::Message>::default_instance()
    }
}

impl MediaSongNode {
    pub fn new() -> MediaSongNode {
        ::std::default::Default::default()
    }

    // optional bytes album_art = 2;

    pub fn album_art(&self) -> &[u8] {
        match self.album_art.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_album_art(&mut self) {
        self.album_art = ::std::option::Option::None;
    }

    pub fn has_album_art(&self) -> bool {
        self.album_art.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album_art(&mut self, v: ::std::vec::Vec<u8>) {
        self.album_art = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album_art(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.album_art.is_none() {
            self.album_art = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.album_art.as_mut().unwrap()
    }

    // Take field
    pub fn take_album_art(&mut self) -> ::std::vec::Vec<u8> {
        self.album_art.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 duration_seconds = 3;

    pub fn duration_seconds(&self) -> u32 {
        self.duration_seconds.unwrap_or(0)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: u32) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaSong>(
            "song",
            |m: &MediaSongNode| { &m.song },
            |m: &mut MediaSongNode| { &mut m.song },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "album_art",
            |m: &MediaSongNode| { &m.album_art },
            |m: &mut MediaSongNode| { &mut m.album_art },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_seconds",
            |m: &MediaSongNode| { &m.duration_seconds },
            |m: &mut MediaSongNode| { &mut m.duration_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaSongNode>(
            "MediaSongNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaSongNode {
    const NAME: &'static str = "MediaSongNode";

    fn is_initialized(&self) -> bool {
        if self.song.is_none() {
            return false;
        }
        for v in &self.song {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.song)?;
                },
                18 => {
                    self.album_art = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.song.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.album_art.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.duration_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.song.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.album_art.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaSongNode {
        MediaSongNode::new()
    }

    fn clear(&mut self) {
        self.song.clear();
        self.album_art = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaSongNode {
        static instance: MediaSongNode = MediaSongNode {
            song: ::protobuf::MessageField::none(),
            album_art: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaSongNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaSongNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaSongNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaSongNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaGetNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaGetNode {
    // message fields
    // @@protoc_insertion_point(field:MediaGetNode.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaGetNode.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MediaGetNode.get_album_art)
    pub get_album_art: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaGetNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaGetNode {
    fn default() -> &'a MediaGetNode {
        <MediaGetNode as ::protobuf::Message>::default_instance()
    }
}

impl MediaGetNode {
    pub fn new() -> MediaGetNode {
        ::std::default::Default::default()
    }

    // required string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 start = 2;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional bool get_album_art = 3;

    pub fn get_album_art(&self) -> bool {
        self.get_album_art.unwrap_or(true)
    }

    pub fn clear_get_album_art(&mut self) {
        self.get_album_art = ::std::option::Option::None;
    }

    pub fn has_get_album_art(&self) -> bool {
        self.get_album_art.is_some()
    }

    // Param is passed by value, moved
    pub fn set_get_album_art(&mut self, v: bool) {
        self.get_album_art = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &MediaGetNode| { &m.path },
            |m: &mut MediaGetNode| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &MediaGetNode| { &m.start },
            |m: &mut MediaGetNode| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "get_album_art",
            |m: &MediaGetNode| { &m.get_album_art },
            |m: &mut MediaGetNode| { &mut m.get_album_art },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaGetNode>(
            "MediaGetNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaGetNode {
    const NAME: &'static str = "MediaGetNode";

    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.get_album_art = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.get_album_art {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.get_album_art {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaGetNode {
        MediaGetNode::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.get_album_art = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaGetNode {
        static instance: MediaGetNode = MediaGetNode {
            path: ::std::option::Option::None,
            start: ::std::option::Option::None,
            get_album_art: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaGetNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaGetNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaGetNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaGetNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaBrowserInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaBrowserInput {
    // message fields
    // @@protoc_insertion_point(field:MediaBrowserInput.input)
    pub input: ::protobuf::MessageField<InstrumentClusterInput>,
    // @@protoc_insertion_point(field:MediaBrowserInput.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaBrowserInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaBrowserInput {
    fn default() -> &'a MediaBrowserInput {
        <MediaBrowserInput as ::protobuf::Message>::default_instance()
    }
}

impl MediaBrowserInput {
    pub fn new() -> MediaBrowserInput {
        ::std::default::Default::default()
    }

    // required string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InstrumentClusterInput>(
            "input",
            |m: &MediaBrowserInput| { &m.input },
            |m: &mut MediaBrowserInput| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &MediaBrowserInput| { &m.path },
            |m: &mut MediaBrowserInput| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaBrowserInput>(
            "MediaBrowserInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaBrowserInput {
    const NAME: &'static str = "MediaBrowserInput";

    fn is_initialized(&self) -> bool {
        if self.input.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaBrowserInput {
        MediaBrowserInput::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaBrowserInput {
        static instance: MediaBrowserInput = MediaBrowserInput {
            input: ::protobuf::MessageField::none(),
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaBrowserInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaBrowserInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaBrowserInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaBrowserInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationSetSensor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationSetSensor {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationSetSensor.sensors)
    pub sensors: ::protobuf::MessageField<SensorBatch>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationSetSensor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationSetSensor {
    fn default() -> &'a GalVerificationSetSensor {
        <GalVerificationSetSensor as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationSetSensor {
    pub fn new() -> GalVerificationSetSensor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SensorBatch>(
            "sensors",
            |m: &GalVerificationSetSensor| { &m.sensors },
            |m: &mut GalVerificationSetSensor| { &mut m.sensors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationSetSensor>(
            "GalVerificationSetSensor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationSetSensor {
    const NAME: &'static str = "GalVerificationSetSensor";

    fn is_initialized(&self) -> bool {
        for v in &self.sensors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sensors)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sensors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sensors.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationSetSensor {
        GalVerificationSetSensor::new()
    }

    fn clear(&mut self) {
        self.sensors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationSetSensor {
        static instance: GalVerificationSetSensor = GalVerificationSetSensor {
            sensors: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationSetSensor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationSetSensor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationSetSensor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationSetSensor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationMediaSinkStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationMediaSinkStatus {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationMediaSinkStatus.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GalVerificationMediaSinkStatus.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<config::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationMediaSinkStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationMediaSinkStatus {
    fn default() -> &'a GalVerificationMediaSinkStatus {
        <GalVerificationMediaSinkStatus as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationMediaSinkStatus {
    pub fn new() -> GalVerificationMediaSinkStatus {
        ::std::default::Default::default()
    }

    // required int32 channel = 1;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // required .Config.Status status = 2;

    pub fn status(&self) -> config::Status {
        match self.status {
            Some(e) => e.enum_value_or(config::Status::STATUS_WAIT),
            None => config::Status::STATUS_WAIT,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: config::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &GalVerificationMediaSinkStatus| { &m.channel },
            |m: &mut GalVerificationMediaSinkStatus| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GalVerificationMediaSinkStatus| { &m.status },
            |m: &mut GalVerificationMediaSinkStatus| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationMediaSinkStatus>(
            "GalVerificationMediaSinkStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationMediaSinkStatus {
    const NAME: &'static str = "GalVerificationMediaSinkStatus";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationMediaSinkStatus {
        GalVerificationMediaSinkStatus::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationMediaSinkStatus {
        static instance: GalVerificationMediaSinkStatus = GalVerificationMediaSinkStatus {
            channel: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationMediaSinkStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationMediaSinkStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationMediaSinkStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationMediaSinkStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationVideoFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationVideoFocus {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationVideoFocus.video_focus_mode)
    pub video_focus_mode: ::std::option::Option<::protobuf::EnumOrUnknown<VideoFocusMode>>,
    // @@protoc_insertion_point(field:GalVerificationVideoFocus.deny)
    pub deny: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GalVerificationVideoFocus.unsolicited)
    pub unsolicited: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationVideoFocus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationVideoFocus {
    fn default() -> &'a GalVerificationVideoFocus {
        <GalVerificationVideoFocus as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationVideoFocus {
    pub fn new() -> GalVerificationVideoFocus {
        ::std::default::Default::default()
    }

    // required .VideoFocusMode video_focus_mode = 1;

    pub fn video_focus_mode(&self) -> VideoFocusMode {
        match self.video_focus_mode {
            Some(e) => e.enum_value_or(VideoFocusMode::VIDEO_FOCUS_PROJECTED),
            None => VideoFocusMode::VIDEO_FOCUS_PROJECTED,
        }
    }

    pub fn clear_video_focus_mode(&mut self) {
        self.video_focus_mode = ::std::option::Option::None;
    }

    pub fn has_video_focus_mode(&self) -> bool {
        self.video_focus_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_focus_mode(&mut self, v: VideoFocusMode) {
        self.video_focus_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool deny = 2;

    pub fn deny(&self) -> bool {
        self.deny.unwrap_or(false)
    }

    pub fn clear_deny(&mut self) {
        self.deny = ::std::option::Option::None;
    }

    pub fn has_deny(&self) -> bool {
        self.deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny(&mut self, v: bool) {
        self.deny = ::std::option::Option::Some(v);
    }

    // optional bool unsolicited = 3;

    pub fn unsolicited(&self) -> bool {
        self.unsolicited.unwrap_or(false)
    }

    pub fn clear_unsolicited(&mut self) {
        self.unsolicited = ::std::option::Option::None;
    }

    pub fn has_unsolicited(&self) -> bool {
        self.unsolicited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsolicited(&mut self, v: bool) {
        self.unsolicited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_focus_mode",
            |m: &GalVerificationVideoFocus| { &m.video_focus_mode },
            |m: &mut GalVerificationVideoFocus| { &mut m.video_focus_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deny",
            |m: &GalVerificationVideoFocus| { &m.deny },
            |m: &mut GalVerificationVideoFocus| { &mut m.deny },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsolicited",
            |m: &GalVerificationVideoFocus| { &m.unsolicited },
            |m: &mut GalVerificationVideoFocus| { &mut m.unsolicited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationVideoFocus>(
            "GalVerificationVideoFocus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationVideoFocus {
    const NAME: &'static str = "GalVerificationVideoFocus";

    fn is_initialized(&self) -> bool {
        if self.video_focus_mode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.video_focus_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.deny = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.unsolicited = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.video_focus_mode {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.deny {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unsolicited {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.video_focus_mode {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.deny {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.unsolicited {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationVideoFocus {
        GalVerificationVideoFocus::new()
    }

    fn clear(&mut self) {
        self.video_focus_mode = ::std::option::Option::None;
        self.deny = ::std::option::Option::None;
        self.unsolicited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationVideoFocus {
        static instance: GalVerificationVideoFocus = GalVerificationVideoFocus {
            video_focus_mode: ::std::option::Option::None,
            deny: ::std::option::Option::None,
            unsolicited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationVideoFocus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationVideoFocus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationVideoFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationVideoFocus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationAudioFocus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationAudioFocus {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationAudioFocus.audio_focus_state)
    pub audio_focus_state: ::std::option::Option<::protobuf::EnumOrUnknown<AudioFocusStateType>>,
    // @@protoc_insertion_point(field:GalVerificationAudioFocus.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GalVerificationAudioFocus.unsolicited)
    pub unsolicited: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationAudioFocus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationAudioFocus {
    fn default() -> &'a GalVerificationAudioFocus {
        <GalVerificationAudioFocus as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationAudioFocus {
    pub fn new() -> GalVerificationAudioFocus {
        ::std::default::Default::default()
    }

    // required .AudioFocusStateType audio_focus_state = 1;

    pub fn audio_focus_state(&self) -> AudioFocusStateType {
        match self.audio_focus_state {
            Some(e) => e.enum_value_or(AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID),
            None => AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID,
        }
    }

    pub fn clear_audio_focus_state(&mut self) {
        self.audio_focus_state = ::std::option::Option::None;
    }

    pub fn has_audio_focus_state(&self) -> bool {
        self.audio_focus_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_focus_state(&mut self, v: AudioFocusStateType) {
        self.audio_focus_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 channel = 2;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional bool unsolicited = 3;

    pub fn unsolicited(&self) -> bool {
        self.unsolicited.unwrap_or(false)
    }

    pub fn clear_unsolicited(&mut self) {
        self.unsolicited = ::std::option::Option::None;
    }

    pub fn has_unsolicited(&self) -> bool {
        self.unsolicited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsolicited(&mut self, v: bool) {
        self.unsolicited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_focus_state",
            |m: &GalVerificationAudioFocus| { &m.audio_focus_state },
            |m: &mut GalVerificationAudioFocus| { &mut m.audio_focus_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &GalVerificationAudioFocus| { &m.channel },
            |m: &mut GalVerificationAudioFocus| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unsolicited",
            |m: &GalVerificationAudioFocus| { &m.unsolicited },
            |m: &mut GalVerificationAudioFocus| { &mut m.unsolicited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationAudioFocus>(
            "GalVerificationAudioFocus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationAudioFocus {
    const NAME: &'static str = "GalVerificationAudioFocus";

    fn is_initialized(&self) -> bool {
        if self.audio_focus_state.is_none() {
            return false;
        }
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.audio_focus_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.unsolicited = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio_focus_state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.unsolicited {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio_focus_state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.channel {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.unsolicited {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationAudioFocus {
        GalVerificationAudioFocus::new()
    }

    fn clear(&mut self) {
        self.audio_focus_state = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.unsolicited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationAudioFocus {
        static instance: GalVerificationAudioFocus = GalVerificationAudioFocus {
            audio_focus_state: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            unsolicited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationAudioFocus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationAudioFocus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationAudioFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationAudioFocus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationInjectInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationInjectInput {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationInjectInput.input)
    pub input: ::protobuf::MessageField<InputReport>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationInjectInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationInjectInput {
    fn default() -> &'a GalVerificationInjectInput {
        <GalVerificationInjectInput as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationInjectInput {
    pub fn new() -> GalVerificationInjectInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InputReport>(
            "input",
            |m: &GalVerificationInjectInput| { &m.input },
            |m: &mut GalVerificationInjectInput| { &mut m.input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationInjectInput>(
            "GalVerificationInjectInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationInjectInput {
    const NAME: &'static str = "GalVerificationInjectInput";

    fn is_initialized(&self) -> bool {
        if self.input.is_none() {
            return false;
        }
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationInjectInput {
        GalVerificationInjectInput::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationInjectInput {
        static instance: GalVerificationInjectInput = GalVerificationInjectInput {
            input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationInjectInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationInjectInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationInjectInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationInjectInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationBugReportRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationBugReportRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationBugReportRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationBugReportRequest {
    fn default() -> &'a GalVerificationBugReportRequest {
        <GalVerificationBugReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationBugReportRequest {
    pub fn new() -> GalVerificationBugReportRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationBugReportRequest>(
            "GalVerificationBugReportRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationBugReportRequest {
    const NAME: &'static str = "GalVerificationBugReportRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationBugReportRequest {
        GalVerificationBugReportRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationBugReportRequest {
        static instance: GalVerificationBugReportRequest = GalVerificationBugReportRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationBugReportRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationBugReportRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationBugReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationBugReportRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationBugReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationBugReportResponse {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationBugReportResponse.bug_report)
    pub bug_report: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationBugReportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationBugReportResponse {
    fn default() -> &'a GalVerificationBugReportResponse {
        <GalVerificationBugReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationBugReportResponse {
    pub fn new() -> GalVerificationBugReportResponse {
        ::std::default::Default::default()
    }

    // required string bug_report = 1;

    pub fn bug_report(&self) -> &str {
        match self.bug_report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bug_report(&mut self) {
        self.bug_report = ::std::option::Option::None;
    }

    pub fn has_bug_report(&self) -> bool {
        self.bug_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bug_report(&mut self, v: ::std::string::String) {
        self.bug_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bug_report(&mut self) -> &mut ::std::string::String {
        if self.bug_report.is_none() {
            self.bug_report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bug_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_bug_report(&mut self) -> ::std::string::String {
        self.bug_report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bug_report",
            |m: &GalVerificationBugReportResponse| { &m.bug_report },
            |m: &mut GalVerificationBugReportResponse| { &mut m.bug_report },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationBugReportResponse>(
            "GalVerificationBugReportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationBugReportResponse {
    const NAME: &'static str = "GalVerificationBugReportResponse";

    fn is_initialized(&self) -> bool {
        if self.bug_report.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bug_report = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bug_report.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bug_report.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationBugReportResponse {
        GalVerificationBugReportResponse::new()
    }

    fn clear(&mut self) {
        self.bug_report = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationBugReportResponse {
        static instance: GalVerificationBugReportResponse = GalVerificationBugReportResponse {
            bug_report: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationBugReportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationBugReportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationBugReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationBugReportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationScreenCaptureRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationScreenCaptureRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationScreenCaptureRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationScreenCaptureRequest {
    fn default() -> &'a GalVerificationScreenCaptureRequest {
        <GalVerificationScreenCaptureRequest as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationScreenCaptureRequest {
    pub fn new() -> GalVerificationScreenCaptureRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationScreenCaptureRequest>(
            "GalVerificationScreenCaptureRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationScreenCaptureRequest {
    const NAME: &'static str = "GalVerificationScreenCaptureRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationScreenCaptureRequest {
        GalVerificationScreenCaptureRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationScreenCaptureRequest {
        static instance: GalVerificationScreenCaptureRequest = GalVerificationScreenCaptureRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationScreenCaptureRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationScreenCaptureRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationScreenCaptureRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationScreenCaptureRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationScreenCaptureResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationScreenCaptureResponse {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationScreenCaptureResponse.screen_capture)
    pub screen_capture: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationScreenCaptureResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationScreenCaptureResponse {
    fn default() -> &'a GalVerificationScreenCaptureResponse {
        <GalVerificationScreenCaptureResponse as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationScreenCaptureResponse {
    pub fn new() -> GalVerificationScreenCaptureResponse {
        ::std::default::Default::default()
    }

    // required bytes screen_capture = 1;

    pub fn screen_capture(&self) -> &[u8] {
        match self.screen_capture.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screen_capture(&mut self) {
        self.screen_capture = ::std::option::Option::None;
    }

    pub fn has_screen_capture(&self) -> bool {
        self.screen_capture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_capture(&mut self, v: ::std::vec::Vec<u8>) {
        self.screen_capture = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screen_capture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screen_capture.is_none() {
            self.screen_capture = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.screen_capture.as_mut().unwrap()
    }

    // Take field
    pub fn take_screen_capture(&mut self) -> ::std::vec::Vec<u8> {
        self.screen_capture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_capture",
            |m: &GalVerificationScreenCaptureResponse| { &m.screen_capture },
            |m: &mut GalVerificationScreenCaptureResponse| { &mut m.screen_capture },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationScreenCaptureResponse>(
            "GalVerificationScreenCaptureResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationScreenCaptureResponse {
    const NAME: &'static str = "GalVerificationScreenCaptureResponse";

    fn is_initialized(&self) -> bool {
        if self.screen_capture.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.screen_capture = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screen_capture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screen_capture.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationScreenCaptureResponse {
        GalVerificationScreenCaptureResponse::new()
    }

    fn clear(&mut self) {
        self.screen_capture = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationScreenCaptureResponse {
        static instance: GalVerificationScreenCaptureResponse = GalVerificationScreenCaptureResponse {
            screen_capture: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationScreenCaptureResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationScreenCaptureResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationScreenCaptureResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationScreenCaptureResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationDisplayInformationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationDisplayInformationRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationDisplayInformationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationDisplayInformationRequest {
    fn default() -> &'a GalVerificationDisplayInformationRequest {
        <GalVerificationDisplayInformationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationDisplayInformationRequest {
    pub fn new() -> GalVerificationDisplayInformationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationDisplayInformationRequest>(
            "GalVerificationDisplayInformationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationDisplayInformationRequest {
    const NAME: &'static str = "GalVerificationDisplayInformationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationDisplayInformationRequest {
        GalVerificationDisplayInformationRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationDisplayInformationRequest {
        static instance: GalVerificationDisplayInformationRequest = GalVerificationDisplayInformationRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationDisplayInformationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationDisplayInformationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationDisplayInformationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationDisplayInformationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GalVerificationDisplayInformationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GalVerificationDisplayInformationResponse {
    // message fields
    // @@protoc_insertion_point(field:GalVerificationDisplayInformationResponse.native_width)
    pub native_width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GalVerificationDisplayInformationResponse.native_height)
    pub native_height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GalVerificationDisplayInformationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GalVerificationDisplayInformationResponse {
    fn default() -> &'a GalVerificationDisplayInformationResponse {
        <GalVerificationDisplayInformationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GalVerificationDisplayInformationResponse {
    pub fn new() -> GalVerificationDisplayInformationResponse {
        ::std::default::Default::default()
    }

    // required int32 native_width = 1;

    pub fn native_width(&self) -> i32 {
        self.native_width.unwrap_or(0)
    }

    pub fn clear_native_width(&mut self) {
        self.native_width = ::std::option::Option::None;
    }

    pub fn has_native_width(&self) -> bool {
        self.native_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_width(&mut self, v: i32) {
        self.native_width = ::std::option::Option::Some(v);
    }

    // required int32 native_height = 2;

    pub fn native_height(&self) -> i32 {
        self.native_height.unwrap_or(0)
    }

    pub fn clear_native_height(&mut self) {
        self.native_height = ::std::option::Option::None;
    }

    pub fn has_native_height(&self) -> bool {
        self.native_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_height(&mut self, v: i32) {
        self.native_height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "native_width",
            |m: &GalVerificationDisplayInformationResponse| { &m.native_width },
            |m: &mut GalVerificationDisplayInformationResponse| { &mut m.native_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "native_height",
            |m: &GalVerificationDisplayInformationResponse| { &m.native_height },
            |m: &mut GalVerificationDisplayInformationResponse| { &mut m.native_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GalVerificationDisplayInformationResponse>(
            "GalVerificationDisplayInformationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GalVerificationDisplayInformationResponse {
    const NAME: &'static str = "GalVerificationDisplayInformationResponse";

    fn is_initialized(&self) -> bool {
        if self.native_width.is_none() {
            return false;
        }
        if self.native_height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.native_width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.native_height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.native_width {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.native_height {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.native_width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.native_height {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GalVerificationDisplayInformationResponse {
        GalVerificationDisplayInformationResponse::new()
    }

    fn clear(&mut self) {
        self.native_width = ::std::option::Option::None;
        self.native_height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GalVerificationDisplayInformationResponse {
        static instance: GalVerificationDisplayInformationResponse = GalVerificationDisplayInformationResponse {
            native_width: ::std::option::Option::None,
            native_height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GalVerificationDisplayInformationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GalVerificationDisplayInformationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GalVerificationDisplayInformationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GalVerificationDisplayInformationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GenericNotificationSubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GenericNotificationSubscribe {
    // special fields
    // @@protoc_insertion_point(special_field:GenericNotificationSubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericNotificationSubscribe {
    fn default() -> &'a GenericNotificationSubscribe {
        <GenericNotificationSubscribe as ::protobuf::Message>::default_instance()
    }
}

impl GenericNotificationSubscribe {
    pub fn new() -> GenericNotificationSubscribe {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericNotificationSubscribe>(
            "GenericNotificationSubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericNotificationSubscribe {
    const NAME: &'static str = "GenericNotificationSubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericNotificationSubscribe {
        GenericNotificationSubscribe::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericNotificationSubscribe {
        static instance: GenericNotificationSubscribe = GenericNotificationSubscribe {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericNotificationSubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericNotificationSubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericNotificationSubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericNotificationSubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GenericNotificationUnsubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GenericNotificationUnsubscribe {
    // special fields
    // @@protoc_insertion_point(special_field:GenericNotificationUnsubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericNotificationUnsubscribe {
    fn default() -> &'a GenericNotificationUnsubscribe {
        <GenericNotificationUnsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl GenericNotificationUnsubscribe {
    pub fn new() -> GenericNotificationUnsubscribe {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericNotificationUnsubscribe>(
            "GenericNotificationUnsubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericNotificationUnsubscribe {
    const NAME: &'static str = "GenericNotificationUnsubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericNotificationUnsubscribe {
        GenericNotificationUnsubscribe::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericNotificationUnsubscribe {
        static instance: GenericNotificationUnsubscribe = GenericNotificationUnsubscribe {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericNotificationUnsubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericNotificationUnsubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericNotificationUnsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericNotificationUnsubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GenericNotificationMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GenericNotificationMessage {
    // message fields
    // @@protoc_insertion_point(field:GenericNotificationMessage.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GenericNotificationMessage.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GenericNotificationMessage.icon)
    pub icon: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:GenericNotificationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericNotificationMessage {
    fn default() -> &'a GenericNotificationMessage {
        <GenericNotificationMessage as ::protobuf::Message>::default_instance()
    }
}

impl GenericNotificationMessage {
    pub fn new() -> GenericNotificationMessage {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes icon = 3;

    pub fn icon(&self) -> &[u8] {
        match self.icon.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::vec::Vec<u8>) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::vec::Vec<u8> {
        self.icon.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &GenericNotificationMessage| { &m.id },
            |m: &mut GenericNotificationMessage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &GenericNotificationMessage| { &m.text },
            |m: &mut GenericNotificationMessage| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &GenericNotificationMessage| { &m.icon },
            |m: &mut GenericNotificationMessage| { &mut m.icon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericNotificationMessage>(
            "GenericNotificationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericNotificationMessage {
    const NAME: &'static str = "GenericNotificationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.icon = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericNotificationMessage {
        GenericNotificationMessage::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericNotificationMessage {
        static instance: GenericNotificationMessage = GenericNotificationMessage {
            id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericNotificationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericNotificationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericNotificationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericNotificationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GenericNotificationAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GenericNotificationAck {
    // message fields
    // @@protoc_insertion_point(field:GenericNotificationAck.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GenericNotificationAck.handled)
    pub handled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:GenericNotificationAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericNotificationAck {
    fn default() -> &'a GenericNotificationAck {
        <GenericNotificationAck as ::protobuf::Message>::default_instance()
    }
}

impl GenericNotificationAck {
    pub fn new() -> GenericNotificationAck {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool handled = 2;

    pub fn handled(&self) -> bool {
        self.handled.unwrap_or(false)
    }

    pub fn clear_handled(&mut self) {
        self.handled = ::std::option::Option::None;
    }

    pub fn has_handled(&self) -> bool {
        self.handled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handled(&mut self, v: bool) {
        self.handled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &GenericNotificationAck| { &m.id },
            |m: &mut GenericNotificationAck| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handled",
            |m: &GenericNotificationAck| { &m.handled },
            |m: &mut GenericNotificationAck| { &mut m.handled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericNotificationAck>(
            "GenericNotificationAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericNotificationAck {
    const NAME: &'static str = "GenericNotificationAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.handled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.handled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.handled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericNotificationAck {
        GenericNotificationAck::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.handled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericNotificationAck {
        static instance: GenericNotificationAck = GenericNotificationAck {
            id: ::std::option::Option::None,
            handled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericNotificationAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericNotificationAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericNotificationAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericNotificationAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GoogleDiagnosticsBugReportRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GoogleDiagnosticsBugReportRequest {
    // message fields
    // @@protoc_insertion_point(field:GoogleDiagnosticsBugReportRequest.token)
    pub token: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GoogleDiagnosticsBugReportRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GoogleDiagnosticsBugReportRequest {
    fn default() -> &'a GoogleDiagnosticsBugReportRequest {
        <GoogleDiagnosticsBugReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GoogleDiagnosticsBugReportRequest {
    pub fn new() -> GoogleDiagnosticsBugReportRequest {
        ::std::default::Default::default()
    }

    // required int32 token = 1;

    pub fn token(&self) -> i32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: i32) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &GoogleDiagnosticsBugReportRequest| { &m.token },
            |m: &mut GoogleDiagnosticsBugReportRequest| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoogleDiagnosticsBugReportRequest>(
            "GoogleDiagnosticsBugReportRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GoogleDiagnosticsBugReportRequest {
    const NAME: &'static str = "GoogleDiagnosticsBugReportRequest";

    fn is_initialized(&self) -> bool {
        if self.token.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GoogleDiagnosticsBugReportRequest {
        GoogleDiagnosticsBugReportRequest::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GoogleDiagnosticsBugReportRequest {
        static instance: GoogleDiagnosticsBugReportRequest = GoogleDiagnosticsBugReportRequest {
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GoogleDiagnosticsBugReportRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GoogleDiagnosticsBugReportRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GoogleDiagnosticsBugReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoogleDiagnosticsBugReportRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GoogleDiagnosticsBugReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GoogleDiagnosticsBugReportResponse {
    // message fields
    // @@protoc_insertion_point(field:GoogleDiagnosticsBugReportResponse.bug_report)
    pub bug_report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GoogleDiagnosticsBugReportResponse.tokens)
    pub tokens: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:GoogleDiagnosticsBugReportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GoogleDiagnosticsBugReportResponse {
    fn default() -> &'a GoogleDiagnosticsBugReportResponse {
        <GoogleDiagnosticsBugReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl GoogleDiagnosticsBugReportResponse {
    pub fn new() -> GoogleDiagnosticsBugReportResponse {
        ::std::default::Default::default()
    }

    // optional string bug_report = 1;

    pub fn bug_report(&self) -> &str {
        match self.bug_report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bug_report(&mut self) {
        self.bug_report = ::std::option::Option::None;
    }

    pub fn has_bug_report(&self) -> bool {
        self.bug_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bug_report(&mut self, v: ::std::string::String) {
        self.bug_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bug_report(&mut self) -> &mut ::std::string::String {
        if self.bug_report.is_none() {
            self.bug_report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bug_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_bug_report(&mut self) -> ::std::string::String {
        self.bug_report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bug_report",
            |m: &GoogleDiagnosticsBugReportResponse| { &m.bug_report },
            |m: &mut GoogleDiagnosticsBugReportResponse| { &mut m.bug_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tokens",
            |m: &GoogleDiagnosticsBugReportResponse| { &m.tokens },
            |m: &mut GoogleDiagnosticsBugReportResponse| { &mut m.tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoogleDiagnosticsBugReportResponse>(
            "GoogleDiagnosticsBugReportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GoogleDiagnosticsBugReportResponse {
    const NAME: &'static str = "GoogleDiagnosticsBugReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bug_report = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.tokens)?;
                },
                16 => {
                    self.tokens.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bug_report.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bug_report.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.tokens {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GoogleDiagnosticsBugReportResponse {
        GoogleDiagnosticsBugReportResponse::new()
    }

    fn clear(&mut self) {
        self.bug_report = ::std::option::Option::None;
        self.tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GoogleDiagnosticsBugReportResponse {
        static instance: GoogleDiagnosticsBugReportResponse = GoogleDiagnosticsBugReportResponse {
            bug_report: ::std::option::Option::None,
            tokens: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GoogleDiagnosticsBugReportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GoogleDiagnosticsBugReportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GoogleDiagnosticsBugReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoogleDiagnosticsBugReportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ControlMessageType)
pub enum ControlMessageType {
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_VERSION_REQUEST)
    MESSAGE_VERSION_REQUEST = 1,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_VERSION_RESPONSE)
    MESSAGE_VERSION_RESPONSE = 2,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_ENCAPSULATED_SSL)
    MESSAGE_ENCAPSULATED_SSL = 3,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_AUTH_COMPLETE)
    MESSAGE_AUTH_COMPLETE = 4,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_SERVICE_DISCOVERY_REQUEST)
    MESSAGE_SERVICE_DISCOVERY_REQUEST = 5,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_SERVICE_DISCOVERY_RESPONSE)
    MESSAGE_SERVICE_DISCOVERY_RESPONSE = 6,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_CHANNEL_OPEN_REQUEST)
    MESSAGE_CHANNEL_OPEN_REQUEST = 7,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_CHANNEL_OPEN_RESPONSE)
    MESSAGE_CHANNEL_OPEN_RESPONSE = 8,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_CHANNEL_CLOSE_NOTIFICATION)
    MESSAGE_CHANNEL_CLOSE_NOTIFICATION = 9,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_PING_REQUEST)
    MESSAGE_PING_REQUEST = 11,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_PING_RESPONSE)
    MESSAGE_PING_RESPONSE = 12,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_NAV_FOCUS_REQUEST)
    MESSAGE_NAV_FOCUS_REQUEST = 13,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_NAV_FOCUS_NOTIFICATION)
    MESSAGE_NAV_FOCUS_NOTIFICATION = 14,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_BYEBYE_REQUEST)
    MESSAGE_BYEBYE_REQUEST = 15,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_BYEBYE_RESPONSE)
    MESSAGE_BYEBYE_RESPONSE = 16,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_VOICE_SESSION_NOTIFICATION)
    MESSAGE_VOICE_SESSION_NOTIFICATION = 17,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_AUDIO_FOCUS_REQUEST)
    MESSAGE_AUDIO_FOCUS_REQUEST = 18,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_AUDIO_FOCUS_NOTIFICATION)
    MESSAGE_AUDIO_FOCUS_NOTIFICATION = 19,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_CAR_CONNECTED_DEVICES_REQUEST)
    MESSAGE_CAR_CONNECTED_DEVICES_REQUEST = 20,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE)
    MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE = 21,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_USER_SWITCH_REQUEST)
    MESSAGE_USER_SWITCH_REQUEST = 22,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_BATTERY_STATUS_NOTIFICATION)
    MESSAGE_BATTERY_STATUS_NOTIFICATION = 23,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_CALL_AVAILABILITY_STATUS)
    MESSAGE_CALL_AVAILABILITY_STATUS = 24,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_USER_SWITCH_RESPONSE)
    MESSAGE_USER_SWITCH_RESPONSE = 25,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_SERVICE_DISCOVERY_UPDATE)
    MESSAGE_SERVICE_DISCOVERY_UPDATE = 26,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_UNEXPECTED_MESSAGE)
    MESSAGE_UNEXPECTED_MESSAGE = 255,
    // @@protoc_insertion_point(enum_value:ControlMessageType.MESSAGE_FRAMING_ERROR)
    MESSAGE_FRAMING_ERROR = 65535,
}

impl ::protobuf::Enum for ControlMessageType {
    const NAME: &'static str = "ControlMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ControlMessageType> {
        match value {
            1 => ::std::option::Option::Some(ControlMessageType::MESSAGE_VERSION_REQUEST),
            2 => ::std::option::Option::Some(ControlMessageType::MESSAGE_VERSION_RESPONSE),
            3 => ::std::option::Option::Some(ControlMessageType::MESSAGE_ENCAPSULATED_SSL),
            4 => ::std::option::Option::Some(ControlMessageType::MESSAGE_AUTH_COMPLETE),
            5 => ::std::option::Option::Some(ControlMessageType::MESSAGE_SERVICE_DISCOVERY_REQUEST),
            6 => ::std::option::Option::Some(ControlMessageType::MESSAGE_SERVICE_DISCOVERY_RESPONSE),
            7 => ::std::option::Option::Some(ControlMessageType::MESSAGE_CHANNEL_OPEN_REQUEST),
            8 => ::std::option::Option::Some(ControlMessageType::MESSAGE_CHANNEL_OPEN_RESPONSE),
            9 => ::std::option::Option::Some(ControlMessageType::MESSAGE_CHANNEL_CLOSE_NOTIFICATION),
            11 => ::std::option::Option::Some(ControlMessageType::MESSAGE_PING_REQUEST),
            12 => ::std::option::Option::Some(ControlMessageType::MESSAGE_PING_RESPONSE),
            13 => ::std::option::Option::Some(ControlMessageType::MESSAGE_NAV_FOCUS_REQUEST),
            14 => ::std::option::Option::Some(ControlMessageType::MESSAGE_NAV_FOCUS_NOTIFICATION),
            15 => ::std::option::Option::Some(ControlMessageType::MESSAGE_BYEBYE_REQUEST),
            16 => ::std::option::Option::Some(ControlMessageType::MESSAGE_BYEBYE_RESPONSE),
            17 => ::std::option::Option::Some(ControlMessageType::MESSAGE_VOICE_SESSION_NOTIFICATION),
            18 => ::std::option::Option::Some(ControlMessageType::MESSAGE_AUDIO_FOCUS_REQUEST),
            19 => ::std::option::Option::Some(ControlMessageType::MESSAGE_AUDIO_FOCUS_NOTIFICATION),
            20 => ::std::option::Option::Some(ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_REQUEST),
            21 => ::std::option::Option::Some(ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE),
            22 => ::std::option::Option::Some(ControlMessageType::MESSAGE_USER_SWITCH_REQUEST),
            23 => ::std::option::Option::Some(ControlMessageType::MESSAGE_BATTERY_STATUS_NOTIFICATION),
            24 => ::std::option::Option::Some(ControlMessageType::MESSAGE_CALL_AVAILABILITY_STATUS),
            25 => ::std::option::Option::Some(ControlMessageType::MESSAGE_USER_SWITCH_RESPONSE),
            26 => ::std::option::Option::Some(ControlMessageType::MESSAGE_SERVICE_DISCOVERY_UPDATE),
            255 => ::std::option::Option::Some(ControlMessageType::MESSAGE_UNEXPECTED_MESSAGE),
            65535 => ::std::option::Option::Some(ControlMessageType::MESSAGE_FRAMING_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ControlMessageType> {
        match str {
            "MESSAGE_VERSION_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_VERSION_REQUEST),
            "MESSAGE_VERSION_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_VERSION_RESPONSE),
            "MESSAGE_ENCAPSULATED_SSL" => ::std::option::Option::Some(ControlMessageType::MESSAGE_ENCAPSULATED_SSL),
            "MESSAGE_AUTH_COMPLETE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_AUTH_COMPLETE),
            "MESSAGE_SERVICE_DISCOVERY_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_SERVICE_DISCOVERY_REQUEST),
            "MESSAGE_SERVICE_DISCOVERY_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_SERVICE_DISCOVERY_RESPONSE),
            "MESSAGE_CHANNEL_OPEN_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_CHANNEL_OPEN_REQUEST),
            "MESSAGE_CHANNEL_OPEN_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_CHANNEL_OPEN_RESPONSE),
            "MESSAGE_CHANNEL_CLOSE_NOTIFICATION" => ::std::option::Option::Some(ControlMessageType::MESSAGE_CHANNEL_CLOSE_NOTIFICATION),
            "MESSAGE_PING_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_PING_REQUEST),
            "MESSAGE_PING_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_PING_RESPONSE),
            "MESSAGE_NAV_FOCUS_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_NAV_FOCUS_REQUEST),
            "MESSAGE_NAV_FOCUS_NOTIFICATION" => ::std::option::Option::Some(ControlMessageType::MESSAGE_NAV_FOCUS_NOTIFICATION),
            "MESSAGE_BYEBYE_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_BYEBYE_REQUEST),
            "MESSAGE_BYEBYE_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_BYEBYE_RESPONSE),
            "MESSAGE_VOICE_SESSION_NOTIFICATION" => ::std::option::Option::Some(ControlMessageType::MESSAGE_VOICE_SESSION_NOTIFICATION),
            "MESSAGE_AUDIO_FOCUS_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_AUDIO_FOCUS_REQUEST),
            "MESSAGE_AUDIO_FOCUS_NOTIFICATION" => ::std::option::Option::Some(ControlMessageType::MESSAGE_AUDIO_FOCUS_NOTIFICATION),
            "MESSAGE_CAR_CONNECTED_DEVICES_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_REQUEST),
            "MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE),
            "MESSAGE_USER_SWITCH_REQUEST" => ::std::option::Option::Some(ControlMessageType::MESSAGE_USER_SWITCH_REQUEST),
            "MESSAGE_BATTERY_STATUS_NOTIFICATION" => ::std::option::Option::Some(ControlMessageType::MESSAGE_BATTERY_STATUS_NOTIFICATION),
            "MESSAGE_CALL_AVAILABILITY_STATUS" => ::std::option::Option::Some(ControlMessageType::MESSAGE_CALL_AVAILABILITY_STATUS),
            "MESSAGE_USER_SWITCH_RESPONSE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_USER_SWITCH_RESPONSE),
            "MESSAGE_SERVICE_DISCOVERY_UPDATE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_SERVICE_DISCOVERY_UPDATE),
            "MESSAGE_UNEXPECTED_MESSAGE" => ::std::option::Option::Some(ControlMessageType::MESSAGE_UNEXPECTED_MESSAGE),
            "MESSAGE_FRAMING_ERROR" => ::std::option::Option::Some(ControlMessageType::MESSAGE_FRAMING_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ControlMessageType] = &[
        ControlMessageType::MESSAGE_VERSION_REQUEST,
        ControlMessageType::MESSAGE_VERSION_RESPONSE,
        ControlMessageType::MESSAGE_ENCAPSULATED_SSL,
        ControlMessageType::MESSAGE_AUTH_COMPLETE,
        ControlMessageType::MESSAGE_SERVICE_DISCOVERY_REQUEST,
        ControlMessageType::MESSAGE_SERVICE_DISCOVERY_RESPONSE,
        ControlMessageType::MESSAGE_CHANNEL_OPEN_REQUEST,
        ControlMessageType::MESSAGE_CHANNEL_OPEN_RESPONSE,
        ControlMessageType::MESSAGE_CHANNEL_CLOSE_NOTIFICATION,
        ControlMessageType::MESSAGE_PING_REQUEST,
        ControlMessageType::MESSAGE_PING_RESPONSE,
        ControlMessageType::MESSAGE_NAV_FOCUS_REQUEST,
        ControlMessageType::MESSAGE_NAV_FOCUS_NOTIFICATION,
        ControlMessageType::MESSAGE_BYEBYE_REQUEST,
        ControlMessageType::MESSAGE_BYEBYE_RESPONSE,
        ControlMessageType::MESSAGE_VOICE_SESSION_NOTIFICATION,
        ControlMessageType::MESSAGE_AUDIO_FOCUS_REQUEST,
        ControlMessageType::MESSAGE_AUDIO_FOCUS_NOTIFICATION,
        ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_REQUEST,
        ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE,
        ControlMessageType::MESSAGE_USER_SWITCH_REQUEST,
        ControlMessageType::MESSAGE_BATTERY_STATUS_NOTIFICATION,
        ControlMessageType::MESSAGE_CALL_AVAILABILITY_STATUS,
        ControlMessageType::MESSAGE_USER_SWITCH_RESPONSE,
        ControlMessageType::MESSAGE_SERVICE_DISCOVERY_UPDATE,
        ControlMessageType::MESSAGE_UNEXPECTED_MESSAGE,
        ControlMessageType::MESSAGE_FRAMING_ERROR,
    ];
}

impl ::protobuf::EnumFull for ControlMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ControlMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ControlMessageType::MESSAGE_VERSION_REQUEST => 0,
            ControlMessageType::MESSAGE_VERSION_RESPONSE => 1,
            ControlMessageType::MESSAGE_ENCAPSULATED_SSL => 2,
            ControlMessageType::MESSAGE_AUTH_COMPLETE => 3,
            ControlMessageType::MESSAGE_SERVICE_DISCOVERY_REQUEST => 4,
            ControlMessageType::MESSAGE_SERVICE_DISCOVERY_RESPONSE => 5,
            ControlMessageType::MESSAGE_CHANNEL_OPEN_REQUEST => 6,
            ControlMessageType::MESSAGE_CHANNEL_OPEN_RESPONSE => 7,
            ControlMessageType::MESSAGE_CHANNEL_CLOSE_NOTIFICATION => 8,
            ControlMessageType::MESSAGE_PING_REQUEST => 9,
            ControlMessageType::MESSAGE_PING_RESPONSE => 10,
            ControlMessageType::MESSAGE_NAV_FOCUS_REQUEST => 11,
            ControlMessageType::MESSAGE_NAV_FOCUS_NOTIFICATION => 12,
            ControlMessageType::MESSAGE_BYEBYE_REQUEST => 13,
            ControlMessageType::MESSAGE_BYEBYE_RESPONSE => 14,
            ControlMessageType::MESSAGE_VOICE_SESSION_NOTIFICATION => 15,
            ControlMessageType::MESSAGE_AUDIO_FOCUS_REQUEST => 16,
            ControlMessageType::MESSAGE_AUDIO_FOCUS_NOTIFICATION => 17,
            ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_REQUEST => 18,
            ControlMessageType::MESSAGE_CAR_CONNECTED_DEVICES_RESPONSE => 19,
            ControlMessageType::MESSAGE_USER_SWITCH_REQUEST => 20,
            ControlMessageType::MESSAGE_BATTERY_STATUS_NOTIFICATION => 21,
            ControlMessageType::MESSAGE_CALL_AVAILABILITY_STATUS => 22,
            ControlMessageType::MESSAGE_USER_SWITCH_RESPONSE => 23,
            ControlMessageType::MESSAGE_SERVICE_DISCOVERY_UPDATE => 24,
            ControlMessageType::MESSAGE_UNEXPECTED_MESSAGE => 25,
            ControlMessageType::MESSAGE_FRAMING_ERROR => 26,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ControlMessageType {
    fn default() -> Self {
        ControlMessageType::MESSAGE_VERSION_REQUEST
    }
}

impl ControlMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ControlMessageType>("ControlMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FragInfo)
pub enum FragInfo {
    // @@protoc_insertion_point(enum_value:FragInfo.FRAG_CONTINUATION)
    FRAG_CONTINUATION = 0,
    // @@protoc_insertion_point(enum_value:FragInfo.FRAG_FIRST)
    FRAG_FIRST = 1,
    // @@protoc_insertion_point(enum_value:FragInfo.FRAG_LAST)
    FRAG_LAST = 2,
    // @@protoc_insertion_point(enum_value:FragInfo.FRAG_UNFRAGMENTED)
    FRAG_UNFRAGMENTED = 3,
}

impl ::protobuf::Enum for FragInfo {
    const NAME: &'static str = "FragInfo";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FragInfo> {
        match value {
            0 => ::std::option::Option::Some(FragInfo::FRAG_CONTINUATION),
            1 => ::std::option::Option::Some(FragInfo::FRAG_FIRST),
            2 => ::std::option::Option::Some(FragInfo::FRAG_LAST),
            3 => ::std::option::Option::Some(FragInfo::FRAG_UNFRAGMENTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FragInfo> {
        match str {
            "FRAG_CONTINUATION" => ::std::option::Option::Some(FragInfo::FRAG_CONTINUATION),
            "FRAG_FIRST" => ::std::option::Option::Some(FragInfo::FRAG_FIRST),
            "FRAG_LAST" => ::std::option::Option::Some(FragInfo::FRAG_LAST),
            "FRAG_UNFRAGMENTED" => ::std::option::Option::Some(FragInfo::FRAG_UNFRAGMENTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FragInfo] = &[
        FragInfo::FRAG_CONTINUATION,
        FragInfo::FRAG_FIRST,
        FragInfo::FRAG_LAST,
        FragInfo::FRAG_UNFRAGMENTED,
    ];
}

impl ::protobuf::EnumFull for FragInfo {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FragInfo").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FragInfo {
    fn default() -> Self {
        FragInfo::FRAG_CONTINUATION
    }
}

impl FragInfo {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FragInfo>("FragInfo")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DriverPosition)
pub enum DriverPosition {
    // @@protoc_insertion_point(enum_value:DriverPosition.DRIVER_POSITION_LEFT)
    DRIVER_POSITION_LEFT = 0,
    // @@protoc_insertion_point(enum_value:DriverPosition.DRIVER_POSITION_RIGHT)
    DRIVER_POSITION_RIGHT = 1,
    // @@protoc_insertion_point(enum_value:DriverPosition.DRIVER_POSITION_CENTER)
    DRIVER_POSITION_CENTER = 2,
    // @@protoc_insertion_point(enum_value:DriverPosition.DRIVER_POSITION_UNKNOWN)
    DRIVER_POSITION_UNKNOWN = 3,
}

impl ::protobuf::Enum for DriverPosition {
    const NAME: &'static str = "DriverPosition";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DriverPosition> {
        match value {
            0 => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_LEFT),
            1 => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_RIGHT),
            2 => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_CENTER),
            3 => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DriverPosition> {
        match str {
            "DRIVER_POSITION_LEFT" => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_LEFT),
            "DRIVER_POSITION_RIGHT" => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_RIGHT),
            "DRIVER_POSITION_CENTER" => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_CENTER),
            "DRIVER_POSITION_UNKNOWN" => ::std::option::Option::Some(DriverPosition::DRIVER_POSITION_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DriverPosition] = &[
        DriverPosition::DRIVER_POSITION_LEFT,
        DriverPosition::DRIVER_POSITION_RIGHT,
        DriverPosition::DRIVER_POSITION_CENTER,
        DriverPosition::DRIVER_POSITION_UNKNOWN,
    ];
}

impl ::protobuf::EnumFull for DriverPosition {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DriverPosition").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DriverPosition {
    fn default() -> Self {
        DriverPosition::DRIVER_POSITION_LEFT
    }
}

impl DriverPosition {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DriverPosition>("DriverPosition")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SessionConfiguration)
pub enum SessionConfiguration {
    // @@protoc_insertion_point(enum_value:SessionConfiguration.UI_CONFIG_HIDE_CLOCK)
    UI_CONFIG_HIDE_CLOCK = 1,
    // @@protoc_insertion_point(enum_value:SessionConfiguration.UI_CONFIG_HIDE_PHONE_SIGNAL)
    UI_CONFIG_HIDE_PHONE_SIGNAL = 2,
    // @@protoc_insertion_point(enum_value:SessionConfiguration.UI_CONFIG_HIDE_BATTERY_LEVEL)
    UI_CONFIG_HIDE_BATTERY_LEVEL = 4,
    // @@protoc_insertion_point(enum_value:SessionConfiguration.CAN_PLAY_NATIVE_MEDIA_DURING_VR)
    CAN_PLAY_NATIVE_MEDIA_DURING_VR = 8,
}

impl ::protobuf::Enum for SessionConfiguration {
    const NAME: &'static str = "SessionConfiguration";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SessionConfiguration> {
        match value {
            1 => ::std::option::Option::Some(SessionConfiguration::UI_CONFIG_HIDE_CLOCK),
            2 => ::std::option::Option::Some(SessionConfiguration::UI_CONFIG_HIDE_PHONE_SIGNAL),
            4 => ::std::option::Option::Some(SessionConfiguration::UI_CONFIG_HIDE_BATTERY_LEVEL),
            8 => ::std::option::Option::Some(SessionConfiguration::CAN_PLAY_NATIVE_MEDIA_DURING_VR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SessionConfiguration> {
        match str {
            "UI_CONFIG_HIDE_CLOCK" => ::std::option::Option::Some(SessionConfiguration::UI_CONFIG_HIDE_CLOCK),
            "UI_CONFIG_HIDE_PHONE_SIGNAL" => ::std::option::Option::Some(SessionConfiguration::UI_CONFIG_HIDE_PHONE_SIGNAL),
            "UI_CONFIG_HIDE_BATTERY_LEVEL" => ::std::option::Option::Some(SessionConfiguration::UI_CONFIG_HIDE_BATTERY_LEVEL),
            "CAN_PLAY_NATIVE_MEDIA_DURING_VR" => ::std::option::Option::Some(SessionConfiguration::CAN_PLAY_NATIVE_MEDIA_DURING_VR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SessionConfiguration] = &[
        SessionConfiguration::UI_CONFIG_HIDE_CLOCK,
        SessionConfiguration::UI_CONFIG_HIDE_PHONE_SIGNAL,
        SessionConfiguration::UI_CONFIG_HIDE_BATTERY_LEVEL,
        SessionConfiguration::CAN_PLAY_NATIVE_MEDIA_DURING_VR,
    ];
}

impl ::protobuf::EnumFull for SessionConfiguration {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SessionConfiguration").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SessionConfiguration::UI_CONFIG_HIDE_CLOCK => 0,
            SessionConfiguration::UI_CONFIG_HIDE_PHONE_SIGNAL => 1,
            SessionConfiguration::UI_CONFIG_HIDE_BATTERY_LEVEL => 2,
            SessionConfiguration::CAN_PLAY_NATIVE_MEDIA_DURING_VR => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SessionConfiguration {
    fn default() -> Self {
        SessionConfiguration::UI_CONFIG_HIDE_CLOCK
    }
}

impl SessionConfiguration {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SessionConfiguration>("SessionConfiguration")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LocationCharacterization)
pub enum LocationCharacterization {
    // @@protoc_insertion_point(enum_value:LocationCharacterization.PRIOR_LOCATIONS)
    PRIOR_LOCATIONS = 1,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.GYROSCOPE_FUSION)
    GYROSCOPE_FUSION = 2,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.ACCELEROMETER_FUSION)
    ACCELEROMETER_FUSION = 4,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.COMPASS_FUSION)
    COMPASS_FUSION = 8,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.WHEEL_SPEED_FUSION)
    WHEEL_SPEED_FUSION = 16,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.STEERING_ANGLE_FUSION)
    STEERING_ANGLE_FUSION = 32,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.CAR_SPEED_FUSION)
    CAR_SPEED_FUSION = 64,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.DEAD_RECKONED)
    DEAD_RECKONED = 128,
    // @@protoc_insertion_point(enum_value:LocationCharacterization.RAW_GPS_ONLY)
    RAW_GPS_ONLY = 256,
}

impl ::protobuf::Enum for LocationCharacterization {
    const NAME: &'static str = "LocationCharacterization";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LocationCharacterization> {
        match value {
            1 => ::std::option::Option::Some(LocationCharacterization::PRIOR_LOCATIONS),
            2 => ::std::option::Option::Some(LocationCharacterization::GYROSCOPE_FUSION),
            4 => ::std::option::Option::Some(LocationCharacterization::ACCELEROMETER_FUSION),
            8 => ::std::option::Option::Some(LocationCharacterization::COMPASS_FUSION),
            16 => ::std::option::Option::Some(LocationCharacterization::WHEEL_SPEED_FUSION),
            32 => ::std::option::Option::Some(LocationCharacterization::STEERING_ANGLE_FUSION),
            64 => ::std::option::Option::Some(LocationCharacterization::CAR_SPEED_FUSION),
            128 => ::std::option::Option::Some(LocationCharacterization::DEAD_RECKONED),
            256 => ::std::option::Option::Some(LocationCharacterization::RAW_GPS_ONLY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LocationCharacterization> {
        match str {
            "PRIOR_LOCATIONS" => ::std::option::Option::Some(LocationCharacterization::PRIOR_LOCATIONS),
            "GYROSCOPE_FUSION" => ::std::option::Option::Some(LocationCharacterization::GYROSCOPE_FUSION),
            "ACCELEROMETER_FUSION" => ::std::option::Option::Some(LocationCharacterization::ACCELEROMETER_FUSION),
            "COMPASS_FUSION" => ::std::option::Option::Some(LocationCharacterization::COMPASS_FUSION),
            "WHEEL_SPEED_FUSION" => ::std::option::Option::Some(LocationCharacterization::WHEEL_SPEED_FUSION),
            "STEERING_ANGLE_FUSION" => ::std::option::Option::Some(LocationCharacterization::STEERING_ANGLE_FUSION),
            "CAR_SPEED_FUSION" => ::std::option::Option::Some(LocationCharacterization::CAR_SPEED_FUSION),
            "DEAD_RECKONED" => ::std::option::Option::Some(LocationCharacterization::DEAD_RECKONED),
            "RAW_GPS_ONLY" => ::std::option::Option::Some(LocationCharacterization::RAW_GPS_ONLY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LocationCharacterization] = &[
        LocationCharacterization::PRIOR_LOCATIONS,
        LocationCharacterization::GYROSCOPE_FUSION,
        LocationCharacterization::ACCELEROMETER_FUSION,
        LocationCharacterization::COMPASS_FUSION,
        LocationCharacterization::WHEEL_SPEED_FUSION,
        LocationCharacterization::STEERING_ANGLE_FUSION,
        LocationCharacterization::CAR_SPEED_FUSION,
        LocationCharacterization::DEAD_RECKONED,
        LocationCharacterization::RAW_GPS_ONLY,
    ];
}

impl ::protobuf::EnumFull for LocationCharacterization {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LocationCharacterization").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            LocationCharacterization::PRIOR_LOCATIONS => 0,
            LocationCharacterization::GYROSCOPE_FUSION => 1,
            LocationCharacterization::ACCELEROMETER_FUSION => 2,
            LocationCharacterization::COMPASS_FUSION => 3,
            LocationCharacterization::WHEEL_SPEED_FUSION => 4,
            LocationCharacterization::STEERING_ANGLE_FUSION => 5,
            LocationCharacterization::CAR_SPEED_FUSION => 6,
            LocationCharacterization::DEAD_RECKONED => 7,
            LocationCharacterization::RAW_GPS_ONLY => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for LocationCharacterization {
    fn default() -> Self {
        LocationCharacterization::PRIOR_LOCATIONS
    }
}

impl LocationCharacterization {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LocationCharacterization>("LocationCharacterization")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorType)
pub enum SensorType {
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_LOCATION)
    SENSOR_LOCATION = 1,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_COMPASS)
    SENSOR_COMPASS = 2,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_SPEED)
    SENSOR_SPEED = 3,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_RPM)
    SENSOR_RPM = 4,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_ODOMETER)
    SENSOR_ODOMETER = 5,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_FUEL)
    SENSOR_FUEL = 6,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_PARKING_BRAKE)
    SENSOR_PARKING_BRAKE = 7,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_GEAR)
    SENSOR_GEAR = 8,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_OBDII_DIAGNOSTIC_CODE)
    SENSOR_OBDII_DIAGNOSTIC_CODE = 9,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_NIGHT_MODE)
    SENSOR_NIGHT_MODE = 10,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_ENVIRONMENT_DATA)
    SENSOR_ENVIRONMENT_DATA = 11,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_HVAC_DATA)
    SENSOR_HVAC_DATA = 12,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_DRIVING_STATUS_DATA)
    SENSOR_DRIVING_STATUS_DATA = 13,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_DEAD_RECKONING_DATA)
    SENSOR_DEAD_RECKONING_DATA = 14,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_PASSENGER_DATA)
    SENSOR_PASSENGER_DATA = 15,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_DOOR_DATA)
    SENSOR_DOOR_DATA = 16,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_LIGHT_DATA)
    SENSOR_LIGHT_DATA = 17,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_TIRE_PRESSURE_DATA)
    SENSOR_TIRE_PRESSURE_DATA = 18,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_ACCELEROMETER_DATA)
    SENSOR_ACCELEROMETER_DATA = 19,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_GYROSCOPE_DATA)
    SENSOR_GYROSCOPE_DATA = 20,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_GPS_SATELLITE_DATA)
    SENSOR_GPS_SATELLITE_DATA = 21,
    // @@protoc_insertion_point(enum_value:SensorType.SENSOR_TOLL_CARD)
    SENSOR_TOLL_CARD = 22,
}

impl ::protobuf::Enum for SensorType {
    const NAME: &'static str = "SensorType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorType> {
        match value {
            1 => ::std::option::Option::Some(SensorType::SENSOR_LOCATION),
            2 => ::std::option::Option::Some(SensorType::SENSOR_COMPASS),
            3 => ::std::option::Option::Some(SensorType::SENSOR_SPEED),
            4 => ::std::option::Option::Some(SensorType::SENSOR_RPM),
            5 => ::std::option::Option::Some(SensorType::SENSOR_ODOMETER),
            6 => ::std::option::Option::Some(SensorType::SENSOR_FUEL),
            7 => ::std::option::Option::Some(SensorType::SENSOR_PARKING_BRAKE),
            8 => ::std::option::Option::Some(SensorType::SENSOR_GEAR),
            9 => ::std::option::Option::Some(SensorType::SENSOR_OBDII_DIAGNOSTIC_CODE),
            10 => ::std::option::Option::Some(SensorType::SENSOR_NIGHT_MODE),
            11 => ::std::option::Option::Some(SensorType::SENSOR_ENVIRONMENT_DATA),
            12 => ::std::option::Option::Some(SensorType::SENSOR_HVAC_DATA),
            13 => ::std::option::Option::Some(SensorType::SENSOR_DRIVING_STATUS_DATA),
            14 => ::std::option::Option::Some(SensorType::SENSOR_DEAD_RECKONING_DATA),
            15 => ::std::option::Option::Some(SensorType::SENSOR_PASSENGER_DATA),
            16 => ::std::option::Option::Some(SensorType::SENSOR_DOOR_DATA),
            17 => ::std::option::Option::Some(SensorType::SENSOR_LIGHT_DATA),
            18 => ::std::option::Option::Some(SensorType::SENSOR_TIRE_PRESSURE_DATA),
            19 => ::std::option::Option::Some(SensorType::SENSOR_ACCELEROMETER_DATA),
            20 => ::std::option::Option::Some(SensorType::SENSOR_GYROSCOPE_DATA),
            21 => ::std::option::Option::Some(SensorType::SENSOR_GPS_SATELLITE_DATA),
            22 => ::std::option::Option::Some(SensorType::SENSOR_TOLL_CARD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SensorType> {
        match str {
            "SENSOR_LOCATION" => ::std::option::Option::Some(SensorType::SENSOR_LOCATION),
            "SENSOR_COMPASS" => ::std::option::Option::Some(SensorType::SENSOR_COMPASS),
            "SENSOR_SPEED" => ::std::option::Option::Some(SensorType::SENSOR_SPEED),
            "SENSOR_RPM" => ::std::option::Option::Some(SensorType::SENSOR_RPM),
            "SENSOR_ODOMETER" => ::std::option::Option::Some(SensorType::SENSOR_ODOMETER),
            "SENSOR_FUEL" => ::std::option::Option::Some(SensorType::SENSOR_FUEL),
            "SENSOR_PARKING_BRAKE" => ::std::option::Option::Some(SensorType::SENSOR_PARKING_BRAKE),
            "SENSOR_GEAR" => ::std::option::Option::Some(SensorType::SENSOR_GEAR),
            "SENSOR_OBDII_DIAGNOSTIC_CODE" => ::std::option::Option::Some(SensorType::SENSOR_OBDII_DIAGNOSTIC_CODE),
            "SENSOR_NIGHT_MODE" => ::std::option::Option::Some(SensorType::SENSOR_NIGHT_MODE),
            "SENSOR_ENVIRONMENT_DATA" => ::std::option::Option::Some(SensorType::SENSOR_ENVIRONMENT_DATA),
            "SENSOR_HVAC_DATA" => ::std::option::Option::Some(SensorType::SENSOR_HVAC_DATA),
            "SENSOR_DRIVING_STATUS_DATA" => ::std::option::Option::Some(SensorType::SENSOR_DRIVING_STATUS_DATA),
            "SENSOR_DEAD_RECKONING_DATA" => ::std::option::Option::Some(SensorType::SENSOR_DEAD_RECKONING_DATA),
            "SENSOR_PASSENGER_DATA" => ::std::option::Option::Some(SensorType::SENSOR_PASSENGER_DATA),
            "SENSOR_DOOR_DATA" => ::std::option::Option::Some(SensorType::SENSOR_DOOR_DATA),
            "SENSOR_LIGHT_DATA" => ::std::option::Option::Some(SensorType::SENSOR_LIGHT_DATA),
            "SENSOR_TIRE_PRESSURE_DATA" => ::std::option::Option::Some(SensorType::SENSOR_TIRE_PRESSURE_DATA),
            "SENSOR_ACCELEROMETER_DATA" => ::std::option::Option::Some(SensorType::SENSOR_ACCELEROMETER_DATA),
            "SENSOR_GYROSCOPE_DATA" => ::std::option::Option::Some(SensorType::SENSOR_GYROSCOPE_DATA),
            "SENSOR_GPS_SATELLITE_DATA" => ::std::option::Option::Some(SensorType::SENSOR_GPS_SATELLITE_DATA),
            "SENSOR_TOLL_CARD" => ::std::option::Option::Some(SensorType::SENSOR_TOLL_CARD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorType] = &[
        SensorType::SENSOR_LOCATION,
        SensorType::SENSOR_COMPASS,
        SensorType::SENSOR_SPEED,
        SensorType::SENSOR_RPM,
        SensorType::SENSOR_ODOMETER,
        SensorType::SENSOR_FUEL,
        SensorType::SENSOR_PARKING_BRAKE,
        SensorType::SENSOR_GEAR,
        SensorType::SENSOR_OBDII_DIAGNOSTIC_CODE,
        SensorType::SENSOR_NIGHT_MODE,
        SensorType::SENSOR_ENVIRONMENT_DATA,
        SensorType::SENSOR_HVAC_DATA,
        SensorType::SENSOR_DRIVING_STATUS_DATA,
        SensorType::SENSOR_DEAD_RECKONING_DATA,
        SensorType::SENSOR_PASSENGER_DATA,
        SensorType::SENSOR_DOOR_DATA,
        SensorType::SENSOR_LIGHT_DATA,
        SensorType::SENSOR_TIRE_PRESSURE_DATA,
        SensorType::SENSOR_ACCELEROMETER_DATA,
        SensorType::SENSOR_GYROSCOPE_DATA,
        SensorType::SENSOR_GPS_SATELLITE_DATA,
        SensorType::SENSOR_TOLL_CARD,
    ];
}

impl ::protobuf::EnumFull for SensorType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SensorType::SENSOR_LOCATION => 0,
            SensorType::SENSOR_COMPASS => 1,
            SensorType::SENSOR_SPEED => 2,
            SensorType::SENSOR_RPM => 3,
            SensorType::SENSOR_ODOMETER => 4,
            SensorType::SENSOR_FUEL => 5,
            SensorType::SENSOR_PARKING_BRAKE => 6,
            SensorType::SENSOR_GEAR => 7,
            SensorType::SENSOR_OBDII_DIAGNOSTIC_CODE => 8,
            SensorType::SENSOR_NIGHT_MODE => 9,
            SensorType::SENSOR_ENVIRONMENT_DATA => 10,
            SensorType::SENSOR_HVAC_DATA => 11,
            SensorType::SENSOR_DRIVING_STATUS_DATA => 12,
            SensorType::SENSOR_DEAD_RECKONING_DATA => 13,
            SensorType::SENSOR_PASSENGER_DATA => 14,
            SensorType::SENSOR_DOOR_DATA => 15,
            SensorType::SENSOR_LIGHT_DATA => 16,
            SensorType::SENSOR_TIRE_PRESSURE_DATA => 17,
            SensorType::SENSOR_ACCELEROMETER_DATA => 18,
            SensorType::SENSOR_GYROSCOPE_DATA => 19,
            SensorType::SENSOR_GPS_SATELLITE_DATA => 20,
            SensorType::SENSOR_TOLL_CARD => 21,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SensorType {
    fn default() -> Self {
        SensorType::SENSOR_LOCATION
    }
}

impl SensorType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorType>("SensorType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FuelType)
pub enum FuelType {
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_UNKNOWN)
    FUEL_TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_UNLEADED)
    FUEL_TYPE_UNLEADED = 1,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_LEADED)
    FUEL_TYPE_LEADED = 2,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_DIESEL_1)
    FUEL_TYPE_DIESEL_1 = 3,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_DIESEL_2)
    FUEL_TYPE_DIESEL_2 = 4,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_BIODIESEL)
    FUEL_TYPE_BIODIESEL = 5,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_E85)
    FUEL_TYPE_E85 = 6,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_LPG)
    FUEL_TYPE_LPG = 7,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_CNG)
    FUEL_TYPE_CNG = 8,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_LNG)
    FUEL_TYPE_LNG = 9,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_ELECTRIC)
    FUEL_TYPE_ELECTRIC = 10,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_HYDROGEN)
    FUEL_TYPE_HYDROGEN = 11,
    // @@protoc_insertion_point(enum_value:FuelType.FUEL_TYPE_OTHER)
    FUEL_TYPE_OTHER = 12,
}

impl ::protobuf::Enum for FuelType {
    const NAME: &'static str = "FuelType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FuelType> {
        match value {
            0 => ::std::option::Option::Some(FuelType::FUEL_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(FuelType::FUEL_TYPE_UNLEADED),
            2 => ::std::option::Option::Some(FuelType::FUEL_TYPE_LEADED),
            3 => ::std::option::Option::Some(FuelType::FUEL_TYPE_DIESEL_1),
            4 => ::std::option::Option::Some(FuelType::FUEL_TYPE_DIESEL_2),
            5 => ::std::option::Option::Some(FuelType::FUEL_TYPE_BIODIESEL),
            6 => ::std::option::Option::Some(FuelType::FUEL_TYPE_E85),
            7 => ::std::option::Option::Some(FuelType::FUEL_TYPE_LPG),
            8 => ::std::option::Option::Some(FuelType::FUEL_TYPE_CNG),
            9 => ::std::option::Option::Some(FuelType::FUEL_TYPE_LNG),
            10 => ::std::option::Option::Some(FuelType::FUEL_TYPE_ELECTRIC),
            11 => ::std::option::Option::Some(FuelType::FUEL_TYPE_HYDROGEN),
            12 => ::std::option::Option::Some(FuelType::FUEL_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FuelType> {
        match str {
            "FUEL_TYPE_UNKNOWN" => ::std::option::Option::Some(FuelType::FUEL_TYPE_UNKNOWN),
            "FUEL_TYPE_UNLEADED" => ::std::option::Option::Some(FuelType::FUEL_TYPE_UNLEADED),
            "FUEL_TYPE_LEADED" => ::std::option::Option::Some(FuelType::FUEL_TYPE_LEADED),
            "FUEL_TYPE_DIESEL_1" => ::std::option::Option::Some(FuelType::FUEL_TYPE_DIESEL_1),
            "FUEL_TYPE_DIESEL_2" => ::std::option::Option::Some(FuelType::FUEL_TYPE_DIESEL_2),
            "FUEL_TYPE_BIODIESEL" => ::std::option::Option::Some(FuelType::FUEL_TYPE_BIODIESEL),
            "FUEL_TYPE_E85" => ::std::option::Option::Some(FuelType::FUEL_TYPE_E85),
            "FUEL_TYPE_LPG" => ::std::option::Option::Some(FuelType::FUEL_TYPE_LPG),
            "FUEL_TYPE_CNG" => ::std::option::Option::Some(FuelType::FUEL_TYPE_CNG),
            "FUEL_TYPE_LNG" => ::std::option::Option::Some(FuelType::FUEL_TYPE_LNG),
            "FUEL_TYPE_ELECTRIC" => ::std::option::Option::Some(FuelType::FUEL_TYPE_ELECTRIC),
            "FUEL_TYPE_HYDROGEN" => ::std::option::Option::Some(FuelType::FUEL_TYPE_HYDROGEN),
            "FUEL_TYPE_OTHER" => ::std::option::Option::Some(FuelType::FUEL_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FuelType] = &[
        FuelType::FUEL_TYPE_UNKNOWN,
        FuelType::FUEL_TYPE_UNLEADED,
        FuelType::FUEL_TYPE_LEADED,
        FuelType::FUEL_TYPE_DIESEL_1,
        FuelType::FUEL_TYPE_DIESEL_2,
        FuelType::FUEL_TYPE_BIODIESEL,
        FuelType::FUEL_TYPE_E85,
        FuelType::FUEL_TYPE_LPG,
        FuelType::FUEL_TYPE_CNG,
        FuelType::FUEL_TYPE_LNG,
        FuelType::FUEL_TYPE_ELECTRIC,
        FuelType::FUEL_TYPE_HYDROGEN,
        FuelType::FUEL_TYPE_OTHER,
    ];
}

impl ::protobuf::EnumFull for FuelType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FuelType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FuelType {
    fn default() -> Self {
        FuelType::FUEL_TYPE_UNKNOWN
    }
}

impl FuelType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FuelType>("FuelType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EvConnectorType)
pub enum EvConnectorType {
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_UNKNOWN)
    EV_CONNECTOR_TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_J1772)
    EV_CONNECTOR_TYPE_J1772 = 1,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_MENNEKES)
    EV_CONNECTOR_TYPE_MENNEKES = 2,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_CHADEMO)
    EV_CONNECTOR_TYPE_CHADEMO = 3,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_COMBO_1)
    EV_CONNECTOR_TYPE_COMBO_1 = 4,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_COMBO_2)
    EV_CONNECTOR_TYPE_COMBO_2 = 5,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_TESLA_ROADSTER)
    EV_CONNECTOR_TYPE_TESLA_ROADSTER = 6,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_TESLA_HPWC)
    EV_CONNECTOR_TYPE_TESLA_HPWC = 7,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER)
    EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER = 8,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_GBT)
    EV_CONNECTOR_TYPE_GBT = 9,
    // @@protoc_insertion_point(enum_value:EvConnectorType.EV_CONNECTOR_TYPE_OTHER)
    EV_CONNECTOR_TYPE_OTHER = 101,
}

impl ::protobuf::Enum for EvConnectorType {
    const NAME: &'static str = "EvConnectorType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EvConnectorType> {
        match value {
            0 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_J1772),
            2 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_MENNEKES),
            3 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_CHADEMO),
            4 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_COMBO_1),
            5 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_COMBO_2),
            6 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_TESLA_ROADSTER),
            7 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_TESLA_HPWC),
            8 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER),
            9 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_GBT),
            101 => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EvConnectorType> {
        match str {
            "EV_CONNECTOR_TYPE_UNKNOWN" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_UNKNOWN),
            "EV_CONNECTOR_TYPE_J1772" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_J1772),
            "EV_CONNECTOR_TYPE_MENNEKES" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_MENNEKES),
            "EV_CONNECTOR_TYPE_CHADEMO" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_CHADEMO),
            "EV_CONNECTOR_TYPE_COMBO_1" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_COMBO_1),
            "EV_CONNECTOR_TYPE_COMBO_2" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_COMBO_2),
            "EV_CONNECTOR_TYPE_TESLA_ROADSTER" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_TESLA_ROADSTER),
            "EV_CONNECTOR_TYPE_TESLA_HPWC" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_TESLA_HPWC),
            "EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER),
            "EV_CONNECTOR_TYPE_GBT" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_GBT),
            "EV_CONNECTOR_TYPE_OTHER" => ::std::option::Option::Some(EvConnectorType::EV_CONNECTOR_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EvConnectorType] = &[
        EvConnectorType::EV_CONNECTOR_TYPE_UNKNOWN,
        EvConnectorType::EV_CONNECTOR_TYPE_J1772,
        EvConnectorType::EV_CONNECTOR_TYPE_MENNEKES,
        EvConnectorType::EV_CONNECTOR_TYPE_CHADEMO,
        EvConnectorType::EV_CONNECTOR_TYPE_COMBO_1,
        EvConnectorType::EV_CONNECTOR_TYPE_COMBO_2,
        EvConnectorType::EV_CONNECTOR_TYPE_TESLA_ROADSTER,
        EvConnectorType::EV_CONNECTOR_TYPE_TESLA_HPWC,
        EvConnectorType::EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER,
        EvConnectorType::EV_CONNECTOR_TYPE_GBT,
        EvConnectorType::EV_CONNECTOR_TYPE_OTHER,
    ];
}

impl ::protobuf::EnumFull for EvConnectorType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EvConnectorType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EvConnectorType::EV_CONNECTOR_TYPE_UNKNOWN => 0,
            EvConnectorType::EV_CONNECTOR_TYPE_J1772 => 1,
            EvConnectorType::EV_CONNECTOR_TYPE_MENNEKES => 2,
            EvConnectorType::EV_CONNECTOR_TYPE_CHADEMO => 3,
            EvConnectorType::EV_CONNECTOR_TYPE_COMBO_1 => 4,
            EvConnectorType::EV_CONNECTOR_TYPE_COMBO_2 => 5,
            EvConnectorType::EV_CONNECTOR_TYPE_TESLA_ROADSTER => 6,
            EvConnectorType::EV_CONNECTOR_TYPE_TESLA_HPWC => 7,
            EvConnectorType::EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER => 8,
            EvConnectorType::EV_CONNECTOR_TYPE_GBT => 9,
            EvConnectorType::EV_CONNECTOR_TYPE_OTHER => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EvConnectorType {
    fn default() -> Self {
        EvConnectorType::EV_CONNECTOR_TYPE_UNKNOWN
    }
}

impl EvConnectorType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EvConnectorType>("EvConnectorType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VideoCodecResolutionType)
pub enum VideoCodecResolutionType {
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_800x480)
    VIDEO_800x480 = 1,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_1280x720)
    VIDEO_1280x720 = 2,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_1920x1080)
    VIDEO_1920x1080 = 3,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_2560x1440)
    VIDEO_2560x1440 = 4,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_3840x2160)
    VIDEO_3840x2160 = 5,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_720x1280)
    VIDEO_720x1280 = 6,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_1080x1920)
    VIDEO_1080x1920 = 7,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_1440x2560)
    VIDEO_1440x2560 = 8,
    // @@protoc_insertion_point(enum_value:VideoCodecResolutionType.VIDEO_2160x3840)
    VIDEO_2160x3840 = 9,
}

impl ::protobuf::Enum for VideoCodecResolutionType {
    const NAME: &'static str = "VideoCodecResolutionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VideoCodecResolutionType> {
        match value {
            1 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_800x480),
            2 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1280x720),
            3 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1920x1080),
            4 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_2560x1440),
            5 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_3840x2160),
            6 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_720x1280),
            7 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1080x1920),
            8 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1440x2560),
            9 => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_2160x3840),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VideoCodecResolutionType> {
        match str {
            "VIDEO_800x480" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_800x480),
            "VIDEO_1280x720" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1280x720),
            "VIDEO_1920x1080" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1920x1080),
            "VIDEO_2560x1440" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_2560x1440),
            "VIDEO_3840x2160" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_3840x2160),
            "VIDEO_720x1280" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_720x1280),
            "VIDEO_1080x1920" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1080x1920),
            "VIDEO_1440x2560" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_1440x2560),
            "VIDEO_2160x3840" => ::std::option::Option::Some(VideoCodecResolutionType::VIDEO_2160x3840),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VideoCodecResolutionType] = &[
        VideoCodecResolutionType::VIDEO_800x480,
        VideoCodecResolutionType::VIDEO_1280x720,
        VideoCodecResolutionType::VIDEO_1920x1080,
        VideoCodecResolutionType::VIDEO_2560x1440,
        VideoCodecResolutionType::VIDEO_3840x2160,
        VideoCodecResolutionType::VIDEO_720x1280,
        VideoCodecResolutionType::VIDEO_1080x1920,
        VideoCodecResolutionType::VIDEO_1440x2560,
        VideoCodecResolutionType::VIDEO_2160x3840,
    ];
}

impl ::protobuf::EnumFull for VideoCodecResolutionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VideoCodecResolutionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VideoCodecResolutionType::VIDEO_800x480 => 0,
            VideoCodecResolutionType::VIDEO_1280x720 => 1,
            VideoCodecResolutionType::VIDEO_1920x1080 => 2,
            VideoCodecResolutionType::VIDEO_2560x1440 => 3,
            VideoCodecResolutionType::VIDEO_3840x2160 => 4,
            VideoCodecResolutionType::VIDEO_720x1280 => 5,
            VideoCodecResolutionType::VIDEO_1080x1920 => 6,
            VideoCodecResolutionType::VIDEO_1440x2560 => 7,
            VideoCodecResolutionType::VIDEO_2160x3840 => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for VideoCodecResolutionType {
    fn default() -> Self {
        VideoCodecResolutionType::VIDEO_800x480
    }
}

impl VideoCodecResolutionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VideoCodecResolutionType>("VideoCodecResolutionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VideoFrameRateType)
pub enum VideoFrameRateType {
    // @@protoc_insertion_point(enum_value:VideoFrameRateType.VIDEO_FPS_60)
    VIDEO_FPS_60 = 1,
    // @@protoc_insertion_point(enum_value:VideoFrameRateType.VIDEO_FPS_30)
    VIDEO_FPS_30 = 2,
}

impl ::protobuf::Enum for VideoFrameRateType {
    const NAME: &'static str = "VideoFrameRateType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VideoFrameRateType> {
        match value {
            1 => ::std::option::Option::Some(VideoFrameRateType::VIDEO_FPS_60),
            2 => ::std::option::Option::Some(VideoFrameRateType::VIDEO_FPS_30),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VideoFrameRateType> {
        match str {
            "VIDEO_FPS_60" => ::std::option::Option::Some(VideoFrameRateType::VIDEO_FPS_60),
            "VIDEO_FPS_30" => ::std::option::Option::Some(VideoFrameRateType::VIDEO_FPS_30),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VideoFrameRateType] = &[
        VideoFrameRateType::VIDEO_FPS_60,
        VideoFrameRateType::VIDEO_FPS_30,
    ];
}

impl ::protobuf::EnumFull for VideoFrameRateType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VideoFrameRateType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VideoFrameRateType::VIDEO_FPS_60 => 0,
            VideoFrameRateType::VIDEO_FPS_30 => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for VideoFrameRateType {
    fn default() -> Self {
        VideoFrameRateType::VIDEO_FPS_60
    }
}

impl VideoFrameRateType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VideoFrameRateType>("VideoFrameRateType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaCodecType)
pub enum MediaCodecType {
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_AUDIO_PCM)
    MEDIA_CODEC_AUDIO_PCM = 1,
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_AUDIO_AAC_LC)
    MEDIA_CODEC_AUDIO_AAC_LC = 2,
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_VIDEO_H264_BP)
    MEDIA_CODEC_VIDEO_H264_BP = 3,
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_AUDIO_AAC_LC_ADTS)
    MEDIA_CODEC_AUDIO_AAC_LC_ADTS = 4,
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_VIDEO_VP9)
    MEDIA_CODEC_VIDEO_VP9 = 5,
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_VIDEO_AV1)
    MEDIA_CODEC_VIDEO_AV1 = 6,
    // @@protoc_insertion_point(enum_value:MediaCodecType.MEDIA_CODEC_VIDEO_H265)
    MEDIA_CODEC_VIDEO_H265 = 7,
}

impl ::protobuf::Enum for MediaCodecType {
    const NAME: &'static str = "MediaCodecType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaCodecType> {
        match value {
            1 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_AUDIO_PCM),
            2 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC),
            3 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_H264_BP),
            4 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC_ADTS),
            5 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_VP9),
            6 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_AV1),
            7 => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_H265),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaCodecType> {
        match str {
            "MEDIA_CODEC_AUDIO_PCM" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_AUDIO_PCM),
            "MEDIA_CODEC_AUDIO_AAC_LC" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC),
            "MEDIA_CODEC_VIDEO_H264_BP" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_H264_BP),
            "MEDIA_CODEC_AUDIO_AAC_LC_ADTS" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC_ADTS),
            "MEDIA_CODEC_VIDEO_VP9" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_VP9),
            "MEDIA_CODEC_VIDEO_AV1" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_AV1),
            "MEDIA_CODEC_VIDEO_H265" => ::std::option::Option::Some(MediaCodecType::MEDIA_CODEC_VIDEO_H265),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaCodecType] = &[
        MediaCodecType::MEDIA_CODEC_AUDIO_PCM,
        MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC,
        MediaCodecType::MEDIA_CODEC_VIDEO_H264_BP,
        MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC_ADTS,
        MediaCodecType::MEDIA_CODEC_VIDEO_VP9,
        MediaCodecType::MEDIA_CODEC_VIDEO_AV1,
        MediaCodecType::MEDIA_CODEC_VIDEO_H265,
    ];
}

impl ::protobuf::EnumFull for MediaCodecType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaCodecType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MediaCodecType::MEDIA_CODEC_AUDIO_PCM => 0,
            MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC => 1,
            MediaCodecType::MEDIA_CODEC_VIDEO_H264_BP => 2,
            MediaCodecType::MEDIA_CODEC_AUDIO_AAC_LC_ADTS => 3,
            MediaCodecType::MEDIA_CODEC_VIDEO_VP9 => 4,
            MediaCodecType::MEDIA_CODEC_VIDEO_AV1 => 5,
            MediaCodecType::MEDIA_CODEC_VIDEO_H265 => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MediaCodecType {
    fn default() -> Self {
        MediaCodecType::MEDIA_CODEC_AUDIO_PCM
    }
}

impl MediaCodecType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaCodecType>("MediaCodecType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AudioStreamType)
pub enum AudioStreamType {
    // @@protoc_insertion_point(enum_value:AudioStreamType.AUDIO_STREAM_GUIDANCE)
    AUDIO_STREAM_GUIDANCE = 1,
    // @@protoc_insertion_point(enum_value:AudioStreamType.AUDIO_STREAM_SYSTEM_AUDIO)
    AUDIO_STREAM_SYSTEM_AUDIO = 2,
    // @@protoc_insertion_point(enum_value:AudioStreamType.AUDIO_STREAM_MEDIA)
    AUDIO_STREAM_MEDIA = 3,
    // @@protoc_insertion_point(enum_value:AudioStreamType.AUDIO_STREAM_TELEPHONY)
    AUDIO_STREAM_TELEPHONY = 4,
}

impl ::protobuf::Enum for AudioStreamType {
    const NAME: &'static str = "AudioStreamType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioStreamType> {
        match value {
            1 => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_GUIDANCE),
            2 => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_SYSTEM_AUDIO),
            3 => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_MEDIA),
            4 => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_TELEPHONY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AudioStreamType> {
        match str {
            "AUDIO_STREAM_GUIDANCE" => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_GUIDANCE),
            "AUDIO_STREAM_SYSTEM_AUDIO" => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_SYSTEM_AUDIO),
            "AUDIO_STREAM_MEDIA" => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_MEDIA),
            "AUDIO_STREAM_TELEPHONY" => ::std::option::Option::Some(AudioStreamType::AUDIO_STREAM_TELEPHONY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AudioStreamType] = &[
        AudioStreamType::AUDIO_STREAM_GUIDANCE,
        AudioStreamType::AUDIO_STREAM_SYSTEM_AUDIO,
        AudioStreamType::AUDIO_STREAM_MEDIA,
        AudioStreamType::AUDIO_STREAM_TELEPHONY,
    ];
}

impl ::protobuf::EnumFull for AudioStreamType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AudioStreamType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AudioStreamType::AUDIO_STREAM_GUIDANCE => 0,
            AudioStreamType::AUDIO_STREAM_SYSTEM_AUDIO => 1,
            AudioStreamType::AUDIO_STREAM_MEDIA => 2,
            AudioStreamType::AUDIO_STREAM_TELEPHONY => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AudioStreamType {
    fn default() -> Self {
        AudioStreamType::AUDIO_STREAM_GUIDANCE
    }
}

impl AudioStreamType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AudioStreamType>("AudioStreamType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DisplayType)
pub enum DisplayType {
    // @@protoc_insertion_point(enum_value:DisplayType.DISPLAY_TYPE_MAIN)
    DISPLAY_TYPE_MAIN = 0,
    // @@protoc_insertion_point(enum_value:DisplayType.DISPLAY_TYPE_CLUSTER)
    DISPLAY_TYPE_CLUSTER = 1,
    // @@protoc_insertion_point(enum_value:DisplayType.DISPLAY_TYPE_AUXILIARY)
    DISPLAY_TYPE_AUXILIARY = 2,
}

impl ::protobuf::Enum for DisplayType {
    const NAME: &'static str = "DisplayType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DisplayType> {
        match value {
            0 => ::std::option::Option::Some(DisplayType::DISPLAY_TYPE_MAIN),
            1 => ::std::option::Option::Some(DisplayType::DISPLAY_TYPE_CLUSTER),
            2 => ::std::option::Option::Some(DisplayType::DISPLAY_TYPE_AUXILIARY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DisplayType> {
        match str {
            "DISPLAY_TYPE_MAIN" => ::std::option::Option::Some(DisplayType::DISPLAY_TYPE_MAIN),
            "DISPLAY_TYPE_CLUSTER" => ::std::option::Option::Some(DisplayType::DISPLAY_TYPE_CLUSTER),
            "DISPLAY_TYPE_AUXILIARY" => ::std::option::Option::Some(DisplayType::DISPLAY_TYPE_AUXILIARY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DisplayType] = &[
        DisplayType::DISPLAY_TYPE_MAIN,
        DisplayType::DISPLAY_TYPE_CLUSTER,
        DisplayType::DISPLAY_TYPE_AUXILIARY,
    ];
}

impl ::protobuf::EnumFull for DisplayType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DisplayType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DisplayType {
    fn default() -> Self {
        DisplayType::DISPLAY_TYPE_MAIN
    }
}

impl DisplayType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DisplayType>("DisplayType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:UiTheme)
pub enum UiTheme {
    // @@protoc_insertion_point(enum_value:UiTheme.UI_THEME_AUTOMATIC)
    UI_THEME_AUTOMATIC = 0,
    // @@protoc_insertion_point(enum_value:UiTheme.UI_THEME_LIGHT)
    UI_THEME_LIGHT = 1,
    // @@protoc_insertion_point(enum_value:UiTheme.UI_THEME_DARK)
    UI_THEME_DARK = 2,
}

impl ::protobuf::Enum for UiTheme {
    const NAME: &'static str = "UiTheme";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UiTheme> {
        match value {
            0 => ::std::option::Option::Some(UiTheme::UI_THEME_AUTOMATIC),
            1 => ::std::option::Option::Some(UiTheme::UI_THEME_LIGHT),
            2 => ::std::option::Option::Some(UiTheme::UI_THEME_DARK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<UiTheme> {
        match str {
            "UI_THEME_AUTOMATIC" => ::std::option::Option::Some(UiTheme::UI_THEME_AUTOMATIC),
            "UI_THEME_LIGHT" => ::std::option::Option::Some(UiTheme::UI_THEME_LIGHT),
            "UI_THEME_DARK" => ::std::option::Option::Some(UiTheme::UI_THEME_DARK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UiTheme] = &[
        UiTheme::UI_THEME_AUTOMATIC,
        UiTheme::UI_THEME_LIGHT,
        UiTheme::UI_THEME_DARK,
    ];
}

impl ::protobuf::EnumFull for UiTheme {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("UiTheme").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for UiTheme {
    fn default() -> Self {
        UiTheme::UI_THEME_AUTOMATIC
    }
}

impl UiTheme {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UiTheme>("UiTheme")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TouchScreenType)
pub enum TouchScreenType {
    // @@protoc_insertion_point(enum_value:TouchScreenType.CAPACITIVE)
    CAPACITIVE = 1,
    // @@protoc_insertion_point(enum_value:TouchScreenType.RESISTIVE)
    RESISTIVE = 2,
    // @@protoc_insertion_point(enum_value:TouchScreenType.INFRARED)
    INFRARED = 3,
}

impl ::protobuf::Enum for TouchScreenType {
    const NAME: &'static str = "TouchScreenType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TouchScreenType> {
        match value {
            1 => ::std::option::Option::Some(TouchScreenType::CAPACITIVE),
            2 => ::std::option::Option::Some(TouchScreenType::RESISTIVE),
            3 => ::std::option::Option::Some(TouchScreenType::INFRARED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TouchScreenType> {
        match str {
            "CAPACITIVE" => ::std::option::Option::Some(TouchScreenType::CAPACITIVE),
            "RESISTIVE" => ::std::option::Option::Some(TouchScreenType::RESISTIVE),
            "INFRARED" => ::std::option::Option::Some(TouchScreenType::INFRARED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TouchScreenType] = &[
        TouchScreenType::CAPACITIVE,
        TouchScreenType::RESISTIVE,
        TouchScreenType::INFRARED,
    ];
}

impl ::protobuf::EnumFull for TouchScreenType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TouchScreenType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TouchScreenType::CAPACITIVE => 0,
            TouchScreenType::RESISTIVE => 1,
            TouchScreenType::INFRARED => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TouchScreenType {
    fn default() -> Self {
        TouchScreenType::CAPACITIVE
    }
}

impl TouchScreenType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TouchScreenType>("TouchScreenType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BluetoothPairingMethod)
pub enum BluetoothPairingMethod {
    // @@protoc_insertion_point(enum_value:BluetoothPairingMethod.BLUETOOTH_PAIRING_UNAVAILABLE)
    BLUETOOTH_PAIRING_UNAVAILABLE = -1,
    // @@protoc_insertion_point(enum_value:BluetoothPairingMethod.BLUETOOTH_PAIRING_OOB)
    BLUETOOTH_PAIRING_OOB = 1,
    // @@protoc_insertion_point(enum_value:BluetoothPairingMethod.BLUETOOTH_PAIRING_NUMERIC_COMPARISON)
    BLUETOOTH_PAIRING_NUMERIC_COMPARISON = 2,
    // @@protoc_insertion_point(enum_value:BluetoothPairingMethod.BLUETOOTH_PAIRING_PASSKEY_ENTRY)
    BLUETOOTH_PAIRING_PASSKEY_ENTRY = 3,
    // @@protoc_insertion_point(enum_value:BluetoothPairingMethod.BLUETOOTH_PAIRING_PIN)
    BLUETOOTH_PAIRING_PIN = 4,
}

impl ::protobuf::Enum for BluetoothPairingMethod {
    const NAME: &'static str = "BluetoothPairingMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BluetoothPairingMethod> {
        match value {
            -1 => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE),
            1 => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_OOB),
            2 => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_NUMERIC_COMPARISON),
            3 => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_PASSKEY_ENTRY),
            4 => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_PIN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BluetoothPairingMethod> {
        match str {
            "BLUETOOTH_PAIRING_UNAVAILABLE" => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE),
            "BLUETOOTH_PAIRING_OOB" => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_OOB),
            "BLUETOOTH_PAIRING_NUMERIC_COMPARISON" => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_NUMERIC_COMPARISON),
            "BLUETOOTH_PAIRING_PASSKEY_ENTRY" => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_PASSKEY_ENTRY),
            "BLUETOOTH_PAIRING_PIN" => ::std::option::Option::Some(BluetoothPairingMethod::BLUETOOTH_PAIRING_PIN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BluetoothPairingMethod] = &[
        BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE,
        BluetoothPairingMethod::BLUETOOTH_PAIRING_OOB,
        BluetoothPairingMethod::BLUETOOTH_PAIRING_NUMERIC_COMPARISON,
        BluetoothPairingMethod::BLUETOOTH_PAIRING_PASSKEY_ENTRY,
        BluetoothPairingMethod::BLUETOOTH_PAIRING_PIN,
    ];
}

impl ::protobuf::EnumFull for BluetoothPairingMethod {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BluetoothPairingMethod").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE => 0,
            BluetoothPairingMethod::BLUETOOTH_PAIRING_OOB => 1,
            BluetoothPairingMethod::BLUETOOTH_PAIRING_NUMERIC_COMPARISON => 2,
            BluetoothPairingMethod::BLUETOOTH_PAIRING_PASSKEY_ENTRY => 3,
            BluetoothPairingMethod::BLUETOOTH_PAIRING_PIN => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BluetoothPairingMethod {
    fn default() -> Self {
        BluetoothPairingMethod::BLUETOOTH_PAIRING_UNAVAILABLE
    }
}

impl BluetoothPairingMethod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BluetoothPairingMethod>("BluetoothPairingMethod")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TrafficServiceType)
pub enum TrafficServiceType {
    // @@protoc_insertion_point(enum_value:TrafficServiceType.NO_TRAFFIC_SERVICE)
    NO_TRAFFIC_SERVICE = 0,
    // @@protoc_insertion_point(enum_value:TrafficServiceType.TMC_TRAFFIC_SERVICE)
    TMC_TRAFFIC_SERVICE = 1,
}

impl ::protobuf::Enum for TrafficServiceType {
    const NAME: &'static str = "TrafficServiceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrafficServiceType> {
        match value {
            0 => ::std::option::Option::Some(TrafficServiceType::NO_TRAFFIC_SERVICE),
            1 => ::std::option::Option::Some(TrafficServiceType::TMC_TRAFFIC_SERVICE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TrafficServiceType> {
        match str {
            "NO_TRAFFIC_SERVICE" => ::std::option::Option::Some(TrafficServiceType::NO_TRAFFIC_SERVICE),
            "TMC_TRAFFIC_SERVICE" => ::std::option::Option::Some(TrafficServiceType::TMC_TRAFFIC_SERVICE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TrafficServiceType] = &[
        TrafficServiceType::NO_TRAFFIC_SERVICE,
        TrafficServiceType::TMC_TRAFFIC_SERVICE,
    ];
}

impl ::protobuf::EnumFull for TrafficServiceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TrafficServiceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TrafficServiceType {
    fn default() -> Self {
        TrafficServiceType::NO_TRAFFIC_SERVICE
    }
}

impl TrafficServiceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TrafficServiceType>("TrafficServiceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RdsType)
pub enum RdsType {
    // @@protoc_insertion_point(enum_value:RdsType.NO_RDS)
    NO_RDS = 0,
    // @@protoc_insertion_point(enum_value:RdsType.RDS)
    RDS = 1,
    // @@protoc_insertion_point(enum_value:RdsType.RBDS)
    RBDS = 2,
}

impl ::protobuf::Enum for RdsType {
    const NAME: &'static str = "RdsType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RdsType> {
        match value {
            0 => ::std::option::Option::Some(RdsType::NO_RDS),
            1 => ::std::option::Option::Some(RdsType::RDS),
            2 => ::std::option::Option::Some(RdsType::RBDS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RdsType> {
        match str {
            "NO_RDS" => ::std::option::Option::Some(RdsType::NO_RDS),
            "RDS" => ::std::option::Option::Some(RdsType::RDS),
            "RBDS" => ::std::option::Option::Some(RdsType::RBDS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RdsType] = &[
        RdsType::NO_RDS,
        RdsType::RDS,
        RdsType::RBDS,
    ];
}

impl ::protobuf::EnumFull for RdsType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RdsType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RdsType {
    fn default() -> Self {
        RdsType::NO_RDS
    }
}

impl RdsType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RdsType>("RdsType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RadioType)
pub enum RadioType {
    // @@protoc_insertion_point(enum_value:RadioType.AM_RADIO)
    AM_RADIO = 0,
    // @@protoc_insertion_point(enum_value:RadioType.FM_RADIO)
    FM_RADIO = 1,
    // @@protoc_insertion_point(enum_value:RadioType.AM_HD_RADIO)
    AM_HD_RADIO = 2,
    // @@protoc_insertion_point(enum_value:RadioType.FM_HD_RADIO)
    FM_HD_RADIO = 3,
    // @@protoc_insertion_point(enum_value:RadioType.DAB_RADIO)
    DAB_RADIO = 4,
    // @@protoc_insertion_point(enum_value:RadioType.XM_RADIO)
    XM_RADIO = 5,
}

impl ::protobuf::Enum for RadioType {
    const NAME: &'static str = "RadioType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RadioType> {
        match value {
            0 => ::std::option::Option::Some(RadioType::AM_RADIO),
            1 => ::std::option::Option::Some(RadioType::FM_RADIO),
            2 => ::std::option::Option::Some(RadioType::AM_HD_RADIO),
            3 => ::std::option::Option::Some(RadioType::FM_HD_RADIO),
            4 => ::std::option::Option::Some(RadioType::DAB_RADIO),
            5 => ::std::option::Option::Some(RadioType::XM_RADIO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RadioType> {
        match str {
            "AM_RADIO" => ::std::option::Option::Some(RadioType::AM_RADIO),
            "FM_RADIO" => ::std::option::Option::Some(RadioType::FM_RADIO),
            "AM_HD_RADIO" => ::std::option::Option::Some(RadioType::AM_HD_RADIO),
            "FM_HD_RADIO" => ::std::option::Option::Some(RadioType::FM_HD_RADIO),
            "DAB_RADIO" => ::std::option::Option::Some(RadioType::DAB_RADIO),
            "XM_RADIO" => ::std::option::Option::Some(RadioType::XM_RADIO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RadioType] = &[
        RadioType::AM_RADIO,
        RadioType::FM_RADIO,
        RadioType::AM_HD_RADIO,
        RadioType::FM_HD_RADIO,
        RadioType::DAB_RADIO,
        RadioType::XM_RADIO,
    ];
}

impl ::protobuf::EnumFull for RadioType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RadioType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RadioType {
    fn default() -> Self {
        RadioType::AM_RADIO
    }
}

impl RadioType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RadioType>("RadioType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ItuRegion)
pub enum ItuRegion {
    // @@protoc_insertion_point(enum_value:ItuRegion.RADIO_REGION_NONE)
    RADIO_REGION_NONE = 0,
    // @@protoc_insertion_point(enum_value:ItuRegion.RADIO_REGION_ITU_1)
    RADIO_REGION_ITU_1 = 1,
    // @@protoc_insertion_point(enum_value:ItuRegion.RADIO_REGION_ITU_2)
    RADIO_REGION_ITU_2 = 2,
    // @@protoc_insertion_point(enum_value:ItuRegion.RADIO_REGION_OIRT)
    RADIO_REGION_OIRT = 3,
    // @@protoc_insertion_point(enum_value:ItuRegion.RADIO_REGION_JAPAN)
    RADIO_REGION_JAPAN = 4,
    // @@protoc_insertion_point(enum_value:ItuRegion.RADIO_REGION_KOREA)
    RADIO_REGION_KOREA = 5,
}

impl ::protobuf::Enum for ItuRegion {
    const NAME: &'static str = "ItuRegion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ItuRegion> {
        match value {
            0 => ::std::option::Option::Some(ItuRegion::RADIO_REGION_NONE),
            1 => ::std::option::Option::Some(ItuRegion::RADIO_REGION_ITU_1),
            2 => ::std::option::Option::Some(ItuRegion::RADIO_REGION_ITU_2),
            3 => ::std::option::Option::Some(ItuRegion::RADIO_REGION_OIRT),
            4 => ::std::option::Option::Some(ItuRegion::RADIO_REGION_JAPAN),
            5 => ::std::option::Option::Some(ItuRegion::RADIO_REGION_KOREA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ItuRegion> {
        match str {
            "RADIO_REGION_NONE" => ::std::option::Option::Some(ItuRegion::RADIO_REGION_NONE),
            "RADIO_REGION_ITU_1" => ::std::option::Option::Some(ItuRegion::RADIO_REGION_ITU_1),
            "RADIO_REGION_ITU_2" => ::std::option::Option::Some(ItuRegion::RADIO_REGION_ITU_2),
            "RADIO_REGION_OIRT" => ::std::option::Option::Some(ItuRegion::RADIO_REGION_OIRT),
            "RADIO_REGION_JAPAN" => ::std::option::Option::Some(ItuRegion::RADIO_REGION_JAPAN),
            "RADIO_REGION_KOREA" => ::std::option::Option::Some(ItuRegion::RADIO_REGION_KOREA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ItuRegion] = &[
        ItuRegion::RADIO_REGION_NONE,
        ItuRegion::RADIO_REGION_ITU_1,
        ItuRegion::RADIO_REGION_ITU_2,
        ItuRegion::RADIO_REGION_OIRT,
        ItuRegion::RADIO_REGION_JAPAN,
        ItuRegion::RADIO_REGION_KOREA,
    ];
}

impl ::protobuf::EnumFull for ItuRegion {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ItuRegion").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ItuRegion {
    fn default() -> Self {
        ItuRegion::RADIO_REGION_NONE
    }
}

impl ItuRegion {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ItuRegion>("ItuRegion")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NavFocusType)
pub enum NavFocusType {
    // @@protoc_insertion_point(enum_value:NavFocusType.NAV_FOCUS_NATIVE)
    NAV_FOCUS_NATIVE = 1,
    // @@protoc_insertion_point(enum_value:NavFocusType.NAV_FOCUS_PROJECTED)
    NAV_FOCUS_PROJECTED = 2,
}

impl ::protobuf::Enum for NavFocusType {
    const NAME: &'static str = "NavFocusType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NavFocusType> {
        match value {
            1 => ::std::option::Option::Some(NavFocusType::NAV_FOCUS_NATIVE),
            2 => ::std::option::Option::Some(NavFocusType::NAV_FOCUS_PROJECTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NavFocusType> {
        match str {
            "NAV_FOCUS_NATIVE" => ::std::option::Option::Some(NavFocusType::NAV_FOCUS_NATIVE),
            "NAV_FOCUS_PROJECTED" => ::std::option::Option::Some(NavFocusType::NAV_FOCUS_PROJECTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NavFocusType] = &[
        NavFocusType::NAV_FOCUS_NATIVE,
        NavFocusType::NAV_FOCUS_PROJECTED,
    ];
}

impl ::protobuf::EnumFull for NavFocusType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NavFocusType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NavFocusType::NAV_FOCUS_NATIVE => 0,
            NavFocusType::NAV_FOCUS_PROJECTED => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NavFocusType {
    fn default() -> Self {
        NavFocusType::NAV_FOCUS_NATIVE
    }
}

impl NavFocusType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NavFocusType>("NavFocusType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ByeByeReason)
pub enum ByeByeReason {
    // @@protoc_insertion_point(enum_value:ByeByeReason.USER_SELECTION)
    USER_SELECTION = 1,
    // @@protoc_insertion_point(enum_value:ByeByeReason.DEVICE_SWITCH)
    DEVICE_SWITCH = 2,
    // @@protoc_insertion_point(enum_value:ByeByeReason.NOT_SUPPORTED)
    NOT_SUPPORTED = 3,
    // @@protoc_insertion_point(enum_value:ByeByeReason.NOT_CURRENTLY_SUPPORTED)
    NOT_CURRENTLY_SUPPORTED = 4,
    // @@protoc_insertion_point(enum_value:ByeByeReason.PROBE_SUPPORTED)
    PROBE_SUPPORTED = 5,
}

impl ::protobuf::Enum for ByeByeReason {
    const NAME: &'static str = "ByeByeReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ByeByeReason> {
        match value {
            1 => ::std::option::Option::Some(ByeByeReason::USER_SELECTION),
            2 => ::std::option::Option::Some(ByeByeReason::DEVICE_SWITCH),
            3 => ::std::option::Option::Some(ByeByeReason::NOT_SUPPORTED),
            4 => ::std::option::Option::Some(ByeByeReason::NOT_CURRENTLY_SUPPORTED),
            5 => ::std::option::Option::Some(ByeByeReason::PROBE_SUPPORTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ByeByeReason> {
        match str {
            "USER_SELECTION" => ::std::option::Option::Some(ByeByeReason::USER_SELECTION),
            "DEVICE_SWITCH" => ::std::option::Option::Some(ByeByeReason::DEVICE_SWITCH),
            "NOT_SUPPORTED" => ::std::option::Option::Some(ByeByeReason::NOT_SUPPORTED),
            "NOT_CURRENTLY_SUPPORTED" => ::std::option::Option::Some(ByeByeReason::NOT_CURRENTLY_SUPPORTED),
            "PROBE_SUPPORTED" => ::std::option::Option::Some(ByeByeReason::PROBE_SUPPORTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ByeByeReason] = &[
        ByeByeReason::USER_SELECTION,
        ByeByeReason::DEVICE_SWITCH,
        ByeByeReason::NOT_SUPPORTED,
        ByeByeReason::NOT_CURRENTLY_SUPPORTED,
        ByeByeReason::PROBE_SUPPORTED,
    ];
}

impl ::protobuf::EnumFull for ByeByeReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ByeByeReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ByeByeReason::USER_SELECTION => 0,
            ByeByeReason::DEVICE_SWITCH => 1,
            ByeByeReason::NOT_SUPPORTED => 2,
            ByeByeReason::NOT_CURRENTLY_SUPPORTED => 3,
            ByeByeReason::PROBE_SUPPORTED => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ByeByeReason {
    fn default() -> Self {
        ByeByeReason::USER_SELECTION
    }
}

impl ByeByeReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ByeByeReason>("ByeByeReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceSessionStatus)
pub enum VoiceSessionStatus {
    // @@protoc_insertion_point(enum_value:VoiceSessionStatus.VOICE_SESSION_START)
    VOICE_SESSION_START = 1,
    // @@protoc_insertion_point(enum_value:VoiceSessionStatus.VOICE_SESSION_END)
    VOICE_SESSION_END = 2,
}

impl ::protobuf::Enum for VoiceSessionStatus {
    const NAME: &'static str = "VoiceSessionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceSessionStatus> {
        match value {
            1 => ::std::option::Option::Some(VoiceSessionStatus::VOICE_SESSION_START),
            2 => ::std::option::Option::Some(VoiceSessionStatus::VOICE_SESSION_END),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceSessionStatus> {
        match str {
            "VOICE_SESSION_START" => ::std::option::Option::Some(VoiceSessionStatus::VOICE_SESSION_START),
            "VOICE_SESSION_END" => ::std::option::Option::Some(VoiceSessionStatus::VOICE_SESSION_END),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceSessionStatus] = &[
        VoiceSessionStatus::VOICE_SESSION_START,
        VoiceSessionStatus::VOICE_SESSION_END,
    ];
}

impl ::protobuf::EnumFull for VoiceSessionStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceSessionStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VoiceSessionStatus::VOICE_SESSION_START => 0,
            VoiceSessionStatus::VOICE_SESSION_END => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for VoiceSessionStatus {
    fn default() -> Self {
        VoiceSessionStatus::VOICE_SESSION_START
    }
}

impl VoiceSessionStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceSessionStatus>("VoiceSessionStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:UserSwitchStatus)
pub enum UserSwitchStatus {
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.STATUS_OK)
    STATUS_OK = 0,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_NO_RFCOMM_CONNECTION)
    ERROR_NO_RFCOMM_CONNECTION = -1,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_BT_CLOSED_BEFORE_START)
    ERROR_BT_CLOSED_BEFORE_START = -2,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_BT_CLOSED_AFTER_START)
    ERROR_BT_CLOSED_AFTER_START = -3,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION)
    ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION = -4,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_PHONE_UNABLE_TO_CONNECT_WIFI)
    ERROR_PHONE_UNABLE_TO_CONNECT_WIFI = -5,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_MULTIPLE_USER_SWITCH_REQUEST)
    ERROR_MULTIPLE_USER_SWITCH_REQUEST = -6,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_HU_INTERNAL)
    ERROR_HU_INTERNAL = -7,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_INVALID_REQUEST)
    ERROR_INVALID_REQUEST = -8,
    // @@protoc_insertion_point(enum_value:UserSwitchStatus.ERROR_REQUEST_TIMEOUT)
    ERROR_REQUEST_TIMEOUT = -9,
}

impl ::protobuf::Enum for UserSwitchStatus {
    const NAME: &'static str = "UserSwitchStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserSwitchStatus> {
        match value {
            0 => ::std::option::Option::Some(UserSwitchStatus::STATUS_OK),
            -1 => ::std::option::Option::Some(UserSwitchStatus::ERROR_NO_RFCOMM_CONNECTION),
            -2 => ::std::option::Option::Some(UserSwitchStatus::ERROR_BT_CLOSED_BEFORE_START),
            -3 => ::std::option::Option::Some(UserSwitchStatus::ERROR_BT_CLOSED_AFTER_START),
            -4 => ::std::option::Option::Some(UserSwitchStatus::ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION),
            -5 => ::std::option::Option::Some(UserSwitchStatus::ERROR_PHONE_UNABLE_TO_CONNECT_WIFI),
            -6 => ::std::option::Option::Some(UserSwitchStatus::ERROR_MULTIPLE_USER_SWITCH_REQUEST),
            -7 => ::std::option::Option::Some(UserSwitchStatus::ERROR_HU_INTERNAL),
            -8 => ::std::option::Option::Some(UserSwitchStatus::ERROR_INVALID_REQUEST),
            -9 => ::std::option::Option::Some(UserSwitchStatus::ERROR_REQUEST_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<UserSwitchStatus> {
        match str {
            "STATUS_OK" => ::std::option::Option::Some(UserSwitchStatus::STATUS_OK),
            "ERROR_NO_RFCOMM_CONNECTION" => ::std::option::Option::Some(UserSwitchStatus::ERROR_NO_RFCOMM_CONNECTION),
            "ERROR_BT_CLOSED_BEFORE_START" => ::std::option::Option::Some(UserSwitchStatus::ERROR_BT_CLOSED_BEFORE_START),
            "ERROR_BT_CLOSED_AFTER_START" => ::std::option::Option::Some(UserSwitchStatus::ERROR_BT_CLOSED_AFTER_START),
            "ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION" => ::std::option::Option::Some(UserSwitchStatus::ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION),
            "ERROR_PHONE_UNABLE_TO_CONNECT_WIFI" => ::std::option::Option::Some(UserSwitchStatus::ERROR_PHONE_UNABLE_TO_CONNECT_WIFI),
            "ERROR_MULTIPLE_USER_SWITCH_REQUEST" => ::std::option::Option::Some(UserSwitchStatus::ERROR_MULTIPLE_USER_SWITCH_REQUEST),
            "ERROR_HU_INTERNAL" => ::std::option::Option::Some(UserSwitchStatus::ERROR_HU_INTERNAL),
            "ERROR_INVALID_REQUEST" => ::std::option::Option::Some(UserSwitchStatus::ERROR_INVALID_REQUEST),
            "ERROR_REQUEST_TIMEOUT" => ::std::option::Option::Some(UserSwitchStatus::ERROR_REQUEST_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UserSwitchStatus] = &[
        UserSwitchStatus::STATUS_OK,
        UserSwitchStatus::ERROR_NO_RFCOMM_CONNECTION,
        UserSwitchStatus::ERROR_BT_CLOSED_BEFORE_START,
        UserSwitchStatus::ERROR_BT_CLOSED_AFTER_START,
        UserSwitchStatus::ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION,
        UserSwitchStatus::ERROR_PHONE_UNABLE_TO_CONNECT_WIFI,
        UserSwitchStatus::ERROR_MULTIPLE_USER_SWITCH_REQUEST,
        UserSwitchStatus::ERROR_HU_INTERNAL,
        UserSwitchStatus::ERROR_INVALID_REQUEST,
        UserSwitchStatus::ERROR_REQUEST_TIMEOUT,
    ];
}

impl ::protobuf::EnumFull for UserSwitchStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("UserSwitchStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            UserSwitchStatus::STATUS_OK => 0,
            UserSwitchStatus::ERROR_NO_RFCOMM_CONNECTION => 1,
            UserSwitchStatus::ERROR_BT_CLOSED_BEFORE_START => 2,
            UserSwitchStatus::ERROR_BT_CLOSED_AFTER_START => 3,
            UserSwitchStatus::ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VERSION => 4,
            UserSwitchStatus::ERROR_PHONE_UNABLE_TO_CONNECT_WIFI => 5,
            UserSwitchStatus::ERROR_MULTIPLE_USER_SWITCH_REQUEST => 6,
            UserSwitchStatus::ERROR_HU_INTERNAL => 7,
            UserSwitchStatus::ERROR_INVALID_REQUEST => 8,
            UserSwitchStatus::ERROR_REQUEST_TIMEOUT => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for UserSwitchStatus {
    fn default() -> Self {
        UserSwitchStatus::STATUS_OK
    }
}

impl UserSwitchStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UserSwitchStatus>("UserSwitchStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorErrorType)
pub enum SensorErrorType {
    // @@protoc_insertion_point(enum_value:SensorErrorType.SENSOR_OK)
    SENSOR_OK = 1,
    // @@protoc_insertion_point(enum_value:SensorErrorType.SENSOR_ERROR_TRANSIENT)
    SENSOR_ERROR_TRANSIENT = 2,
    // @@protoc_insertion_point(enum_value:SensorErrorType.SENSOR_ERROR_PERMANENT)
    SENSOR_ERROR_PERMANENT = 3,
}

impl ::protobuf::Enum for SensorErrorType {
    const NAME: &'static str = "SensorErrorType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorErrorType> {
        match value {
            1 => ::std::option::Option::Some(SensorErrorType::SENSOR_OK),
            2 => ::std::option::Option::Some(SensorErrorType::SENSOR_ERROR_TRANSIENT),
            3 => ::std::option::Option::Some(SensorErrorType::SENSOR_ERROR_PERMANENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SensorErrorType> {
        match str {
            "SENSOR_OK" => ::std::option::Option::Some(SensorErrorType::SENSOR_OK),
            "SENSOR_ERROR_TRANSIENT" => ::std::option::Option::Some(SensorErrorType::SENSOR_ERROR_TRANSIENT),
            "SENSOR_ERROR_PERMANENT" => ::std::option::Option::Some(SensorErrorType::SENSOR_ERROR_PERMANENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorErrorType] = &[
        SensorErrorType::SENSOR_OK,
        SensorErrorType::SENSOR_ERROR_TRANSIENT,
        SensorErrorType::SENSOR_ERROR_PERMANENT,
    ];
}

impl ::protobuf::EnumFull for SensorErrorType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorErrorType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SensorErrorType::SENSOR_OK => 0,
            SensorErrorType::SENSOR_ERROR_TRANSIENT => 1,
            SensorErrorType::SENSOR_ERROR_PERMANENT => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SensorErrorType {
    fn default() -> Self {
        SensorErrorType::SENSOR_OK
    }
}

impl SensorErrorType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorErrorType>("SensorErrorType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Gear)
pub enum Gear {
    // @@protoc_insertion_point(enum_value:Gear.GEAR_NEUTRAL)
    GEAR_NEUTRAL = 0,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_1)
    GEAR_1 = 1,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_2)
    GEAR_2 = 2,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_3)
    GEAR_3 = 3,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_4)
    GEAR_4 = 4,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_5)
    GEAR_5 = 5,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_6)
    GEAR_6 = 6,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_7)
    GEAR_7 = 7,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_8)
    GEAR_8 = 8,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_9)
    GEAR_9 = 9,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_10)
    GEAR_10 = 10,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_DRIVE)
    GEAR_DRIVE = 100,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_PARK)
    GEAR_PARK = 101,
    // @@protoc_insertion_point(enum_value:Gear.GEAR_REVERSE)
    GEAR_REVERSE = 102,
}

impl ::protobuf::Enum for Gear {
    const NAME: &'static str = "Gear";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Gear> {
        match value {
            0 => ::std::option::Option::Some(Gear::GEAR_NEUTRAL),
            1 => ::std::option::Option::Some(Gear::GEAR_1),
            2 => ::std::option::Option::Some(Gear::GEAR_2),
            3 => ::std::option::Option::Some(Gear::GEAR_3),
            4 => ::std::option::Option::Some(Gear::GEAR_4),
            5 => ::std::option::Option::Some(Gear::GEAR_5),
            6 => ::std::option::Option::Some(Gear::GEAR_6),
            7 => ::std::option::Option::Some(Gear::GEAR_7),
            8 => ::std::option::Option::Some(Gear::GEAR_8),
            9 => ::std::option::Option::Some(Gear::GEAR_9),
            10 => ::std::option::Option::Some(Gear::GEAR_10),
            100 => ::std::option::Option::Some(Gear::GEAR_DRIVE),
            101 => ::std::option::Option::Some(Gear::GEAR_PARK),
            102 => ::std::option::Option::Some(Gear::GEAR_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Gear> {
        match str {
            "GEAR_NEUTRAL" => ::std::option::Option::Some(Gear::GEAR_NEUTRAL),
            "GEAR_1" => ::std::option::Option::Some(Gear::GEAR_1),
            "GEAR_2" => ::std::option::Option::Some(Gear::GEAR_2),
            "GEAR_3" => ::std::option::Option::Some(Gear::GEAR_3),
            "GEAR_4" => ::std::option::Option::Some(Gear::GEAR_4),
            "GEAR_5" => ::std::option::Option::Some(Gear::GEAR_5),
            "GEAR_6" => ::std::option::Option::Some(Gear::GEAR_6),
            "GEAR_7" => ::std::option::Option::Some(Gear::GEAR_7),
            "GEAR_8" => ::std::option::Option::Some(Gear::GEAR_8),
            "GEAR_9" => ::std::option::Option::Some(Gear::GEAR_9),
            "GEAR_10" => ::std::option::Option::Some(Gear::GEAR_10),
            "GEAR_DRIVE" => ::std::option::Option::Some(Gear::GEAR_DRIVE),
            "GEAR_PARK" => ::std::option::Option::Some(Gear::GEAR_PARK),
            "GEAR_REVERSE" => ::std::option::Option::Some(Gear::GEAR_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Gear] = &[
        Gear::GEAR_NEUTRAL,
        Gear::GEAR_1,
        Gear::GEAR_2,
        Gear::GEAR_3,
        Gear::GEAR_4,
        Gear::GEAR_5,
        Gear::GEAR_6,
        Gear::GEAR_7,
        Gear::GEAR_8,
        Gear::GEAR_9,
        Gear::GEAR_10,
        Gear::GEAR_DRIVE,
        Gear::GEAR_PARK,
        Gear::GEAR_REVERSE,
    ];
}

impl ::protobuf::EnumFull for Gear {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Gear").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Gear::GEAR_NEUTRAL => 0,
            Gear::GEAR_1 => 1,
            Gear::GEAR_2 => 2,
            Gear::GEAR_3 => 3,
            Gear::GEAR_4 => 4,
            Gear::GEAR_5 => 5,
            Gear::GEAR_6 => 6,
            Gear::GEAR_7 => 7,
            Gear::GEAR_8 => 8,
            Gear::GEAR_9 => 9,
            Gear::GEAR_10 => 10,
            Gear::GEAR_DRIVE => 11,
            Gear::GEAR_PARK => 12,
            Gear::GEAR_REVERSE => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Gear {
    fn default() -> Self {
        Gear::GEAR_NEUTRAL
    }
}

impl Gear {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Gear>("Gear")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DrivingStatus)
pub enum DrivingStatus {
    // @@protoc_insertion_point(enum_value:DrivingStatus.DRIVE_STATUS_UNRESTRICTED)
    DRIVE_STATUS_UNRESTRICTED = 0,
    // @@protoc_insertion_point(enum_value:DrivingStatus.DRIVE_STATUS_NO_VIDEO)
    DRIVE_STATUS_NO_VIDEO = 1,
    // @@protoc_insertion_point(enum_value:DrivingStatus.DRIVE_STATUS_NO_KEYBOARD_INPUT)
    DRIVE_STATUS_NO_KEYBOARD_INPUT = 2,
    // @@protoc_insertion_point(enum_value:DrivingStatus.DRIVE_STATUS_NO_VOICE_INPUT)
    DRIVE_STATUS_NO_VOICE_INPUT = 4,
    // @@protoc_insertion_point(enum_value:DrivingStatus.DRIVE_STATUS_NO_CONFIG)
    DRIVE_STATUS_NO_CONFIG = 8,
    // @@protoc_insertion_point(enum_value:DrivingStatus.DRIVE_STATUS_LIMIT_MESSAGE_LEN)
    DRIVE_STATUS_LIMIT_MESSAGE_LEN = 16,
}

impl ::protobuf::Enum for DrivingStatus {
    const NAME: &'static str = "DrivingStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DrivingStatus> {
        match value {
            0 => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_UNRESTRICTED),
            1 => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_VIDEO),
            2 => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_KEYBOARD_INPUT),
            4 => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_VOICE_INPUT),
            8 => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_CONFIG),
            16 => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_LIMIT_MESSAGE_LEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DrivingStatus> {
        match str {
            "DRIVE_STATUS_UNRESTRICTED" => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_UNRESTRICTED),
            "DRIVE_STATUS_NO_VIDEO" => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_VIDEO),
            "DRIVE_STATUS_NO_KEYBOARD_INPUT" => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_KEYBOARD_INPUT),
            "DRIVE_STATUS_NO_VOICE_INPUT" => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_VOICE_INPUT),
            "DRIVE_STATUS_NO_CONFIG" => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_NO_CONFIG),
            "DRIVE_STATUS_LIMIT_MESSAGE_LEN" => ::std::option::Option::Some(DrivingStatus::DRIVE_STATUS_LIMIT_MESSAGE_LEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DrivingStatus] = &[
        DrivingStatus::DRIVE_STATUS_UNRESTRICTED,
        DrivingStatus::DRIVE_STATUS_NO_VIDEO,
        DrivingStatus::DRIVE_STATUS_NO_KEYBOARD_INPUT,
        DrivingStatus::DRIVE_STATUS_NO_VOICE_INPUT,
        DrivingStatus::DRIVE_STATUS_NO_CONFIG,
        DrivingStatus::DRIVE_STATUS_LIMIT_MESSAGE_LEN,
    ];
}

impl ::protobuf::EnumFull for DrivingStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DrivingStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DrivingStatus::DRIVE_STATUS_UNRESTRICTED => 0,
            DrivingStatus::DRIVE_STATUS_NO_VIDEO => 1,
            DrivingStatus::DRIVE_STATUS_NO_KEYBOARD_INPUT => 2,
            DrivingStatus::DRIVE_STATUS_NO_VOICE_INPUT => 3,
            DrivingStatus::DRIVE_STATUS_NO_CONFIG => 4,
            DrivingStatus::DRIVE_STATUS_LIMIT_MESSAGE_LEN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DrivingStatus {
    fn default() -> Self {
        DrivingStatus::DRIVE_STATUS_UNRESTRICTED
    }
}

impl DrivingStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DrivingStatus>("DrivingStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:HeadLightState)
pub enum HeadLightState {
    // @@protoc_insertion_point(enum_value:HeadLightState.HEAD_LIGHT_STATE_OFF)
    HEAD_LIGHT_STATE_OFF = 1,
    // @@protoc_insertion_point(enum_value:HeadLightState.HEAD_LIGHT_STATE_ON)
    HEAD_LIGHT_STATE_ON = 2,
    // @@protoc_insertion_point(enum_value:HeadLightState.HEAD_LIGHT_STATE_HIGH)
    HEAD_LIGHT_STATE_HIGH = 3,
}

impl ::protobuf::Enum for HeadLightState {
    const NAME: &'static str = "HeadLightState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HeadLightState> {
        match value {
            1 => ::std::option::Option::Some(HeadLightState::HEAD_LIGHT_STATE_OFF),
            2 => ::std::option::Option::Some(HeadLightState::HEAD_LIGHT_STATE_ON),
            3 => ::std::option::Option::Some(HeadLightState::HEAD_LIGHT_STATE_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<HeadLightState> {
        match str {
            "HEAD_LIGHT_STATE_OFF" => ::std::option::Option::Some(HeadLightState::HEAD_LIGHT_STATE_OFF),
            "HEAD_LIGHT_STATE_ON" => ::std::option::Option::Some(HeadLightState::HEAD_LIGHT_STATE_ON),
            "HEAD_LIGHT_STATE_HIGH" => ::std::option::Option::Some(HeadLightState::HEAD_LIGHT_STATE_HIGH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [HeadLightState] = &[
        HeadLightState::HEAD_LIGHT_STATE_OFF,
        HeadLightState::HEAD_LIGHT_STATE_ON,
        HeadLightState::HEAD_LIGHT_STATE_HIGH,
    ];
}

impl ::protobuf::EnumFull for HeadLightState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("HeadLightState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            HeadLightState::HEAD_LIGHT_STATE_OFF => 0,
            HeadLightState::HEAD_LIGHT_STATE_ON => 1,
            HeadLightState::HEAD_LIGHT_STATE_HIGH => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HeadLightState {
    fn default() -> Self {
        HeadLightState::HEAD_LIGHT_STATE_OFF
    }
}

impl HeadLightState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HeadLightState>("HeadLightState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TurnIndicatorState)
pub enum TurnIndicatorState {
    // @@protoc_insertion_point(enum_value:TurnIndicatorState.TURN_INDICATOR_NONE)
    TURN_INDICATOR_NONE = 1,
    // @@protoc_insertion_point(enum_value:TurnIndicatorState.TURN_INDICATOR_LEFT)
    TURN_INDICATOR_LEFT = 2,
    // @@protoc_insertion_point(enum_value:TurnIndicatorState.TURN_INDICATOR_RIGHT)
    TURN_INDICATOR_RIGHT = 3,
}

impl ::protobuf::Enum for TurnIndicatorState {
    const NAME: &'static str = "TurnIndicatorState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TurnIndicatorState> {
        match value {
            1 => ::std::option::Option::Some(TurnIndicatorState::TURN_INDICATOR_NONE),
            2 => ::std::option::Option::Some(TurnIndicatorState::TURN_INDICATOR_LEFT),
            3 => ::std::option::Option::Some(TurnIndicatorState::TURN_INDICATOR_RIGHT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TurnIndicatorState> {
        match str {
            "TURN_INDICATOR_NONE" => ::std::option::Option::Some(TurnIndicatorState::TURN_INDICATOR_NONE),
            "TURN_INDICATOR_LEFT" => ::std::option::Option::Some(TurnIndicatorState::TURN_INDICATOR_LEFT),
            "TURN_INDICATOR_RIGHT" => ::std::option::Option::Some(TurnIndicatorState::TURN_INDICATOR_RIGHT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TurnIndicatorState] = &[
        TurnIndicatorState::TURN_INDICATOR_NONE,
        TurnIndicatorState::TURN_INDICATOR_LEFT,
        TurnIndicatorState::TURN_INDICATOR_RIGHT,
    ];
}

impl ::protobuf::EnumFull for TurnIndicatorState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TurnIndicatorState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TurnIndicatorState::TURN_INDICATOR_NONE => 0,
            TurnIndicatorState::TURN_INDICATOR_LEFT => 1,
            TurnIndicatorState::TURN_INDICATOR_RIGHT => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TurnIndicatorState {
    fn default() -> Self {
        TurnIndicatorState::TURN_INDICATOR_NONE
    }
}

impl TurnIndicatorState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TurnIndicatorState>("TurnIndicatorState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorMessageId)
pub enum SensorMessageId {
    // @@protoc_insertion_point(enum_value:SensorMessageId.SENSOR_MESSAGE_REQUEST)
    SENSOR_MESSAGE_REQUEST = 32769,
    // @@protoc_insertion_point(enum_value:SensorMessageId.SENSOR_MESSAGE_RESPONSE)
    SENSOR_MESSAGE_RESPONSE = 32770,
    // @@protoc_insertion_point(enum_value:SensorMessageId.SENSOR_MESSAGE_BATCH)
    SENSOR_MESSAGE_BATCH = 32771,
    // @@protoc_insertion_point(enum_value:SensorMessageId.SENSOR_MESSAGE_ERROR)
    SENSOR_MESSAGE_ERROR = 32772,
}

impl ::protobuf::Enum for SensorMessageId {
    const NAME: &'static str = "SensorMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorMessageId> {
        match value {
            32769 => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_REQUEST),
            32770 => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_RESPONSE),
            32771 => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_BATCH),
            32772 => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SensorMessageId> {
        match str {
            "SENSOR_MESSAGE_REQUEST" => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_REQUEST),
            "SENSOR_MESSAGE_RESPONSE" => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_RESPONSE),
            "SENSOR_MESSAGE_BATCH" => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_BATCH),
            "SENSOR_MESSAGE_ERROR" => ::std::option::Option::Some(SensorMessageId::SENSOR_MESSAGE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorMessageId] = &[
        SensorMessageId::SENSOR_MESSAGE_REQUEST,
        SensorMessageId::SENSOR_MESSAGE_RESPONSE,
        SensorMessageId::SENSOR_MESSAGE_BATCH,
        SensorMessageId::SENSOR_MESSAGE_ERROR,
    ];
}

impl ::protobuf::EnumFull for SensorMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SensorMessageId::SENSOR_MESSAGE_REQUEST => 0,
            SensorMessageId::SENSOR_MESSAGE_RESPONSE => 1,
            SensorMessageId::SENSOR_MESSAGE_BATCH => 2,
            SensorMessageId::SENSOR_MESSAGE_ERROR => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SensorMessageId {
    fn default() -> Self {
        SensorMessageId::SENSOR_MESSAGE_REQUEST
    }
}

impl SensorMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorMessageId>("SensorMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VideoFocusReason)
pub enum VideoFocusReason {
    // @@protoc_insertion_point(enum_value:VideoFocusReason.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:VideoFocusReason.PHONE_SCREEN_OFF)
    PHONE_SCREEN_OFF = 1,
    // @@protoc_insertion_point(enum_value:VideoFocusReason.LAUNCH_NATIVE)
    LAUNCH_NATIVE = 2,
}

impl ::protobuf::Enum for VideoFocusReason {
    const NAME: &'static str = "VideoFocusReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VideoFocusReason> {
        match value {
            0 => ::std::option::Option::Some(VideoFocusReason::UNKNOWN),
            1 => ::std::option::Option::Some(VideoFocusReason::PHONE_SCREEN_OFF),
            2 => ::std::option::Option::Some(VideoFocusReason::LAUNCH_NATIVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VideoFocusReason> {
        match str {
            "UNKNOWN" => ::std::option::Option::Some(VideoFocusReason::UNKNOWN),
            "PHONE_SCREEN_OFF" => ::std::option::Option::Some(VideoFocusReason::PHONE_SCREEN_OFF),
            "LAUNCH_NATIVE" => ::std::option::Option::Some(VideoFocusReason::LAUNCH_NATIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VideoFocusReason] = &[
        VideoFocusReason::UNKNOWN,
        VideoFocusReason::PHONE_SCREEN_OFF,
        VideoFocusReason::LAUNCH_NATIVE,
    ];
}

impl ::protobuf::EnumFull for VideoFocusReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VideoFocusReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VideoFocusReason {
    fn default() -> Self {
        VideoFocusReason::UNKNOWN
    }
}

impl VideoFocusReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VideoFocusReason>("VideoFocusReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VideoFocusMode)
pub enum VideoFocusMode {
    // @@protoc_insertion_point(enum_value:VideoFocusMode.VIDEO_FOCUS_PROJECTED)
    VIDEO_FOCUS_PROJECTED = 1,
    // @@protoc_insertion_point(enum_value:VideoFocusMode.VIDEO_FOCUS_NATIVE)
    VIDEO_FOCUS_NATIVE = 2,
    // @@protoc_insertion_point(enum_value:VideoFocusMode.VIDEO_FOCUS_NATIVE_TRANSIENT)
    VIDEO_FOCUS_NATIVE_TRANSIENT = 3,
    // @@protoc_insertion_point(enum_value:VideoFocusMode.VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS)
    VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS = 4,
}

impl ::protobuf::Enum for VideoFocusMode {
    const NAME: &'static str = "VideoFocusMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VideoFocusMode> {
        match value {
            1 => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_PROJECTED),
            2 => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_NATIVE),
            3 => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_NATIVE_TRANSIENT),
            4 => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VideoFocusMode> {
        match str {
            "VIDEO_FOCUS_PROJECTED" => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_PROJECTED),
            "VIDEO_FOCUS_NATIVE" => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_NATIVE),
            "VIDEO_FOCUS_NATIVE_TRANSIENT" => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_NATIVE_TRANSIENT),
            "VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS" => ::std::option::Option::Some(VideoFocusMode::VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VideoFocusMode] = &[
        VideoFocusMode::VIDEO_FOCUS_PROJECTED,
        VideoFocusMode::VIDEO_FOCUS_NATIVE,
        VideoFocusMode::VIDEO_FOCUS_NATIVE_TRANSIENT,
        VideoFocusMode::VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS,
    ];
}

impl ::protobuf::EnumFull for VideoFocusMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VideoFocusMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VideoFocusMode::VIDEO_FOCUS_PROJECTED => 0,
            VideoFocusMode::VIDEO_FOCUS_NATIVE => 1,
            VideoFocusMode::VIDEO_FOCUS_NATIVE_TRANSIENT => 2,
            VideoFocusMode::VIDEO_FOCUS_PROJECTED_NO_INPUT_FOCUS => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for VideoFocusMode {
    fn default() -> Self {
        VideoFocusMode::VIDEO_FOCUS_PROJECTED
    }
}

impl VideoFocusMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VideoFocusMode>("VideoFocusMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AudioFocusRequestType)
pub enum AudioFocusRequestType {
    // @@protoc_insertion_point(enum_value:AudioFocusRequestType.AUDIO_FOCUS_GAIN)
    AUDIO_FOCUS_GAIN = 1,
    // @@protoc_insertion_point(enum_value:AudioFocusRequestType.AUDIO_FOCUS_GAIN_TRANSIENT)
    AUDIO_FOCUS_GAIN_TRANSIENT = 2,
    // @@protoc_insertion_point(enum_value:AudioFocusRequestType.AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK)
    AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK = 3,
    // @@protoc_insertion_point(enum_value:AudioFocusRequestType.AUDIO_FOCUS_RELEASE)
    AUDIO_FOCUS_RELEASE = 4,
}

impl ::protobuf::Enum for AudioFocusRequestType {
    const NAME: &'static str = "AudioFocusRequestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioFocusRequestType> {
        match value {
            1 => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_GAIN),
            2 => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT),
            3 => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK),
            4 => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_RELEASE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AudioFocusRequestType> {
        match str {
            "AUDIO_FOCUS_GAIN" => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_GAIN),
            "AUDIO_FOCUS_GAIN_TRANSIENT" => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT),
            "AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK" => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK),
            "AUDIO_FOCUS_RELEASE" => ::std::option::Option::Some(AudioFocusRequestType::AUDIO_FOCUS_RELEASE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AudioFocusRequestType] = &[
        AudioFocusRequestType::AUDIO_FOCUS_GAIN,
        AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT,
        AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK,
        AudioFocusRequestType::AUDIO_FOCUS_RELEASE,
    ];
}

impl ::protobuf::EnumFull for AudioFocusRequestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AudioFocusRequestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AudioFocusRequestType::AUDIO_FOCUS_GAIN => 0,
            AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT => 1,
            AudioFocusRequestType::AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK => 2,
            AudioFocusRequestType::AUDIO_FOCUS_RELEASE => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AudioFocusRequestType {
    fn default() -> Self {
        AudioFocusRequestType::AUDIO_FOCUS_GAIN
    }
}

impl AudioFocusRequestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AudioFocusRequestType>("AudioFocusRequestType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AudioFocusStateType)
pub enum AudioFocusStateType {
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_INVALID)
    AUDIO_FOCUS_STATE_INVALID = 0,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_GAIN)
    AUDIO_FOCUS_STATE_GAIN = 1,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_GAIN_TRANSIENT)
    AUDIO_FOCUS_STATE_GAIN_TRANSIENT = 2,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_LOSS)
    AUDIO_FOCUS_STATE_LOSS = 3,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK)
    AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK = 4,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_LOSS_TRANSIENT)
    AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 5,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY)
    AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY = 6,
    // @@protoc_insertion_point(enum_value:AudioFocusStateType.AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY)
    AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY = 7,
}

impl ::protobuf::Enum for AudioFocusStateType {
    const NAME: &'static str = "AudioFocusStateType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioFocusStateType> {
        match value {
            0 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID),
            1 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN),
            2 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_TRANSIENT),
            3 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS),
            4 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK),
            5 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS_TRANSIENT),
            6 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY),
            7 => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AudioFocusStateType> {
        match str {
            "AUDIO_FOCUS_STATE_INVALID" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID),
            "AUDIO_FOCUS_STATE_GAIN" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN),
            "AUDIO_FOCUS_STATE_GAIN_TRANSIENT" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_TRANSIENT),
            "AUDIO_FOCUS_STATE_LOSS" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS),
            "AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK),
            "AUDIO_FOCUS_STATE_LOSS_TRANSIENT" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS_TRANSIENT),
            "AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY),
            "AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY" => ::std::option::Option::Some(AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AudioFocusStateType] = &[
        AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID,
        AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN,
        AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_TRANSIENT,
        AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS,
        AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK,
        AudioFocusStateType::AUDIO_FOCUS_STATE_LOSS_TRANSIENT,
        AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY,
        AudioFocusStateType::AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY,
    ];
}

impl ::protobuf::EnumFull for AudioFocusStateType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AudioFocusStateType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AudioFocusStateType {
    fn default() -> Self {
        AudioFocusStateType::AUDIO_FOCUS_STATE_INVALID
    }
}

impl AudioFocusStateType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AudioFocusStateType>("AudioFocusStateType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaMessageId)
pub enum MediaMessageId {
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_DATA)
    MEDIA_MESSAGE_DATA = 0,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_CODEC_CONFIG)
    MEDIA_MESSAGE_CODEC_CONFIG = 1,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_SETUP)
    MEDIA_MESSAGE_SETUP = 32768,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_START)
    MEDIA_MESSAGE_START = 32769,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_STOP)
    MEDIA_MESSAGE_STOP = 32770,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_CONFIG)
    MEDIA_MESSAGE_CONFIG = 32771,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_ACK)
    MEDIA_MESSAGE_ACK = 32772,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_MICROPHONE_REQUEST)
    MEDIA_MESSAGE_MICROPHONE_REQUEST = 32773,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_MICROPHONE_RESPONSE)
    MEDIA_MESSAGE_MICROPHONE_RESPONSE = 32774,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST)
    MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST = 32775,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION)
    MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION = 32776,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST)
    MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST = 32777,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY)
    MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY = 32778,
    // @@protoc_insertion_point(enum_value:MediaMessageId.MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION)
    MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION = 32779,
}

impl ::protobuf::Enum for MediaMessageId {
    const NAME: &'static str = "MediaMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaMessageId> {
        match value {
            0 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_DATA),
            1 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_CODEC_CONFIG),
            32768 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_SETUP),
            32769 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_START),
            32770 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_STOP),
            32771 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_CONFIG),
            32772 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_ACK),
            32773 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_MICROPHONE_REQUEST),
            32774 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_MICROPHONE_RESPONSE),
            32775 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST),
            32776 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION),
            32777 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST),
            32778 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY),
            32779 => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaMessageId> {
        match str {
            "MEDIA_MESSAGE_DATA" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_DATA),
            "MEDIA_MESSAGE_CODEC_CONFIG" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_CODEC_CONFIG),
            "MEDIA_MESSAGE_SETUP" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_SETUP),
            "MEDIA_MESSAGE_START" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_START),
            "MEDIA_MESSAGE_STOP" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_STOP),
            "MEDIA_MESSAGE_CONFIG" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_CONFIG),
            "MEDIA_MESSAGE_ACK" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_ACK),
            "MEDIA_MESSAGE_MICROPHONE_REQUEST" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_MICROPHONE_REQUEST),
            "MEDIA_MESSAGE_MICROPHONE_RESPONSE" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_MICROPHONE_RESPONSE),
            "MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST),
            "MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION),
            "MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST),
            "MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY),
            "MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION" => ::std::option::Option::Some(MediaMessageId::MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaMessageId] = &[
        MediaMessageId::MEDIA_MESSAGE_DATA,
        MediaMessageId::MEDIA_MESSAGE_CODEC_CONFIG,
        MediaMessageId::MEDIA_MESSAGE_SETUP,
        MediaMessageId::MEDIA_MESSAGE_START,
        MediaMessageId::MEDIA_MESSAGE_STOP,
        MediaMessageId::MEDIA_MESSAGE_CONFIG,
        MediaMessageId::MEDIA_MESSAGE_ACK,
        MediaMessageId::MEDIA_MESSAGE_MICROPHONE_REQUEST,
        MediaMessageId::MEDIA_MESSAGE_MICROPHONE_RESPONSE,
        MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST,
        MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION,
        MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST,
        MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY,
        MediaMessageId::MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION,
    ];
}

impl ::protobuf::EnumFull for MediaMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MediaMessageId::MEDIA_MESSAGE_DATA => 0,
            MediaMessageId::MEDIA_MESSAGE_CODEC_CONFIG => 1,
            MediaMessageId::MEDIA_MESSAGE_SETUP => 2,
            MediaMessageId::MEDIA_MESSAGE_START => 3,
            MediaMessageId::MEDIA_MESSAGE_STOP => 4,
            MediaMessageId::MEDIA_MESSAGE_CONFIG => 5,
            MediaMessageId::MEDIA_MESSAGE_ACK => 6,
            MediaMessageId::MEDIA_MESSAGE_MICROPHONE_REQUEST => 7,
            MediaMessageId::MEDIA_MESSAGE_MICROPHONE_RESPONSE => 8,
            MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST => 9,
            MediaMessageId::MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION => 10,
            MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST => 11,
            MediaMessageId::MEDIA_MESSAGE_UPDATE_UI_CONFIG_REPLY => 12,
            MediaMessageId::MEDIA_MESSAGE_AUDIO_UNDERFLOW_NOTIFICATION => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MediaMessageId {
    fn default() -> Self {
        MediaMessageId::MEDIA_MESSAGE_DATA
    }
}

impl MediaMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaMessageId>("MediaMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PointerAction)
pub enum PointerAction {
    // @@protoc_insertion_point(enum_value:PointerAction.ACTION_DOWN)
    ACTION_DOWN = 0,
    // @@protoc_insertion_point(enum_value:PointerAction.ACTION_UP)
    ACTION_UP = 1,
    // @@protoc_insertion_point(enum_value:PointerAction.ACTION_MOVED)
    ACTION_MOVED = 2,
    // @@protoc_insertion_point(enum_value:PointerAction.ACTION_POINTER_DOWN)
    ACTION_POINTER_DOWN = 5,
    // @@protoc_insertion_point(enum_value:PointerAction.ACTION_POINTER_UP)
    ACTION_POINTER_UP = 6,
}

impl ::protobuf::Enum for PointerAction {
    const NAME: &'static str = "PointerAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PointerAction> {
        match value {
            0 => ::std::option::Option::Some(PointerAction::ACTION_DOWN),
            1 => ::std::option::Option::Some(PointerAction::ACTION_UP),
            2 => ::std::option::Option::Some(PointerAction::ACTION_MOVED),
            5 => ::std::option::Option::Some(PointerAction::ACTION_POINTER_DOWN),
            6 => ::std::option::Option::Some(PointerAction::ACTION_POINTER_UP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PointerAction> {
        match str {
            "ACTION_DOWN" => ::std::option::Option::Some(PointerAction::ACTION_DOWN),
            "ACTION_UP" => ::std::option::Option::Some(PointerAction::ACTION_UP),
            "ACTION_MOVED" => ::std::option::Option::Some(PointerAction::ACTION_MOVED),
            "ACTION_POINTER_DOWN" => ::std::option::Option::Some(PointerAction::ACTION_POINTER_DOWN),
            "ACTION_POINTER_UP" => ::std::option::Option::Some(PointerAction::ACTION_POINTER_UP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PointerAction] = &[
        PointerAction::ACTION_DOWN,
        PointerAction::ACTION_UP,
        PointerAction::ACTION_MOVED,
        PointerAction::ACTION_POINTER_DOWN,
        PointerAction::ACTION_POINTER_UP,
    ];
}

impl ::protobuf::EnumFull for PointerAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PointerAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PointerAction::ACTION_DOWN => 0,
            PointerAction::ACTION_UP => 1,
            PointerAction::ACTION_MOVED => 2,
            PointerAction::ACTION_POINTER_DOWN => 3,
            PointerAction::ACTION_POINTER_UP => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PointerAction {
    fn default() -> Self {
        PointerAction::ACTION_DOWN
    }
}

impl PointerAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PointerAction>("PointerAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FeedbackEvent)
pub enum FeedbackEvent {
    // @@protoc_insertion_point(enum_value:FeedbackEvent.FEEDBACK_SELECT)
    FEEDBACK_SELECT = 1,
    // @@protoc_insertion_point(enum_value:FeedbackEvent.FEEDBACK_FOCUS_CHANGE)
    FEEDBACK_FOCUS_CHANGE = 2,
    // @@protoc_insertion_point(enum_value:FeedbackEvent.FEEDBACK_DRAG_SELECT)
    FEEDBACK_DRAG_SELECT = 3,
    // @@protoc_insertion_point(enum_value:FeedbackEvent.FEEDBACK_DRAG_START)
    FEEDBACK_DRAG_START = 4,
    // @@protoc_insertion_point(enum_value:FeedbackEvent.FEEDBACK_DRAG_END)
    FEEDBACK_DRAG_END = 5,
}

impl ::protobuf::Enum for FeedbackEvent {
    const NAME: &'static str = "FeedbackEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FeedbackEvent> {
        match value {
            1 => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_SELECT),
            2 => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_FOCUS_CHANGE),
            3 => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_DRAG_SELECT),
            4 => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_DRAG_START),
            5 => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_DRAG_END),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FeedbackEvent> {
        match str {
            "FEEDBACK_SELECT" => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_SELECT),
            "FEEDBACK_FOCUS_CHANGE" => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_FOCUS_CHANGE),
            "FEEDBACK_DRAG_SELECT" => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_DRAG_SELECT),
            "FEEDBACK_DRAG_START" => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_DRAG_START),
            "FEEDBACK_DRAG_END" => ::std::option::Option::Some(FeedbackEvent::FEEDBACK_DRAG_END),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FeedbackEvent] = &[
        FeedbackEvent::FEEDBACK_SELECT,
        FeedbackEvent::FEEDBACK_FOCUS_CHANGE,
        FeedbackEvent::FEEDBACK_DRAG_SELECT,
        FeedbackEvent::FEEDBACK_DRAG_START,
        FeedbackEvent::FEEDBACK_DRAG_END,
    ];
}

impl ::protobuf::EnumFull for FeedbackEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FeedbackEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FeedbackEvent::FEEDBACK_SELECT => 0,
            FeedbackEvent::FEEDBACK_FOCUS_CHANGE => 1,
            FeedbackEvent::FEEDBACK_DRAG_SELECT => 2,
            FeedbackEvent::FEEDBACK_DRAG_START => 3,
            FeedbackEvent::FEEDBACK_DRAG_END => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for FeedbackEvent {
    fn default() -> Self {
        FeedbackEvent::FEEDBACK_SELECT
    }
}

impl FeedbackEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FeedbackEvent>("FeedbackEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:InputMessageId)
pub enum InputMessageId {
    // @@protoc_insertion_point(enum_value:InputMessageId.INPUT_MESSAGE_INPUT_REPORT)
    INPUT_MESSAGE_INPUT_REPORT = 32769,
    // @@protoc_insertion_point(enum_value:InputMessageId.INPUT_MESSAGE_KEY_BINDING_REQUEST)
    INPUT_MESSAGE_KEY_BINDING_REQUEST = 32770,
    // @@protoc_insertion_point(enum_value:InputMessageId.INPUT_MESSAGE_KEY_BINDING_RESPONSE)
    INPUT_MESSAGE_KEY_BINDING_RESPONSE = 32771,
    // @@protoc_insertion_point(enum_value:InputMessageId.INPUT_MESSAGE_INPUT_FEEDBACK)
    INPUT_MESSAGE_INPUT_FEEDBACK = 32772,
}

impl ::protobuf::Enum for InputMessageId {
    const NAME: &'static str = "InputMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InputMessageId> {
        match value {
            32769 => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_INPUT_REPORT),
            32770 => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_KEY_BINDING_REQUEST),
            32771 => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_KEY_BINDING_RESPONSE),
            32772 => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_INPUT_FEEDBACK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<InputMessageId> {
        match str {
            "INPUT_MESSAGE_INPUT_REPORT" => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_INPUT_REPORT),
            "INPUT_MESSAGE_KEY_BINDING_REQUEST" => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_KEY_BINDING_REQUEST),
            "INPUT_MESSAGE_KEY_BINDING_RESPONSE" => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_KEY_BINDING_RESPONSE),
            "INPUT_MESSAGE_INPUT_FEEDBACK" => ::std::option::Option::Some(InputMessageId::INPUT_MESSAGE_INPUT_FEEDBACK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InputMessageId] = &[
        InputMessageId::INPUT_MESSAGE_INPUT_REPORT,
        InputMessageId::INPUT_MESSAGE_KEY_BINDING_REQUEST,
        InputMessageId::INPUT_MESSAGE_KEY_BINDING_RESPONSE,
        InputMessageId::INPUT_MESSAGE_INPUT_FEEDBACK,
    ];
}

impl ::protobuf::EnumFull for InputMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("InputMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            InputMessageId::INPUT_MESSAGE_INPUT_REPORT => 0,
            InputMessageId::INPUT_MESSAGE_KEY_BINDING_REQUEST => 1,
            InputMessageId::INPUT_MESSAGE_KEY_BINDING_RESPONSE => 2,
            InputMessageId::INPUT_MESSAGE_INPUT_FEEDBACK => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for InputMessageId {
    fn default() -> Self {
        InputMessageId::INPUT_MESSAGE_INPUT_REPORT
    }
}

impl InputMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InputMessageId>("InputMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BluetoothMessageId)
pub enum BluetoothMessageId {
    // @@protoc_insertion_point(enum_value:BluetoothMessageId.BLUETOOTH_MESSAGE_PAIRING_REQUEST)
    BLUETOOTH_MESSAGE_PAIRING_REQUEST = 32769,
    // @@protoc_insertion_point(enum_value:BluetoothMessageId.BLUETOOTH_MESSAGE_PAIRING_RESPONSE)
    BLUETOOTH_MESSAGE_PAIRING_RESPONSE = 32770,
    // @@protoc_insertion_point(enum_value:BluetoothMessageId.BLUETOOTH_MESSAGE_AUTHENTICATION_DATA)
    BLUETOOTH_MESSAGE_AUTHENTICATION_DATA = 32771,
    // @@protoc_insertion_point(enum_value:BluetoothMessageId.BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT)
    BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT = 32772,
}

impl ::protobuf::Enum for BluetoothMessageId {
    const NAME: &'static str = "BluetoothMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BluetoothMessageId> {
        match value {
            32769 => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_REQUEST),
            32770 => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_RESPONSE),
            32771 => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_DATA),
            32772 => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BluetoothMessageId> {
        match str {
            "BLUETOOTH_MESSAGE_PAIRING_REQUEST" => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_REQUEST),
            "BLUETOOTH_MESSAGE_PAIRING_RESPONSE" => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_RESPONSE),
            "BLUETOOTH_MESSAGE_AUTHENTICATION_DATA" => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_DATA),
            "BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT" => ::std::option::Option::Some(BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BluetoothMessageId] = &[
        BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_REQUEST,
        BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_RESPONSE,
        BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_DATA,
        BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT,
    ];
}

impl ::protobuf::EnumFull for BluetoothMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BluetoothMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_REQUEST => 0,
            BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_RESPONSE => 1,
            BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_DATA => 2,
            BluetoothMessageId::BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BluetoothMessageId {
    fn default() -> Self {
        BluetoothMessageId::BLUETOOTH_MESSAGE_PAIRING_REQUEST
    }
}

impl BluetoothMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BluetoothMessageId>("BluetoothMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:WifiSecurityMode)
pub enum WifiSecurityMode {
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.UNKNOWN_SECURITY_MODE)
    UNKNOWN_SECURITY_MODE = 0,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.OPEN)
    OPEN = 1,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WEP_64)
    WEP_64 = 2,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WEP_128)
    WEP_128 = 3,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WPA_PERSONAL)
    WPA_PERSONAL = 4,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WPA2_PERSONAL)
    WPA2_PERSONAL = 5,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WPA_WPA2_PERSONAL)
    WPA_WPA2_PERSONAL = 6,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WPA_ENTERPRISE)
    WPA_ENTERPRISE = 7,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WPA2_ENTERPRISE)
    WPA2_ENTERPRISE = 8,
    // @@protoc_insertion_point(enum_value:WifiSecurityMode.WPA_WPA2_ENTERPRISE)
    WPA_WPA2_ENTERPRISE = 9,
}

impl ::protobuf::Enum for WifiSecurityMode {
    const NAME: &'static str = "WifiSecurityMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WifiSecurityMode> {
        match value {
            0 => ::std::option::Option::Some(WifiSecurityMode::UNKNOWN_SECURITY_MODE),
            1 => ::std::option::Option::Some(WifiSecurityMode::OPEN),
            2 => ::std::option::Option::Some(WifiSecurityMode::WEP_64),
            3 => ::std::option::Option::Some(WifiSecurityMode::WEP_128),
            4 => ::std::option::Option::Some(WifiSecurityMode::WPA_PERSONAL),
            5 => ::std::option::Option::Some(WifiSecurityMode::WPA2_PERSONAL),
            6 => ::std::option::Option::Some(WifiSecurityMode::WPA_WPA2_PERSONAL),
            7 => ::std::option::Option::Some(WifiSecurityMode::WPA_ENTERPRISE),
            8 => ::std::option::Option::Some(WifiSecurityMode::WPA2_ENTERPRISE),
            9 => ::std::option::Option::Some(WifiSecurityMode::WPA_WPA2_ENTERPRISE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<WifiSecurityMode> {
        match str {
            "UNKNOWN_SECURITY_MODE" => ::std::option::Option::Some(WifiSecurityMode::UNKNOWN_SECURITY_MODE),
            "OPEN" => ::std::option::Option::Some(WifiSecurityMode::OPEN),
            "WEP_64" => ::std::option::Option::Some(WifiSecurityMode::WEP_64),
            "WEP_128" => ::std::option::Option::Some(WifiSecurityMode::WEP_128),
            "WPA_PERSONAL" => ::std::option::Option::Some(WifiSecurityMode::WPA_PERSONAL),
            "WPA2_PERSONAL" => ::std::option::Option::Some(WifiSecurityMode::WPA2_PERSONAL),
            "WPA_WPA2_PERSONAL" => ::std::option::Option::Some(WifiSecurityMode::WPA_WPA2_PERSONAL),
            "WPA_ENTERPRISE" => ::std::option::Option::Some(WifiSecurityMode::WPA_ENTERPRISE),
            "WPA2_ENTERPRISE" => ::std::option::Option::Some(WifiSecurityMode::WPA2_ENTERPRISE),
            "WPA_WPA2_ENTERPRISE" => ::std::option::Option::Some(WifiSecurityMode::WPA_WPA2_ENTERPRISE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WifiSecurityMode] = &[
        WifiSecurityMode::UNKNOWN_SECURITY_MODE,
        WifiSecurityMode::OPEN,
        WifiSecurityMode::WEP_64,
        WifiSecurityMode::WEP_128,
        WifiSecurityMode::WPA_PERSONAL,
        WifiSecurityMode::WPA2_PERSONAL,
        WifiSecurityMode::WPA_WPA2_PERSONAL,
        WifiSecurityMode::WPA_ENTERPRISE,
        WifiSecurityMode::WPA2_ENTERPRISE,
        WifiSecurityMode::WPA_WPA2_ENTERPRISE,
    ];
}

impl ::protobuf::EnumFull for WifiSecurityMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WifiSecurityMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WifiSecurityMode {
    fn default() -> Self {
        WifiSecurityMode::UNKNOWN_SECURITY_MODE
    }
}

impl WifiSecurityMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WifiSecurityMode>("WifiSecurityMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AccessPointType)
pub enum AccessPointType {
    // @@protoc_insertion_point(enum_value:AccessPointType.STATIC)
    STATIC = 0,
    // @@protoc_insertion_point(enum_value:AccessPointType.DYNAMIC)
    DYNAMIC = 1,
}

impl ::protobuf::Enum for AccessPointType {
    const NAME: &'static str = "AccessPointType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccessPointType> {
        match value {
            0 => ::std::option::Option::Some(AccessPointType::STATIC),
            1 => ::std::option::Option::Some(AccessPointType::DYNAMIC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AccessPointType> {
        match str {
            "STATIC" => ::std::option::Option::Some(AccessPointType::STATIC),
            "DYNAMIC" => ::std::option::Option::Some(AccessPointType::DYNAMIC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AccessPointType] = &[
        AccessPointType::STATIC,
        AccessPointType::DYNAMIC,
    ];
}

impl ::protobuf::EnumFull for AccessPointType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AccessPointType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AccessPointType {
    fn default() -> Self {
        AccessPointType::STATIC
    }
}

impl AccessPointType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccessPointType>("AccessPointType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:WifiProjectionMessageId)
pub enum WifiProjectionMessageId {
    // @@protoc_insertion_point(enum_value:WifiProjectionMessageId.WIFI_MESSAGE_CREDENTIALS_REQUEST)
    WIFI_MESSAGE_CREDENTIALS_REQUEST = 32769,
    // @@protoc_insertion_point(enum_value:WifiProjectionMessageId.WIFI_MESSAGE_CREDENTIALS_RESPONSE)
    WIFI_MESSAGE_CREDENTIALS_RESPONSE = 32770,
}

impl ::protobuf::Enum for WifiProjectionMessageId {
    const NAME: &'static str = "WifiProjectionMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WifiProjectionMessageId> {
        match value {
            32769 => ::std::option::Option::Some(WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_REQUEST),
            32770 => ::std::option::Option::Some(WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<WifiProjectionMessageId> {
        match str {
            "WIFI_MESSAGE_CREDENTIALS_REQUEST" => ::std::option::Option::Some(WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_REQUEST),
            "WIFI_MESSAGE_CREDENTIALS_RESPONSE" => ::std::option::Option::Some(WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WifiProjectionMessageId] = &[
        WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_REQUEST,
        WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_RESPONSE,
    ];
}

impl ::protobuf::EnumFull for WifiProjectionMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WifiProjectionMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_REQUEST => 0,
            WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_RESPONSE => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for WifiProjectionMessageId {
    fn default() -> Self {
        WifiProjectionMessageId::WIFI_MESSAGE_CREDENTIALS_REQUEST
    }
}

impl WifiProjectionMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WifiProjectionMessageId>("WifiProjectionMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RadioMessageId)
pub enum RadioMessageId {
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION)
    RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION = 32769,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST)
    RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST = 32770,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_STEP_CHANNEL_REQUEST)
    RADIO_MESSAGE_STEP_CHANNEL_REQUEST = 32771,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_STEP_CHANNEL_RESPONSE)
    RADIO_MESSAGE_STEP_CHANNEL_RESPONSE = 32772,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_SEEK_STATION_REQUEST)
    RADIO_MESSAGE_SEEK_STATION_REQUEST = 32773,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_SEEK_STATION_RESPONSE)
    RADIO_MESSAGE_SEEK_STATION_RESPONSE = 32774,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_SCAN_STATIONS_REQUEST)
    RADIO_MESSAGE_SCAN_STATIONS_REQUEST = 32775,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_SCAN_STATIONS_RESPONSE)
    RADIO_MESSAGE_SCAN_STATIONS_RESPONSE = 32776,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_TUNE_TO_STATION_REQUEST)
    RADIO_MESSAGE_TUNE_TO_STATION_REQUEST = 32777,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE)
    RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE = 32778,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST)
    RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST = 32779,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE)
    RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE = 32780,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION)
    RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION = 32781,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST)
    RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST = 32782,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE)
    RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE = 32783,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST)
    RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST = 32784,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE)
    RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE = 32785,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION)
    RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION = 32786,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_MUTE_RADIO_REQUEST)
    RADIO_MESSAGE_MUTE_RADIO_REQUEST = 32787,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_MUTE_RADIO_RESPONSE)
    RADIO_MESSAGE_MUTE_RADIO_RESPONSE = 32788,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST)
    RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST = 32789,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE)
    RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE = 32790,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_RADIO_SOURCE_REQUEST)
    RADIO_MESSAGE_RADIO_SOURCE_REQUEST = 32791,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_RADIO_SOURCE_RESPONSE)
    RADIO_MESSAGE_RADIO_SOURCE_RESPONSE = 32792,
    // @@protoc_insertion_point(enum_value:RadioMessageId.RADIO_MESSAGE_STATE_NOTIFICATION)
    RADIO_MESSAGE_STATE_NOTIFICATION = 32793,
}

impl ::protobuf::Enum for RadioMessageId {
    const NAME: &'static str = "RadioMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RadioMessageId> {
        match value {
            32769 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION),
            32770 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST),
            32771 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_REQUEST),
            32772 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_RESPONSE),
            32773 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SEEK_STATION_REQUEST),
            32774 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SEEK_STATION_RESPONSE),
            32775 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_REQUEST),
            32776 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_RESPONSE),
            32777 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_REQUEST),
            32778 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE),
            32779 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST),
            32780 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE),
            32781 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION),
            32782 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST),
            32783 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE),
            32784 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST),
            32785 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE),
            32786 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION),
            32787 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_REQUEST),
            32788 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_RESPONSE),
            32789 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST),
            32790 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE),
            32791 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_REQUEST),
            32792 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_RESPONSE),
            32793 => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STATE_NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RadioMessageId> {
        match str {
            "RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION),
            "RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST),
            "RADIO_MESSAGE_STEP_CHANNEL_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_REQUEST),
            "RADIO_MESSAGE_STEP_CHANNEL_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_RESPONSE),
            "RADIO_MESSAGE_SEEK_STATION_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SEEK_STATION_REQUEST),
            "RADIO_MESSAGE_SEEK_STATION_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SEEK_STATION_RESPONSE),
            "RADIO_MESSAGE_SCAN_STATIONS_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_REQUEST),
            "RADIO_MESSAGE_SCAN_STATIONS_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_RESPONSE),
            "RADIO_MESSAGE_TUNE_TO_STATION_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_REQUEST),
            "RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE),
            "RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST),
            "RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE),
            "RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION),
            "RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST),
            "RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE),
            "RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST),
            "RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE),
            "RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION),
            "RADIO_MESSAGE_MUTE_RADIO_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_REQUEST),
            "RADIO_MESSAGE_MUTE_RADIO_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_RESPONSE),
            "RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST),
            "RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE),
            "RADIO_MESSAGE_RADIO_SOURCE_REQUEST" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_REQUEST),
            "RADIO_MESSAGE_RADIO_SOURCE_RESPONSE" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_RESPONSE),
            "RADIO_MESSAGE_STATE_NOTIFICATION" => ::std::option::Option::Some(RadioMessageId::RADIO_MESSAGE_STATE_NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RadioMessageId] = &[
        RadioMessageId::RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION,
        RadioMessageId::RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST,
        RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_REQUEST,
        RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_SEEK_STATION_REQUEST,
        RadioMessageId::RADIO_MESSAGE_SEEK_STATION_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_REQUEST,
        RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_REQUEST,
        RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST,
        RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION,
        RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST,
        RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST,
        RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION,
        RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_REQUEST,
        RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST,
        RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_REQUEST,
        RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_RESPONSE,
        RadioMessageId::RADIO_MESSAGE_STATE_NOTIFICATION,
    ];
}

impl ::protobuf::EnumFull for RadioMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RadioMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            RadioMessageId::RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION => 0,
            RadioMessageId::RADIO_MESSAGE_SELECT_ACTIVE_RADIO_REQUEST => 1,
            RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_REQUEST => 2,
            RadioMessageId::RADIO_MESSAGE_STEP_CHANNEL_RESPONSE => 3,
            RadioMessageId::RADIO_MESSAGE_SEEK_STATION_REQUEST => 4,
            RadioMessageId::RADIO_MESSAGE_SEEK_STATION_RESPONSE => 5,
            RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_REQUEST => 6,
            RadioMessageId::RADIO_MESSAGE_SCAN_STATIONS_RESPONSE => 7,
            RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_REQUEST => 8,
            RadioMessageId::RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE => 9,
            RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST => 10,
            RadioMessageId::RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE => 11,
            RadioMessageId::RADIO_MESSAGE_STATION_PRESETS_NOTIFICATION => 12,
            RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_REQUEST => 13,
            RadioMessageId::RADIO_MESSAGE_CANCEL_OPERATIONS_RESPONSE => 14,
            RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_REQUEST => 15,
            RadioMessageId::RADIO_MESSAGE_CONFIGURE_CHANNEL_SPACING_RESPONSE => 16,
            RadioMessageId::RADIO_MESSAGE_RADIO_STATION_INFO_NOTIFICATION => 17,
            RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_REQUEST => 18,
            RadioMessageId::RADIO_MESSAGE_MUTE_RADIO_RESPONSE => 19,
            RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST => 20,
            RadioMessageId::RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE => 21,
            RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_REQUEST => 22,
            RadioMessageId::RADIO_MESSAGE_RADIO_SOURCE_RESPONSE => 23,
            RadioMessageId::RADIO_MESSAGE_STATE_NOTIFICATION => 24,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for RadioMessageId {
    fn default() -> Self {
        RadioMessageId::RADIO_MESSAGE_ACTIVE_RADIO_NOTIFICATION
    }
}

impl RadioMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RadioMessageId>("RadioMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:HdAcquisionState)
pub enum HdAcquisionState {
    // @@protoc_insertion_point(enum_value:HdAcquisionState.ANALOG)
    ANALOG = 0,
    // @@protoc_insertion_point(enum_value:HdAcquisionState.ACQUIRING_HD)
    ACQUIRING_HD = 1,
    // @@protoc_insertion_point(enum_value:HdAcquisionState.ACQUIRED_HD)
    ACQUIRED_HD = 2,
}

impl ::protobuf::Enum for HdAcquisionState {
    const NAME: &'static str = "HdAcquisionState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HdAcquisionState> {
        match value {
            0 => ::std::option::Option::Some(HdAcquisionState::ANALOG),
            1 => ::std::option::Option::Some(HdAcquisionState::ACQUIRING_HD),
            2 => ::std::option::Option::Some(HdAcquisionState::ACQUIRED_HD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<HdAcquisionState> {
        match str {
            "ANALOG" => ::std::option::Option::Some(HdAcquisionState::ANALOG),
            "ACQUIRING_HD" => ::std::option::Option::Some(HdAcquisionState::ACQUIRING_HD),
            "ACQUIRED_HD" => ::std::option::Option::Some(HdAcquisionState::ACQUIRED_HD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [HdAcquisionState] = &[
        HdAcquisionState::ANALOG,
        HdAcquisionState::ACQUIRING_HD,
        HdAcquisionState::ACQUIRED_HD,
    ];
}

impl ::protobuf::EnumFull for HdAcquisionState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("HdAcquisionState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for HdAcquisionState {
    fn default() -> Self {
        HdAcquisionState::ANALOG
    }
}

impl HdAcquisionState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HdAcquisionState>("HdAcquisionState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NavigationStatusMessageId)
pub enum NavigationStatusMessageId {
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_START)
    INSTRUMENT_CLUSTER_START = 32769,
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_STOP)
    INSTRUMENT_CLUSTER_STOP = 32770,
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_NAVIGATION_STATUS)
    INSTRUMENT_CLUSTER_NAVIGATION_STATUS = 32771,
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT)
    INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT = 32772,
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT)
    INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT = 32773,
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_NAVIGATION_STATE)
    INSTRUMENT_CLUSTER_NAVIGATION_STATE = 32774,
    // @@protoc_insertion_point(enum_value:NavigationStatusMessageId.INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION)
    INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION = 32775,
}

impl ::protobuf::Enum for NavigationStatusMessageId {
    const NAME: &'static str = "NavigationStatusMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NavigationStatusMessageId> {
        match value {
            32769 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_START),
            32770 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_STOP),
            32771 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATUS),
            32772 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT),
            32773 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT),
            32774 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATE),
            32775 => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NavigationStatusMessageId> {
        match str {
            "INSTRUMENT_CLUSTER_START" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_START),
            "INSTRUMENT_CLUSTER_STOP" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_STOP),
            "INSTRUMENT_CLUSTER_NAVIGATION_STATUS" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATUS),
            "INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT),
            "INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT),
            "INSTRUMENT_CLUSTER_NAVIGATION_STATE" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATE),
            "INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION" => ::std::option::Option::Some(NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NavigationStatusMessageId] = &[
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_START,
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_STOP,
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATUS,
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT,
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT,
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATE,
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION,
    ];
}

impl ::protobuf::EnumFull for NavigationStatusMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NavigationStatusMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_START => 0,
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_STOP => 1,
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATUS => 2,
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT => 3,
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT => 4,
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_STATE => 5,
            NavigationStatusMessageId::INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NavigationStatusMessageId {
    fn default() -> Self {
        NavigationStatusMessageId::INSTRUMENT_CLUSTER_START
    }
}

impl NavigationStatusMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NavigationStatusMessageId>("NavigationStatusMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaPlaybackStatusMessageId)
pub enum MediaPlaybackStatusMessageId {
    // @@protoc_insertion_point(enum_value:MediaPlaybackStatusMessageId.MEDIA_PLAYBACK_STATUS)
    MEDIA_PLAYBACK_STATUS = 32769,
    // @@protoc_insertion_point(enum_value:MediaPlaybackStatusMessageId.MEDIA_PLAYBACK_INPUT)
    MEDIA_PLAYBACK_INPUT = 32770,
    // @@protoc_insertion_point(enum_value:MediaPlaybackStatusMessageId.MEDIA_PLAYBACK_METADATA)
    MEDIA_PLAYBACK_METADATA = 32771,
}

impl ::protobuf::Enum for MediaPlaybackStatusMessageId {
    const NAME: &'static str = "MediaPlaybackStatusMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaPlaybackStatusMessageId> {
        match value {
            32769 => ::std::option::Option::Some(MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_STATUS),
            32770 => ::std::option::Option::Some(MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_INPUT),
            32771 => ::std::option::Option::Some(MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_METADATA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaPlaybackStatusMessageId> {
        match str {
            "MEDIA_PLAYBACK_STATUS" => ::std::option::Option::Some(MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_STATUS),
            "MEDIA_PLAYBACK_INPUT" => ::std::option::Option::Some(MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_INPUT),
            "MEDIA_PLAYBACK_METADATA" => ::std::option::Option::Some(MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_METADATA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaPlaybackStatusMessageId] = &[
        MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_STATUS,
        MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_INPUT,
        MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_METADATA,
    ];
}

impl ::protobuf::EnumFull for MediaPlaybackStatusMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaPlaybackStatusMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_STATUS => 0,
            MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_INPUT => 1,
            MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_METADATA => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MediaPlaybackStatusMessageId {
    fn default() -> Self {
        MediaPlaybackStatusMessageId::MEDIA_PLAYBACK_STATUS
    }
}

impl MediaPlaybackStatusMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaPlaybackStatusMessageId>("MediaPlaybackStatusMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PhoneStatusMessageId)
pub enum PhoneStatusMessageId {
    // @@protoc_insertion_point(enum_value:PhoneStatusMessageId.PHONE_STATUS)
    PHONE_STATUS = 32769,
    // @@protoc_insertion_point(enum_value:PhoneStatusMessageId.PHONE_STATUS_INPUT)
    PHONE_STATUS_INPUT = 32770,
}

impl ::protobuf::Enum for PhoneStatusMessageId {
    const NAME: &'static str = "PhoneStatusMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PhoneStatusMessageId> {
        match value {
            32769 => ::std::option::Option::Some(PhoneStatusMessageId::PHONE_STATUS),
            32770 => ::std::option::Option::Some(PhoneStatusMessageId::PHONE_STATUS_INPUT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PhoneStatusMessageId> {
        match str {
            "PHONE_STATUS" => ::std::option::Option::Some(PhoneStatusMessageId::PHONE_STATUS),
            "PHONE_STATUS_INPUT" => ::std::option::Option::Some(PhoneStatusMessageId::PHONE_STATUS_INPUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PhoneStatusMessageId] = &[
        PhoneStatusMessageId::PHONE_STATUS,
        PhoneStatusMessageId::PHONE_STATUS_INPUT,
    ];
}

impl ::protobuf::EnumFull for PhoneStatusMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PhoneStatusMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PhoneStatusMessageId::PHONE_STATUS => 0,
            PhoneStatusMessageId::PHONE_STATUS_INPUT => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PhoneStatusMessageId {
    fn default() -> Self {
        PhoneStatusMessageId::PHONE_STATUS
    }
}

impl PhoneStatusMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PhoneStatusMessageId>("PhoneStatusMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaBrowserMessageId)
pub enum MediaBrowserMessageId {
    // @@protoc_insertion_point(enum_value:MediaBrowserMessageId.MEDIA_ROOT_NODE)
    MEDIA_ROOT_NODE = 32769,
    // @@protoc_insertion_point(enum_value:MediaBrowserMessageId.MEDIA_SOURCE_NODE)
    MEDIA_SOURCE_NODE = 32770,
    // @@protoc_insertion_point(enum_value:MediaBrowserMessageId.MEDIA_LIST_NODE)
    MEDIA_LIST_NODE = 32771,
    // @@protoc_insertion_point(enum_value:MediaBrowserMessageId.MEDIA_SONG_NODE)
    MEDIA_SONG_NODE = 32772,
    // @@protoc_insertion_point(enum_value:MediaBrowserMessageId.MEDIA_GET_NODE)
    MEDIA_GET_NODE = 32773,
    // @@protoc_insertion_point(enum_value:MediaBrowserMessageId.MEDIA_BROWSE_INPUT)
    MEDIA_BROWSE_INPUT = 32774,
}

impl ::protobuf::Enum for MediaBrowserMessageId {
    const NAME: &'static str = "MediaBrowserMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaBrowserMessageId> {
        match value {
            32769 => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_ROOT_NODE),
            32770 => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_SOURCE_NODE),
            32771 => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_LIST_NODE),
            32772 => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_SONG_NODE),
            32773 => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_GET_NODE),
            32774 => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_BROWSE_INPUT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaBrowserMessageId> {
        match str {
            "MEDIA_ROOT_NODE" => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_ROOT_NODE),
            "MEDIA_SOURCE_NODE" => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_SOURCE_NODE),
            "MEDIA_LIST_NODE" => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_LIST_NODE),
            "MEDIA_SONG_NODE" => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_SONG_NODE),
            "MEDIA_GET_NODE" => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_GET_NODE),
            "MEDIA_BROWSE_INPUT" => ::std::option::Option::Some(MediaBrowserMessageId::MEDIA_BROWSE_INPUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaBrowserMessageId] = &[
        MediaBrowserMessageId::MEDIA_ROOT_NODE,
        MediaBrowserMessageId::MEDIA_SOURCE_NODE,
        MediaBrowserMessageId::MEDIA_LIST_NODE,
        MediaBrowserMessageId::MEDIA_SONG_NODE,
        MediaBrowserMessageId::MEDIA_GET_NODE,
        MediaBrowserMessageId::MEDIA_BROWSE_INPUT,
    ];
}

impl ::protobuf::EnumFull for MediaBrowserMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaBrowserMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MediaBrowserMessageId::MEDIA_ROOT_NODE => 0,
            MediaBrowserMessageId::MEDIA_SOURCE_NODE => 1,
            MediaBrowserMessageId::MEDIA_LIST_NODE => 2,
            MediaBrowserMessageId::MEDIA_SONG_NODE => 3,
            MediaBrowserMessageId::MEDIA_GET_NODE => 4,
            MediaBrowserMessageId::MEDIA_BROWSE_INPUT => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MediaBrowserMessageId {
    fn default() -> Self {
        MediaBrowserMessageId::MEDIA_ROOT_NODE
    }
}

impl MediaBrowserMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaBrowserMessageId>("MediaBrowserMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GalVerificationVendorExtensionMessageId)
pub enum GalVerificationVendorExtensionMessageId {
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_SET_SENSOR)
    GAL_VERIFICATION_SET_SENSOR = 32769,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_MEDIA_SINK_STATUS)
    GAL_VERIFICATION_MEDIA_SINK_STATUS = 32770,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_VIDEO_FOCUS)
    GAL_VERIFICATION_VIDEO_FOCUS = 32771,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_AUDIO_FOCUS)
    GAL_VERIFICATION_AUDIO_FOCUS = 32772,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_INJECT_INPUT)
    GAL_VERIFICATION_INJECT_INPUT = 32773,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_BUG_REPORT_REQUEST)
    GAL_VERIFICATION_BUG_REPORT_REQUEST = 32774,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_BUG_REPORT_RESPONSE)
    GAL_VERIFICATION_BUG_REPORT_RESPONSE = 32775,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST)
    GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST = 32776,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE)
    GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE = 32777,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST)
    GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST = 32778,
    // @@protoc_insertion_point(enum_value:GalVerificationVendorExtensionMessageId.GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE)
    GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE = 32779,
}

impl ::protobuf::Enum for GalVerificationVendorExtensionMessageId {
    const NAME: &'static str = "GalVerificationVendorExtensionMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GalVerificationVendorExtensionMessageId> {
        match value {
            32769 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SET_SENSOR),
            32770 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_MEDIA_SINK_STATUS),
            32771 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_VIDEO_FOCUS),
            32772 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_AUDIO_FOCUS),
            32773 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_INJECT_INPUT),
            32774 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_REQUEST),
            32775 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_RESPONSE),
            32776 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST),
            32777 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE),
            32778 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST),
            32779 => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GalVerificationVendorExtensionMessageId> {
        match str {
            "GAL_VERIFICATION_SET_SENSOR" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SET_SENSOR),
            "GAL_VERIFICATION_MEDIA_SINK_STATUS" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_MEDIA_SINK_STATUS),
            "GAL_VERIFICATION_VIDEO_FOCUS" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_VIDEO_FOCUS),
            "GAL_VERIFICATION_AUDIO_FOCUS" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_AUDIO_FOCUS),
            "GAL_VERIFICATION_INJECT_INPUT" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_INJECT_INPUT),
            "GAL_VERIFICATION_BUG_REPORT_REQUEST" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_REQUEST),
            "GAL_VERIFICATION_BUG_REPORT_RESPONSE" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_RESPONSE),
            "GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST),
            "GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE),
            "GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST),
            "GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE" => ::std::option::Option::Some(GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GalVerificationVendorExtensionMessageId] = &[
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SET_SENSOR,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_MEDIA_SINK_STATUS,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_VIDEO_FOCUS,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_AUDIO_FOCUS,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_INJECT_INPUT,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_REQUEST,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_RESPONSE,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST,
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE,
    ];
}

impl ::protobuf::EnumFull for GalVerificationVendorExtensionMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GalVerificationVendorExtensionMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SET_SENSOR => 0,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_MEDIA_SINK_STATUS => 1,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_VIDEO_FOCUS => 2,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_AUDIO_FOCUS => 3,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_INJECT_INPUT => 4,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_REQUEST => 5,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_BUG_REPORT_RESPONSE => 6,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST => 7,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE => 8,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_REQUEST => 9,
            GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_DISPLAY_INFORMATION_RESPONSE => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GalVerificationVendorExtensionMessageId {
    fn default() -> Self {
        GalVerificationVendorExtensionMessageId::GAL_VERIFICATION_SET_SENSOR
    }
}

impl GalVerificationVendorExtensionMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GalVerificationVendorExtensionMessageId>("GalVerificationVendorExtensionMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GenericNotificationMessageId)
pub enum GenericNotificationMessageId {
    // @@protoc_insertion_point(enum_value:GenericNotificationMessageId.GENERIC_NOTIFICATION_SUBSCRIBE)
    GENERIC_NOTIFICATION_SUBSCRIBE = 32769,
    // @@protoc_insertion_point(enum_value:GenericNotificationMessageId.GENERIC_NOTIFICATION_UNSUBSCRIBE)
    GENERIC_NOTIFICATION_UNSUBSCRIBE = 32770,
    // @@protoc_insertion_point(enum_value:GenericNotificationMessageId.GENERIC_NOTIFICATION_MESSAGE)
    GENERIC_NOTIFICATION_MESSAGE = 32771,
    // @@protoc_insertion_point(enum_value:GenericNotificationMessageId.GENERIC_NOTIFICATION_ACK)
    GENERIC_NOTIFICATION_ACK = 32772,
}

impl ::protobuf::Enum for GenericNotificationMessageId {
    const NAME: &'static str = "GenericNotificationMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GenericNotificationMessageId> {
        match value {
            32769 => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_SUBSCRIBE),
            32770 => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_UNSUBSCRIBE),
            32771 => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_MESSAGE),
            32772 => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_ACK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GenericNotificationMessageId> {
        match str {
            "GENERIC_NOTIFICATION_SUBSCRIBE" => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_SUBSCRIBE),
            "GENERIC_NOTIFICATION_UNSUBSCRIBE" => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_UNSUBSCRIBE),
            "GENERIC_NOTIFICATION_MESSAGE" => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_MESSAGE),
            "GENERIC_NOTIFICATION_ACK" => ::std::option::Option::Some(GenericNotificationMessageId::GENERIC_NOTIFICATION_ACK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GenericNotificationMessageId] = &[
        GenericNotificationMessageId::GENERIC_NOTIFICATION_SUBSCRIBE,
        GenericNotificationMessageId::GENERIC_NOTIFICATION_UNSUBSCRIBE,
        GenericNotificationMessageId::GENERIC_NOTIFICATION_MESSAGE,
        GenericNotificationMessageId::GENERIC_NOTIFICATION_ACK,
    ];
}

impl ::protobuf::EnumFull for GenericNotificationMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GenericNotificationMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GenericNotificationMessageId::GENERIC_NOTIFICATION_SUBSCRIBE => 0,
            GenericNotificationMessageId::GENERIC_NOTIFICATION_UNSUBSCRIBE => 1,
            GenericNotificationMessageId::GENERIC_NOTIFICATION_MESSAGE => 2,
            GenericNotificationMessageId::GENERIC_NOTIFICATION_ACK => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GenericNotificationMessageId {
    fn default() -> Self {
        GenericNotificationMessageId::GENERIC_NOTIFICATION_SUBSCRIBE
    }
}

impl GenericNotificationMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GenericNotificationMessageId>("GenericNotificationMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GoogleDiagnosticsVendorExtensionMessageId)
pub enum GoogleDiagnosticsVendorExtensionMessageId {
    // @@protoc_insertion_point(enum_value:GoogleDiagnosticsVendorExtensionMessageId.DIAGNOSTICS_BUG_REPORT_REQUEST)
    DIAGNOSTICS_BUG_REPORT_REQUEST = 1,
    // @@protoc_insertion_point(enum_value:GoogleDiagnosticsVendorExtensionMessageId.DIAGNOSTICS_BUG_REPORT_RESPONSE)
    DIAGNOSTICS_BUG_REPORT_RESPONSE = 2,
}

impl ::protobuf::Enum for GoogleDiagnosticsVendorExtensionMessageId {
    const NAME: &'static str = "GoogleDiagnosticsVendorExtensionMessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoogleDiagnosticsVendorExtensionMessageId> {
        match value {
            1 => ::std::option::Option::Some(GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_REQUEST),
            2 => ::std::option::Option::Some(GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GoogleDiagnosticsVendorExtensionMessageId> {
        match str {
            "DIAGNOSTICS_BUG_REPORT_REQUEST" => ::std::option::Option::Some(GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_REQUEST),
            "DIAGNOSTICS_BUG_REPORT_RESPONSE" => ::std::option::Option::Some(GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GoogleDiagnosticsVendorExtensionMessageId] = &[
        GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_REQUEST,
        GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_RESPONSE,
    ];
}

impl ::protobuf::EnumFull for GoogleDiagnosticsVendorExtensionMessageId {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GoogleDiagnosticsVendorExtensionMessageId").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_REQUEST => 0,
            GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_RESPONSE => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GoogleDiagnosticsVendorExtensionMessageId {
    fn default() -> Self {
        GoogleDiagnosticsVendorExtensionMessageId::DIAGNOSTICS_BUG_REPORT_REQUEST
    }
}

impl GoogleDiagnosticsVendorExtensionMessageId {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GoogleDiagnosticsVendorExtensionMessageId>("GoogleDiagnosticsVendorExtensionMessageId")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MessageStatus)
pub enum MessageStatus {
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_UNSOLICITED_MESSAGE)
    STATUS_UNSOLICITED_MESSAGE = 1,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_SUCCESS)
    STATUS_SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_NO_COMPATIBLE_VERSION)
    STATUS_NO_COMPATIBLE_VERSION = -1,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_CERTIFICATE_ERROR)
    STATUS_CERTIFICATE_ERROR = -2,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_AUTHENTICATION_FAILURE)
    STATUS_AUTHENTICATION_FAILURE = -3,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_INVALID_SERVICE)
    STATUS_INVALID_SERVICE = -4,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_INVALID_CHANNEL)
    STATUS_INVALID_CHANNEL = -5,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_INVALID_PRIORITY)
    STATUS_INVALID_PRIORITY = -6,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_INTERNAL_ERROR)
    STATUS_INTERNAL_ERROR = -7,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_MEDIA_CONFIG_MISMATCH)
    STATUS_MEDIA_CONFIG_MISMATCH = -8,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_INVALID_SENSOR)
    STATUS_INVALID_SENSOR = -9,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_PAIRING_DELAYED)
    STATUS_BLUETOOTH_PAIRING_DELAYED = -10,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_UNAVAILABLE)
    STATUS_BLUETOOTH_UNAVAILABLE = -11,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_INVALID_ADDRESS)
    STATUS_BLUETOOTH_INVALID_ADDRESS = -12,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_INVALID_PAIRING_METHOD)
    STATUS_BLUETOOTH_INVALID_PAIRING_METHOD = -13,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_INVALID_AUTH_DATA)
    STATUS_BLUETOOTH_INVALID_AUTH_DATA = -14,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_AUTH_DATA_MISMATCH)
    STATUS_BLUETOOTH_AUTH_DATA_MISMATCH = -15,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION)
    STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION = -16,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE)
    STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE = -17,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_KEYCODE_NOT_BOUND)
    STATUS_KEYCODE_NOT_BOUND = -18,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_RADIO_INVALID_STATION)
    STATUS_RADIO_INVALID_STATION = -19,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_INVALID_INPUT)
    STATUS_INVALID_INPUT = -20,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED)
    STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED = -21,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_RADIO_COMM_ERROR)
    STATUS_RADIO_COMM_ERROR = -22,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID)
    STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID = -23,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED)
    STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED = -24,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_PING_TIMEOUT)
    STATUS_PING_TIMEOUT = -25,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_COMMAND_NOT_SUPPORTED)
    STATUS_COMMAND_NOT_SUPPORTED = -250,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_FRAMING_ERROR)
    STATUS_FRAMING_ERROR = -251,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_UNEXPECTED_MESSAGE)
    STATUS_UNEXPECTED_MESSAGE = -253,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_BUSY)
    STATUS_BUSY = -254,
    // @@protoc_insertion_point(enum_value:MessageStatus.STATUS_OUT_OF_MEMORY)
    STATUS_OUT_OF_MEMORY = -255,
}

impl ::protobuf::Enum for MessageStatus {
    const NAME: &'static str = "MessageStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageStatus> {
        match value {
            1 => ::std::option::Option::Some(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            0 => ::std::option::Option::Some(MessageStatus::STATUS_SUCCESS),
            -1 => ::std::option::Option::Some(MessageStatus::STATUS_NO_COMPATIBLE_VERSION),
            -2 => ::std::option::Option::Some(MessageStatus::STATUS_CERTIFICATE_ERROR),
            -3 => ::std::option::Option::Some(MessageStatus::STATUS_AUTHENTICATION_FAILURE),
            -4 => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_SERVICE),
            -5 => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_CHANNEL),
            -6 => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_PRIORITY),
            -7 => ::std::option::Option::Some(MessageStatus::STATUS_INTERNAL_ERROR),
            -8 => ::std::option::Option::Some(MessageStatus::STATUS_MEDIA_CONFIG_MISMATCH),
            -9 => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_SENSOR),
            -10 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_PAIRING_DELAYED),
            -11 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_UNAVAILABLE),
            -12 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_INVALID_ADDRESS),
            -13 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_INVALID_PAIRING_METHOD),
            -14 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_INVALID_AUTH_DATA),
            -15 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_AUTH_DATA_MISMATCH),
            -16 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION),
            -17 => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE),
            -18 => ::std::option::Option::Some(MessageStatus::STATUS_KEYCODE_NOT_BOUND),
            -19 => ::std::option::Option::Some(MessageStatus::STATUS_RADIO_INVALID_STATION),
            -20 => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_INPUT),
            -21 => ::std::option::Option::Some(MessageStatus::STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED),
            -22 => ::std::option::Option::Some(MessageStatus::STATUS_RADIO_COMM_ERROR),
            -23 => ::std::option::Option::Some(MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID),
            -24 => ::std::option::Option::Some(MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED),
            -25 => ::std::option::Option::Some(MessageStatus::STATUS_PING_TIMEOUT),
            -250 => ::std::option::Option::Some(MessageStatus::STATUS_COMMAND_NOT_SUPPORTED),
            -251 => ::std::option::Option::Some(MessageStatus::STATUS_FRAMING_ERROR),
            -253 => ::std::option::Option::Some(MessageStatus::STATUS_UNEXPECTED_MESSAGE),
            -254 => ::std::option::Option::Some(MessageStatus::STATUS_BUSY),
            -255 => ::std::option::Option::Some(MessageStatus::STATUS_OUT_OF_MEMORY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MessageStatus> {
        match str {
            "STATUS_UNSOLICITED_MESSAGE" => ::std::option::Option::Some(MessageStatus::STATUS_UNSOLICITED_MESSAGE),
            "STATUS_SUCCESS" => ::std::option::Option::Some(MessageStatus::STATUS_SUCCESS),
            "STATUS_NO_COMPATIBLE_VERSION" => ::std::option::Option::Some(MessageStatus::STATUS_NO_COMPATIBLE_VERSION),
            "STATUS_CERTIFICATE_ERROR" => ::std::option::Option::Some(MessageStatus::STATUS_CERTIFICATE_ERROR),
            "STATUS_AUTHENTICATION_FAILURE" => ::std::option::Option::Some(MessageStatus::STATUS_AUTHENTICATION_FAILURE),
            "STATUS_INVALID_SERVICE" => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_SERVICE),
            "STATUS_INVALID_CHANNEL" => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_CHANNEL),
            "STATUS_INVALID_PRIORITY" => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_PRIORITY),
            "STATUS_INTERNAL_ERROR" => ::std::option::Option::Some(MessageStatus::STATUS_INTERNAL_ERROR),
            "STATUS_MEDIA_CONFIG_MISMATCH" => ::std::option::Option::Some(MessageStatus::STATUS_MEDIA_CONFIG_MISMATCH),
            "STATUS_INVALID_SENSOR" => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_SENSOR),
            "STATUS_BLUETOOTH_PAIRING_DELAYED" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_PAIRING_DELAYED),
            "STATUS_BLUETOOTH_UNAVAILABLE" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_UNAVAILABLE),
            "STATUS_BLUETOOTH_INVALID_ADDRESS" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_INVALID_ADDRESS),
            "STATUS_BLUETOOTH_INVALID_PAIRING_METHOD" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_INVALID_PAIRING_METHOD),
            "STATUS_BLUETOOTH_INVALID_AUTH_DATA" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_INVALID_AUTH_DATA),
            "STATUS_BLUETOOTH_AUTH_DATA_MISMATCH" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_AUTH_DATA_MISMATCH),
            "STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION),
            "STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE" => ::std::option::Option::Some(MessageStatus::STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE),
            "STATUS_KEYCODE_NOT_BOUND" => ::std::option::Option::Some(MessageStatus::STATUS_KEYCODE_NOT_BOUND),
            "STATUS_RADIO_INVALID_STATION" => ::std::option::Option::Some(MessageStatus::STATUS_RADIO_INVALID_STATION),
            "STATUS_INVALID_INPUT" => ::std::option::Option::Some(MessageStatus::STATUS_INVALID_INPUT),
            "STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED" => ::std::option::Option::Some(MessageStatus::STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED),
            "STATUS_RADIO_COMM_ERROR" => ::std::option::Option::Some(MessageStatus::STATUS_RADIO_COMM_ERROR),
            "STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID" => ::std::option::Option::Some(MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID),
            "STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED" => ::std::option::Option::Some(MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED),
            "STATUS_PING_TIMEOUT" => ::std::option::Option::Some(MessageStatus::STATUS_PING_TIMEOUT),
            "STATUS_COMMAND_NOT_SUPPORTED" => ::std::option::Option::Some(MessageStatus::STATUS_COMMAND_NOT_SUPPORTED),
            "STATUS_FRAMING_ERROR" => ::std::option::Option::Some(MessageStatus::STATUS_FRAMING_ERROR),
            "STATUS_UNEXPECTED_MESSAGE" => ::std::option::Option::Some(MessageStatus::STATUS_UNEXPECTED_MESSAGE),
            "STATUS_BUSY" => ::std::option::Option::Some(MessageStatus::STATUS_BUSY),
            "STATUS_OUT_OF_MEMORY" => ::std::option::Option::Some(MessageStatus::STATUS_OUT_OF_MEMORY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageStatus] = &[
        MessageStatus::STATUS_UNSOLICITED_MESSAGE,
        MessageStatus::STATUS_SUCCESS,
        MessageStatus::STATUS_NO_COMPATIBLE_VERSION,
        MessageStatus::STATUS_CERTIFICATE_ERROR,
        MessageStatus::STATUS_AUTHENTICATION_FAILURE,
        MessageStatus::STATUS_INVALID_SERVICE,
        MessageStatus::STATUS_INVALID_CHANNEL,
        MessageStatus::STATUS_INVALID_PRIORITY,
        MessageStatus::STATUS_INTERNAL_ERROR,
        MessageStatus::STATUS_MEDIA_CONFIG_MISMATCH,
        MessageStatus::STATUS_INVALID_SENSOR,
        MessageStatus::STATUS_BLUETOOTH_PAIRING_DELAYED,
        MessageStatus::STATUS_BLUETOOTH_UNAVAILABLE,
        MessageStatus::STATUS_BLUETOOTH_INVALID_ADDRESS,
        MessageStatus::STATUS_BLUETOOTH_INVALID_PAIRING_METHOD,
        MessageStatus::STATUS_BLUETOOTH_INVALID_AUTH_DATA,
        MessageStatus::STATUS_BLUETOOTH_AUTH_DATA_MISMATCH,
        MessageStatus::STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION,
        MessageStatus::STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE,
        MessageStatus::STATUS_KEYCODE_NOT_BOUND,
        MessageStatus::STATUS_RADIO_INVALID_STATION,
        MessageStatus::STATUS_INVALID_INPUT,
        MessageStatus::STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED,
        MessageStatus::STATUS_RADIO_COMM_ERROR,
        MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID,
        MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED,
        MessageStatus::STATUS_PING_TIMEOUT,
        MessageStatus::STATUS_COMMAND_NOT_SUPPORTED,
        MessageStatus::STATUS_FRAMING_ERROR,
        MessageStatus::STATUS_UNEXPECTED_MESSAGE,
        MessageStatus::STATUS_BUSY,
        MessageStatus::STATUS_OUT_OF_MEMORY,
    ];
}

impl ::protobuf::EnumFull for MessageStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MessageStatus::STATUS_UNSOLICITED_MESSAGE => 0,
            MessageStatus::STATUS_SUCCESS => 1,
            MessageStatus::STATUS_NO_COMPATIBLE_VERSION => 2,
            MessageStatus::STATUS_CERTIFICATE_ERROR => 3,
            MessageStatus::STATUS_AUTHENTICATION_FAILURE => 4,
            MessageStatus::STATUS_INVALID_SERVICE => 5,
            MessageStatus::STATUS_INVALID_CHANNEL => 6,
            MessageStatus::STATUS_INVALID_PRIORITY => 7,
            MessageStatus::STATUS_INTERNAL_ERROR => 8,
            MessageStatus::STATUS_MEDIA_CONFIG_MISMATCH => 9,
            MessageStatus::STATUS_INVALID_SENSOR => 10,
            MessageStatus::STATUS_BLUETOOTH_PAIRING_DELAYED => 11,
            MessageStatus::STATUS_BLUETOOTH_UNAVAILABLE => 12,
            MessageStatus::STATUS_BLUETOOTH_INVALID_ADDRESS => 13,
            MessageStatus::STATUS_BLUETOOTH_INVALID_PAIRING_METHOD => 14,
            MessageStatus::STATUS_BLUETOOTH_INVALID_AUTH_DATA => 15,
            MessageStatus::STATUS_BLUETOOTH_AUTH_DATA_MISMATCH => 16,
            MessageStatus::STATUS_BLUETOOTH_HFP_ANOTHER_CONNECTION => 17,
            MessageStatus::STATUS_BLUETOOTH_HFP_CONNECTION_FAILURE => 18,
            MessageStatus::STATUS_KEYCODE_NOT_BOUND => 19,
            MessageStatus::STATUS_RADIO_INVALID_STATION => 20,
            MessageStatus::STATUS_INVALID_INPUT => 21,
            MessageStatus::STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED => 22,
            MessageStatus::STATUS_RADIO_COMM_ERROR => 23,
            MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_NOT_YET_VALID => 24,
            MessageStatus::STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED => 25,
            MessageStatus::STATUS_PING_TIMEOUT => 26,
            MessageStatus::STATUS_COMMAND_NOT_SUPPORTED => 27,
            MessageStatus::STATUS_FRAMING_ERROR => 28,
            MessageStatus::STATUS_UNEXPECTED_MESSAGE => 29,
            MessageStatus::STATUS_BUSY => 30,
            MessageStatus::STATUS_OUT_OF_MEMORY => 31,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MessageStatus {
    fn default() -> Self {
        MessageStatus::STATUS_UNSOLICITED_MESSAGE
    }
}

impl MessageStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageStatus>("MessageStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:KeyCode)
pub enum KeyCode {
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_UNKNOWN)
    KEYCODE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SOFT_LEFT)
    KEYCODE_SOFT_LEFT = 1,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SOFT_RIGHT)
    KEYCODE_SOFT_RIGHT = 2,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_HOME)
    KEYCODE_HOME = 3,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BACK)
    KEYCODE_BACK = 4,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CALL)
    KEYCODE_CALL = 5,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ENDCALL)
    KEYCODE_ENDCALL = 6,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_0)
    KEYCODE_0 = 7,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_1)
    KEYCODE_1 = 8,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_2)
    KEYCODE_2 = 9,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_3)
    KEYCODE_3 = 10,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_4)
    KEYCODE_4 = 11,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_5)
    KEYCODE_5 = 12,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_6)
    KEYCODE_6 = 13,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_7)
    KEYCODE_7 = 14,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_8)
    KEYCODE_8 = 15,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_9)
    KEYCODE_9 = 16,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_STAR)
    KEYCODE_STAR = 17,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_POUND)
    KEYCODE_POUND = 18,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_UP)
    KEYCODE_DPAD_UP = 19,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_DOWN)
    KEYCODE_DPAD_DOWN = 20,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_LEFT)
    KEYCODE_DPAD_LEFT = 21,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_RIGHT)
    KEYCODE_DPAD_RIGHT = 22,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_CENTER)
    KEYCODE_DPAD_CENTER = 23,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_VOLUME_UP)
    KEYCODE_VOLUME_UP = 24,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_VOLUME_DOWN)
    KEYCODE_VOLUME_DOWN = 25,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_POWER)
    KEYCODE_POWER = 26,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CAMERA)
    KEYCODE_CAMERA = 27,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CLEAR)
    KEYCODE_CLEAR = 28,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_A)
    KEYCODE_A = 29,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_B)
    KEYCODE_B = 30,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_C)
    KEYCODE_C = 31,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_D)
    KEYCODE_D = 32,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_E)
    KEYCODE_E = 33,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F)
    KEYCODE_F = 34,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_G)
    KEYCODE_G = 35,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_H)
    KEYCODE_H = 36,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_I)
    KEYCODE_I = 37,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_J)
    KEYCODE_J = 38,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_K)
    KEYCODE_K = 39,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_L)
    KEYCODE_L = 40,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_M)
    KEYCODE_M = 41,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_N)
    KEYCODE_N = 42,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_O)
    KEYCODE_O = 43,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_P)
    KEYCODE_P = 44,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_Q)
    KEYCODE_Q = 45,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_R)
    KEYCODE_R = 46,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_S)
    KEYCODE_S = 47,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_T)
    KEYCODE_T = 48,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_U)
    KEYCODE_U = 49,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_V)
    KEYCODE_V = 50,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_W)
    KEYCODE_W = 51,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_X)
    KEYCODE_X = 52,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_Y)
    KEYCODE_Y = 53,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_Z)
    KEYCODE_Z = 54,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_COMMA)
    KEYCODE_COMMA = 55,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PERIOD)
    KEYCODE_PERIOD = 56,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ALT_LEFT)
    KEYCODE_ALT_LEFT = 57,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ALT_RIGHT)
    KEYCODE_ALT_RIGHT = 58,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SHIFT_LEFT)
    KEYCODE_SHIFT_LEFT = 59,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SHIFT_RIGHT)
    KEYCODE_SHIFT_RIGHT = 60,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TAB)
    KEYCODE_TAB = 61,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SPACE)
    KEYCODE_SPACE = 62,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SYM)
    KEYCODE_SYM = 63,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_EXPLORER)
    KEYCODE_EXPLORER = 64,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ENVELOPE)
    KEYCODE_ENVELOPE = 65,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ENTER)
    KEYCODE_ENTER = 66,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DEL)
    KEYCODE_DEL = 67,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_GRAVE)
    KEYCODE_GRAVE = 68,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MINUS)
    KEYCODE_MINUS = 69,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_EQUALS)
    KEYCODE_EQUALS = 70,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_LEFT_BRACKET)
    KEYCODE_LEFT_BRACKET = 71,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_RIGHT_BRACKET)
    KEYCODE_RIGHT_BRACKET = 72,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BACKSLASH)
    KEYCODE_BACKSLASH = 73,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SEMICOLON)
    KEYCODE_SEMICOLON = 74,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_APOSTROPHE)
    KEYCODE_APOSTROPHE = 75,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SLASH)
    KEYCODE_SLASH = 76,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_AT)
    KEYCODE_AT = 77,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUM)
    KEYCODE_NUM = 78,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_HEADSETHOOK)
    KEYCODE_HEADSETHOOK = 79,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_FOCUS)
    KEYCODE_FOCUS = 80,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PLUS)
    KEYCODE_PLUS = 81,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MENU)
    KEYCODE_MENU = 82,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NOTIFICATION)
    KEYCODE_NOTIFICATION = 83,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SEARCH)
    KEYCODE_SEARCH = 84,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_PLAY_PAUSE)
    KEYCODE_MEDIA_PLAY_PAUSE = 85,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_STOP)
    KEYCODE_MEDIA_STOP = 86,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_NEXT)
    KEYCODE_MEDIA_NEXT = 87,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_PREVIOUS)
    KEYCODE_MEDIA_PREVIOUS = 88,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_REWIND)
    KEYCODE_MEDIA_REWIND = 89,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_FAST_FORWARD)
    KEYCODE_MEDIA_FAST_FORWARD = 90,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MUTE)
    KEYCODE_MUTE = 91,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PAGE_UP)
    KEYCODE_PAGE_UP = 92,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PAGE_DOWN)
    KEYCODE_PAGE_DOWN = 93,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PICTSYMBOLS)
    KEYCODE_PICTSYMBOLS = 94,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SWITCH_CHARSET)
    KEYCODE_SWITCH_CHARSET = 95,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_A)
    KEYCODE_BUTTON_A = 96,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_B)
    KEYCODE_BUTTON_B = 97,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_C)
    KEYCODE_BUTTON_C = 98,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_X)
    KEYCODE_BUTTON_X = 99,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_Y)
    KEYCODE_BUTTON_Y = 100,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_Z)
    KEYCODE_BUTTON_Z = 101,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_L1)
    KEYCODE_BUTTON_L1 = 102,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_R1)
    KEYCODE_BUTTON_R1 = 103,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_L2)
    KEYCODE_BUTTON_L2 = 104,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_R2)
    KEYCODE_BUTTON_R2 = 105,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_THUMBL)
    KEYCODE_BUTTON_THUMBL = 106,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_THUMBR)
    KEYCODE_BUTTON_THUMBR = 107,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_START)
    KEYCODE_BUTTON_START = 108,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_SELECT)
    KEYCODE_BUTTON_SELECT = 109,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_MODE)
    KEYCODE_BUTTON_MODE = 110,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ESCAPE)
    KEYCODE_ESCAPE = 111,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_FORWARD_DEL)
    KEYCODE_FORWARD_DEL = 112,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CTRL_LEFT)
    KEYCODE_CTRL_LEFT = 113,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CTRL_RIGHT)
    KEYCODE_CTRL_RIGHT = 114,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CAPS_LOCK)
    KEYCODE_CAPS_LOCK = 115,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SCROLL_LOCK)
    KEYCODE_SCROLL_LOCK = 116,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_META_LEFT)
    KEYCODE_META_LEFT = 117,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_META_RIGHT)
    KEYCODE_META_RIGHT = 118,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_FUNCTION)
    KEYCODE_FUNCTION = 119,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SYSRQ)
    KEYCODE_SYSRQ = 120,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BREAK)
    KEYCODE_BREAK = 121,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MOVE_HOME)
    KEYCODE_MOVE_HOME = 122,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MOVE_END)
    KEYCODE_MOVE_END = 123,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_INSERT)
    KEYCODE_INSERT = 124,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_FORWARD)
    KEYCODE_FORWARD = 125,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_PLAY)
    KEYCODE_MEDIA_PLAY = 126,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_PAUSE)
    KEYCODE_MEDIA_PAUSE = 127,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_CLOSE)
    KEYCODE_MEDIA_CLOSE = 128,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_EJECT)
    KEYCODE_MEDIA_EJECT = 129,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_RECORD)
    KEYCODE_MEDIA_RECORD = 130,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F1)
    KEYCODE_F1 = 131,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F2)
    KEYCODE_F2 = 132,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F3)
    KEYCODE_F3 = 133,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F4)
    KEYCODE_F4 = 134,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F5)
    KEYCODE_F5 = 135,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F6)
    KEYCODE_F6 = 136,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F7)
    KEYCODE_F7 = 137,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F8)
    KEYCODE_F8 = 138,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F9)
    KEYCODE_F9 = 139,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F10)
    KEYCODE_F10 = 140,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F11)
    KEYCODE_F11 = 141,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_F12)
    KEYCODE_F12 = 142,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUM_LOCK)
    KEYCODE_NUM_LOCK = 143,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_0)
    KEYCODE_NUMPAD_0 = 144,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_1)
    KEYCODE_NUMPAD_1 = 145,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_2)
    KEYCODE_NUMPAD_2 = 146,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_3)
    KEYCODE_NUMPAD_3 = 147,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_4)
    KEYCODE_NUMPAD_4 = 148,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_5)
    KEYCODE_NUMPAD_5 = 149,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_6)
    KEYCODE_NUMPAD_6 = 150,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_7)
    KEYCODE_NUMPAD_7 = 151,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_8)
    KEYCODE_NUMPAD_8 = 152,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_9)
    KEYCODE_NUMPAD_9 = 153,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_DIVIDE)
    KEYCODE_NUMPAD_DIVIDE = 154,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_MULTIPLY)
    KEYCODE_NUMPAD_MULTIPLY = 155,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_SUBTRACT)
    KEYCODE_NUMPAD_SUBTRACT = 156,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_ADD)
    KEYCODE_NUMPAD_ADD = 157,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_DOT)
    KEYCODE_NUMPAD_DOT = 158,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_COMMA)
    KEYCODE_NUMPAD_COMMA = 159,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_ENTER)
    KEYCODE_NUMPAD_ENTER = 160,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_EQUALS)
    KEYCODE_NUMPAD_EQUALS = 161,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_LEFT_PAREN)
    KEYCODE_NUMPAD_LEFT_PAREN = 162,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NUMPAD_RIGHT_PAREN)
    KEYCODE_NUMPAD_RIGHT_PAREN = 163,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_VOLUME_MUTE)
    KEYCODE_VOLUME_MUTE = 164,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_INFO)
    KEYCODE_INFO = 165,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CHANNEL_UP)
    KEYCODE_CHANNEL_UP = 166,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CHANNEL_DOWN)
    KEYCODE_CHANNEL_DOWN = 167,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ZOOM_IN)
    KEYCODE_ZOOM_IN = 168,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ZOOM_OUT)
    KEYCODE_ZOOM_OUT = 169,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV)
    KEYCODE_TV = 170,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_WINDOW)
    KEYCODE_WINDOW = 171,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_GUIDE)
    KEYCODE_GUIDE = 172,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DVR)
    KEYCODE_DVR = 173,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BOOKMARK)
    KEYCODE_BOOKMARK = 174,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CAPTIONS)
    KEYCODE_CAPTIONS = 175,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SETTINGS)
    KEYCODE_SETTINGS = 176,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_POWER)
    KEYCODE_TV_POWER = 177,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT)
    KEYCODE_TV_INPUT = 178,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_STB_POWER)
    KEYCODE_STB_POWER = 179,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_STB_INPUT)
    KEYCODE_STB_INPUT = 180,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_AVR_POWER)
    KEYCODE_AVR_POWER = 181,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_AVR_INPUT)
    KEYCODE_AVR_INPUT = 182,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PROG_RED)
    KEYCODE_PROG_RED = 183,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PROG_GREEN)
    KEYCODE_PROG_GREEN = 184,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PROG_YELLOW)
    KEYCODE_PROG_YELLOW = 185,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PROG_BLUE)
    KEYCODE_PROG_BLUE = 186,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_APP_SWITCH)
    KEYCODE_APP_SWITCH = 187,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_1)
    KEYCODE_BUTTON_1 = 188,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_2)
    KEYCODE_BUTTON_2 = 189,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_3)
    KEYCODE_BUTTON_3 = 190,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_4)
    KEYCODE_BUTTON_4 = 191,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_5)
    KEYCODE_BUTTON_5 = 192,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_6)
    KEYCODE_BUTTON_6 = 193,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_7)
    KEYCODE_BUTTON_7 = 194,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_8)
    KEYCODE_BUTTON_8 = 195,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_9)
    KEYCODE_BUTTON_9 = 196,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_10)
    KEYCODE_BUTTON_10 = 197,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_11)
    KEYCODE_BUTTON_11 = 198,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_12)
    KEYCODE_BUTTON_12 = 199,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_13)
    KEYCODE_BUTTON_13 = 200,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_14)
    KEYCODE_BUTTON_14 = 201,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_15)
    KEYCODE_BUTTON_15 = 202,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BUTTON_16)
    KEYCODE_BUTTON_16 = 203,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_LANGUAGE_SWITCH)
    KEYCODE_LANGUAGE_SWITCH = 204,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MANNER_MODE)
    KEYCODE_MANNER_MODE = 205,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_3D_MODE)
    KEYCODE_3D_MODE = 206,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CONTACTS)
    KEYCODE_CONTACTS = 207,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CALENDAR)
    KEYCODE_CALENDAR = 208,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MUSIC)
    KEYCODE_MUSIC = 209,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_CALCULATOR)
    KEYCODE_CALCULATOR = 210,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ZENKAKU_HANKAKU)
    KEYCODE_ZENKAKU_HANKAKU = 211,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_EISU)
    KEYCODE_EISU = 212,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MUHENKAN)
    KEYCODE_MUHENKAN = 213,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_HENKAN)
    KEYCODE_HENKAN = 214,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_KATAKANA_HIRAGANA)
    KEYCODE_KATAKANA_HIRAGANA = 215,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_YEN)
    KEYCODE_YEN = 216,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_RO)
    KEYCODE_RO = 217,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_KANA)
    KEYCODE_KANA = 218,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ASSIST)
    KEYCODE_ASSIST = 219,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BRIGHTNESS_DOWN)
    KEYCODE_BRIGHTNESS_DOWN = 220,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_BRIGHTNESS_UP)
    KEYCODE_BRIGHTNESS_UP = 221,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_AUDIO_TRACK)
    KEYCODE_MEDIA_AUDIO_TRACK = 222,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SLEEP)
    KEYCODE_SLEEP = 223,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_WAKEUP)
    KEYCODE_WAKEUP = 224,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PAIRING)
    KEYCODE_PAIRING = 225,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA_TOP_MENU)
    KEYCODE_MEDIA_TOP_MENU = 226,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_11)
    KEYCODE_11 = 227,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_12)
    KEYCODE_12 = 228,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_LAST_CHANNEL)
    KEYCODE_LAST_CHANNEL = 229,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_DATA_SERVICE)
    KEYCODE_TV_DATA_SERVICE = 230,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_VOICE_ASSIST)
    KEYCODE_VOICE_ASSIST = 231,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_RADIO_SERVICE)
    KEYCODE_TV_RADIO_SERVICE = 232,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_TELETEXT)
    KEYCODE_TV_TELETEXT = 233,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_NUMBER_ENTRY)
    KEYCODE_TV_NUMBER_ENTRY = 234,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_TERRESTRIAL_ANALOG)
    KEYCODE_TV_TERRESTRIAL_ANALOG = 235,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_TERRESTRIAL_DIGITAL)
    KEYCODE_TV_TERRESTRIAL_DIGITAL = 236,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_SATELLITE)
    KEYCODE_TV_SATELLITE = 237,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_SATELLITE_BS)
    KEYCODE_TV_SATELLITE_BS = 238,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_SATELLITE_CS)
    KEYCODE_TV_SATELLITE_CS = 239,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_SATELLITE_SERVICE)
    KEYCODE_TV_SATELLITE_SERVICE = 240,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_NETWORK)
    KEYCODE_TV_NETWORK = 241,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_ANTENNA_CABLE)
    KEYCODE_TV_ANTENNA_CABLE = 242,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_HDMI_1)
    KEYCODE_TV_INPUT_HDMI_1 = 243,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_HDMI_2)
    KEYCODE_TV_INPUT_HDMI_2 = 244,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_HDMI_3)
    KEYCODE_TV_INPUT_HDMI_3 = 245,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_HDMI_4)
    KEYCODE_TV_INPUT_HDMI_4 = 246,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_COMPOSITE_1)
    KEYCODE_TV_INPUT_COMPOSITE_1 = 247,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_COMPOSITE_2)
    KEYCODE_TV_INPUT_COMPOSITE_2 = 248,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_COMPONENT_1)
    KEYCODE_TV_INPUT_COMPONENT_1 = 249,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_COMPONENT_2)
    KEYCODE_TV_INPUT_COMPONENT_2 = 250,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_INPUT_VGA_1)
    KEYCODE_TV_INPUT_VGA_1 = 251,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_AUDIO_DESCRIPTION)
    KEYCODE_TV_AUDIO_DESCRIPTION = 252,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP)
    KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP = 253,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN)
    KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN = 254,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_ZOOM_MODE)
    KEYCODE_TV_ZOOM_MODE = 255,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_CONTENTS_MENU)
    KEYCODE_TV_CONTENTS_MENU = 256,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_MEDIA_CONTEXT_MENU)
    KEYCODE_TV_MEDIA_CONTEXT_MENU = 257,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TV_TIMER_PROGRAMMING)
    KEYCODE_TV_TIMER_PROGRAMMING = 258,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_HELP)
    KEYCODE_HELP = 259,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NAVIGATE_PREVIOUS)
    KEYCODE_NAVIGATE_PREVIOUS = 260,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NAVIGATE_NEXT)
    KEYCODE_NAVIGATE_NEXT = 261,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NAVIGATE_IN)
    KEYCODE_NAVIGATE_IN = 262,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NAVIGATE_OUT)
    KEYCODE_NAVIGATE_OUT = 263,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_UP_LEFT)
    KEYCODE_DPAD_UP_LEFT = 268,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_DOWN_LEFT)
    KEYCODE_DPAD_DOWN_LEFT = 269,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_UP_RIGHT)
    KEYCODE_DPAD_UP_RIGHT = 270,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_DPAD_DOWN_RIGHT)
    KEYCODE_DPAD_DOWN_RIGHT = 271,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SENTINEL)
    KEYCODE_SENTINEL = 65535,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_ROTARY_CONTROLLER)
    KEYCODE_ROTARY_CONTROLLER = 65536,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_MEDIA)
    KEYCODE_MEDIA = 65537,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_NAVIGATION)
    KEYCODE_NAVIGATION = 65538,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_RADIO)
    KEYCODE_RADIO = 65539,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TEL)
    KEYCODE_TEL = 65540,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_PRIMARY_BUTTON)
    KEYCODE_PRIMARY_BUTTON = 65541,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_SECONDARY_BUTTON)
    KEYCODE_SECONDARY_BUTTON = 65542,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TERTIARY_BUTTON)
    KEYCODE_TERTIARY_BUTTON = 65543,
    // @@protoc_insertion_point(enum_value:KeyCode.KEYCODE_TURN_CARD)
    KEYCODE_TURN_CARD = 65544,
}

impl ::protobuf::Enum for KeyCode {
    const NAME: &'static str = "KeyCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyCode> {
        match value {
            0 => ::std::option::Option::Some(KeyCode::KEYCODE_UNKNOWN),
            1 => ::std::option::Option::Some(KeyCode::KEYCODE_SOFT_LEFT),
            2 => ::std::option::Option::Some(KeyCode::KEYCODE_SOFT_RIGHT),
            3 => ::std::option::Option::Some(KeyCode::KEYCODE_HOME),
            4 => ::std::option::Option::Some(KeyCode::KEYCODE_BACK),
            5 => ::std::option::Option::Some(KeyCode::KEYCODE_CALL),
            6 => ::std::option::Option::Some(KeyCode::KEYCODE_ENDCALL),
            7 => ::std::option::Option::Some(KeyCode::KEYCODE_0),
            8 => ::std::option::Option::Some(KeyCode::KEYCODE_1),
            9 => ::std::option::Option::Some(KeyCode::KEYCODE_2),
            10 => ::std::option::Option::Some(KeyCode::KEYCODE_3),
            11 => ::std::option::Option::Some(KeyCode::KEYCODE_4),
            12 => ::std::option::Option::Some(KeyCode::KEYCODE_5),
            13 => ::std::option::Option::Some(KeyCode::KEYCODE_6),
            14 => ::std::option::Option::Some(KeyCode::KEYCODE_7),
            15 => ::std::option::Option::Some(KeyCode::KEYCODE_8),
            16 => ::std::option::Option::Some(KeyCode::KEYCODE_9),
            17 => ::std::option::Option::Some(KeyCode::KEYCODE_STAR),
            18 => ::std::option::Option::Some(KeyCode::KEYCODE_POUND),
            19 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_UP),
            20 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_DOWN),
            21 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_LEFT),
            22 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_RIGHT),
            23 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_CENTER),
            24 => ::std::option::Option::Some(KeyCode::KEYCODE_VOLUME_UP),
            25 => ::std::option::Option::Some(KeyCode::KEYCODE_VOLUME_DOWN),
            26 => ::std::option::Option::Some(KeyCode::KEYCODE_POWER),
            27 => ::std::option::Option::Some(KeyCode::KEYCODE_CAMERA),
            28 => ::std::option::Option::Some(KeyCode::KEYCODE_CLEAR),
            29 => ::std::option::Option::Some(KeyCode::KEYCODE_A),
            30 => ::std::option::Option::Some(KeyCode::KEYCODE_B),
            31 => ::std::option::Option::Some(KeyCode::KEYCODE_C),
            32 => ::std::option::Option::Some(KeyCode::KEYCODE_D),
            33 => ::std::option::Option::Some(KeyCode::KEYCODE_E),
            34 => ::std::option::Option::Some(KeyCode::KEYCODE_F),
            35 => ::std::option::Option::Some(KeyCode::KEYCODE_G),
            36 => ::std::option::Option::Some(KeyCode::KEYCODE_H),
            37 => ::std::option::Option::Some(KeyCode::KEYCODE_I),
            38 => ::std::option::Option::Some(KeyCode::KEYCODE_J),
            39 => ::std::option::Option::Some(KeyCode::KEYCODE_K),
            40 => ::std::option::Option::Some(KeyCode::KEYCODE_L),
            41 => ::std::option::Option::Some(KeyCode::KEYCODE_M),
            42 => ::std::option::Option::Some(KeyCode::KEYCODE_N),
            43 => ::std::option::Option::Some(KeyCode::KEYCODE_O),
            44 => ::std::option::Option::Some(KeyCode::KEYCODE_P),
            45 => ::std::option::Option::Some(KeyCode::KEYCODE_Q),
            46 => ::std::option::Option::Some(KeyCode::KEYCODE_R),
            47 => ::std::option::Option::Some(KeyCode::KEYCODE_S),
            48 => ::std::option::Option::Some(KeyCode::KEYCODE_T),
            49 => ::std::option::Option::Some(KeyCode::KEYCODE_U),
            50 => ::std::option::Option::Some(KeyCode::KEYCODE_V),
            51 => ::std::option::Option::Some(KeyCode::KEYCODE_W),
            52 => ::std::option::Option::Some(KeyCode::KEYCODE_X),
            53 => ::std::option::Option::Some(KeyCode::KEYCODE_Y),
            54 => ::std::option::Option::Some(KeyCode::KEYCODE_Z),
            55 => ::std::option::Option::Some(KeyCode::KEYCODE_COMMA),
            56 => ::std::option::Option::Some(KeyCode::KEYCODE_PERIOD),
            57 => ::std::option::Option::Some(KeyCode::KEYCODE_ALT_LEFT),
            58 => ::std::option::Option::Some(KeyCode::KEYCODE_ALT_RIGHT),
            59 => ::std::option::Option::Some(KeyCode::KEYCODE_SHIFT_LEFT),
            60 => ::std::option::Option::Some(KeyCode::KEYCODE_SHIFT_RIGHT),
            61 => ::std::option::Option::Some(KeyCode::KEYCODE_TAB),
            62 => ::std::option::Option::Some(KeyCode::KEYCODE_SPACE),
            63 => ::std::option::Option::Some(KeyCode::KEYCODE_SYM),
            64 => ::std::option::Option::Some(KeyCode::KEYCODE_EXPLORER),
            65 => ::std::option::Option::Some(KeyCode::KEYCODE_ENVELOPE),
            66 => ::std::option::Option::Some(KeyCode::KEYCODE_ENTER),
            67 => ::std::option::Option::Some(KeyCode::KEYCODE_DEL),
            68 => ::std::option::Option::Some(KeyCode::KEYCODE_GRAVE),
            69 => ::std::option::Option::Some(KeyCode::KEYCODE_MINUS),
            70 => ::std::option::Option::Some(KeyCode::KEYCODE_EQUALS),
            71 => ::std::option::Option::Some(KeyCode::KEYCODE_LEFT_BRACKET),
            72 => ::std::option::Option::Some(KeyCode::KEYCODE_RIGHT_BRACKET),
            73 => ::std::option::Option::Some(KeyCode::KEYCODE_BACKSLASH),
            74 => ::std::option::Option::Some(KeyCode::KEYCODE_SEMICOLON),
            75 => ::std::option::Option::Some(KeyCode::KEYCODE_APOSTROPHE),
            76 => ::std::option::Option::Some(KeyCode::KEYCODE_SLASH),
            77 => ::std::option::Option::Some(KeyCode::KEYCODE_AT),
            78 => ::std::option::Option::Some(KeyCode::KEYCODE_NUM),
            79 => ::std::option::Option::Some(KeyCode::KEYCODE_HEADSETHOOK),
            80 => ::std::option::Option::Some(KeyCode::KEYCODE_FOCUS),
            81 => ::std::option::Option::Some(KeyCode::KEYCODE_PLUS),
            82 => ::std::option::Option::Some(KeyCode::KEYCODE_MENU),
            83 => ::std::option::Option::Some(KeyCode::KEYCODE_NOTIFICATION),
            84 => ::std::option::Option::Some(KeyCode::KEYCODE_SEARCH),
            85 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PLAY_PAUSE),
            86 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_STOP),
            87 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_NEXT),
            88 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PREVIOUS),
            89 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_REWIND),
            90 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_FAST_FORWARD),
            91 => ::std::option::Option::Some(KeyCode::KEYCODE_MUTE),
            92 => ::std::option::Option::Some(KeyCode::KEYCODE_PAGE_UP),
            93 => ::std::option::Option::Some(KeyCode::KEYCODE_PAGE_DOWN),
            94 => ::std::option::Option::Some(KeyCode::KEYCODE_PICTSYMBOLS),
            95 => ::std::option::Option::Some(KeyCode::KEYCODE_SWITCH_CHARSET),
            96 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_A),
            97 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_B),
            98 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_C),
            99 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_X),
            100 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_Y),
            101 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_Z),
            102 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_L1),
            103 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_R1),
            104 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_L2),
            105 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_R2),
            106 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_THUMBL),
            107 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_THUMBR),
            108 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_START),
            109 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_SELECT),
            110 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_MODE),
            111 => ::std::option::Option::Some(KeyCode::KEYCODE_ESCAPE),
            112 => ::std::option::Option::Some(KeyCode::KEYCODE_FORWARD_DEL),
            113 => ::std::option::Option::Some(KeyCode::KEYCODE_CTRL_LEFT),
            114 => ::std::option::Option::Some(KeyCode::KEYCODE_CTRL_RIGHT),
            115 => ::std::option::Option::Some(KeyCode::KEYCODE_CAPS_LOCK),
            116 => ::std::option::Option::Some(KeyCode::KEYCODE_SCROLL_LOCK),
            117 => ::std::option::Option::Some(KeyCode::KEYCODE_META_LEFT),
            118 => ::std::option::Option::Some(KeyCode::KEYCODE_META_RIGHT),
            119 => ::std::option::Option::Some(KeyCode::KEYCODE_FUNCTION),
            120 => ::std::option::Option::Some(KeyCode::KEYCODE_SYSRQ),
            121 => ::std::option::Option::Some(KeyCode::KEYCODE_BREAK),
            122 => ::std::option::Option::Some(KeyCode::KEYCODE_MOVE_HOME),
            123 => ::std::option::Option::Some(KeyCode::KEYCODE_MOVE_END),
            124 => ::std::option::Option::Some(KeyCode::KEYCODE_INSERT),
            125 => ::std::option::Option::Some(KeyCode::KEYCODE_FORWARD),
            126 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PLAY),
            127 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PAUSE),
            128 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_CLOSE),
            129 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_EJECT),
            130 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_RECORD),
            131 => ::std::option::Option::Some(KeyCode::KEYCODE_F1),
            132 => ::std::option::Option::Some(KeyCode::KEYCODE_F2),
            133 => ::std::option::Option::Some(KeyCode::KEYCODE_F3),
            134 => ::std::option::Option::Some(KeyCode::KEYCODE_F4),
            135 => ::std::option::Option::Some(KeyCode::KEYCODE_F5),
            136 => ::std::option::Option::Some(KeyCode::KEYCODE_F6),
            137 => ::std::option::Option::Some(KeyCode::KEYCODE_F7),
            138 => ::std::option::Option::Some(KeyCode::KEYCODE_F8),
            139 => ::std::option::Option::Some(KeyCode::KEYCODE_F9),
            140 => ::std::option::Option::Some(KeyCode::KEYCODE_F10),
            141 => ::std::option::Option::Some(KeyCode::KEYCODE_F11),
            142 => ::std::option::Option::Some(KeyCode::KEYCODE_F12),
            143 => ::std::option::Option::Some(KeyCode::KEYCODE_NUM_LOCK),
            144 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_0),
            145 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_1),
            146 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_2),
            147 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_3),
            148 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_4),
            149 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_5),
            150 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_6),
            151 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_7),
            152 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_8),
            153 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_9),
            154 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_DIVIDE),
            155 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_MULTIPLY),
            156 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_SUBTRACT),
            157 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_ADD),
            158 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_DOT),
            159 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_COMMA),
            160 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_ENTER),
            161 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_EQUALS),
            162 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_LEFT_PAREN),
            163 => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_RIGHT_PAREN),
            164 => ::std::option::Option::Some(KeyCode::KEYCODE_VOLUME_MUTE),
            165 => ::std::option::Option::Some(KeyCode::KEYCODE_INFO),
            166 => ::std::option::Option::Some(KeyCode::KEYCODE_CHANNEL_UP),
            167 => ::std::option::Option::Some(KeyCode::KEYCODE_CHANNEL_DOWN),
            168 => ::std::option::Option::Some(KeyCode::KEYCODE_ZOOM_IN),
            169 => ::std::option::Option::Some(KeyCode::KEYCODE_ZOOM_OUT),
            170 => ::std::option::Option::Some(KeyCode::KEYCODE_TV),
            171 => ::std::option::Option::Some(KeyCode::KEYCODE_WINDOW),
            172 => ::std::option::Option::Some(KeyCode::KEYCODE_GUIDE),
            173 => ::std::option::Option::Some(KeyCode::KEYCODE_DVR),
            174 => ::std::option::Option::Some(KeyCode::KEYCODE_BOOKMARK),
            175 => ::std::option::Option::Some(KeyCode::KEYCODE_CAPTIONS),
            176 => ::std::option::Option::Some(KeyCode::KEYCODE_SETTINGS),
            177 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_POWER),
            178 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT),
            179 => ::std::option::Option::Some(KeyCode::KEYCODE_STB_POWER),
            180 => ::std::option::Option::Some(KeyCode::KEYCODE_STB_INPUT),
            181 => ::std::option::Option::Some(KeyCode::KEYCODE_AVR_POWER),
            182 => ::std::option::Option::Some(KeyCode::KEYCODE_AVR_INPUT),
            183 => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_RED),
            184 => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_GREEN),
            185 => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_YELLOW),
            186 => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_BLUE),
            187 => ::std::option::Option::Some(KeyCode::KEYCODE_APP_SWITCH),
            188 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_1),
            189 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_2),
            190 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_3),
            191 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_4),
            192 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_5),
            193 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_6),
            194 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_7),
            195 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_8),
            196 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_9),
            197 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_10),
            198 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_11),
            199 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_12),
            200 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_13),
            201 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_14),
            202 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_15),
            203 => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_16),
            204 => ::std::option::Option::Some(KeyCode::KEYCODE_LANGUAGE_SWITCH),
            205 => ::std::option::Option::Some(KeyCode::KEYCODE_MANNER_MODE),
            206 => ::std::option::Option::Some(KeyCode::KEYCODE_3D_MODE),
            207 => ::std::option::Option::Some(KeyCode::KEYCODE_CONTACTS),
            208 => ::std::option::Option::Some(KeyCode::KEYCODE_CALENDAR),
            209 => ::std::option::Option::Some(KeyCode::KEYCODE_MUSIC),
            210 => ::std::option::Option::Some(KeyCode::KEYCODE_CALCULATOR),
            211 => ::std::option::Option::Some(KeyCode::KEYCODE_ZENKAKU_HANKAKU),
            212 => ::std::option::Option::Some(KeyCode::KEYCODE_EISU),
            213 => ::std::option::Option::Some(KeyCode::KEYCODE_MUHENKAN),
            214 => ::std::option::Option::Some(KeyCode::KEYCODE_HENKAN),
            215 => ::std::option::Option::Some(KeyCode::KEYCODE_KATAKANA_HIRAGANA),
            216 => ::std::option::Option::Some(KeyCode::KEYCODE_YEN),
            217 => ::std::option::Option::Some(KeyCode::KEYCODE_RO),
            218 => ::std::option::Option::Some(KeyCode::KEYCODE_KANA),
            219 => ::std::option::Option::Some(KeyCode::KEYCODE_ASSIST),
            220 => ::std::option::Option::Some(KeyCode::KEYCODE_BRIGHTNESS_DOWN),
            221 => ::std::option::Option::Some(KeyCode::KEYCODE_BRIGHTNESS_UP),
            222 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_AUDIO_TRACK),
            223 => ::std::option::Option::Some(KeyCode::KEYCODE_SLEEP),
            224 => ::std::option::Option::Some(KeyCode::KEYCODE_WAKEUP),
            225 => ::std::option::Option::Some(KeyCode::KEYCODE_PAIRING),
            226 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_TOP_MENU),
            227 => ::std::option::Option::Some(KeyCode::KEYCODE_11),
            228 => ::std::option::Option::Some(KeyCode::KEYCODE_12),
            229 => ::std::option::Option::Some(KeyCode::KEYCODE_LAST_CHANNEL),
            230 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_DATA_SERVICE),
            231 => ::std::option::Option::Some(KeyCode::KEYCODE_VOICE_ASSIST),
            232 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_RADIO_SERVICE),
            233 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TELETEXT),
            234 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_NUMBER_ENTRY),
            235 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TERRESTRIAL_ANALOG),
            236 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TERRESTRIAL_DIGITAL),
            237 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE),
            238 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE_BS),
            239 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE_CS),
            240 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE_SERVICE),
            241 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_NETWORK),
            242 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_ANTENNA_CABLE),
            243 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_1),
            244 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_2),
            245 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_3),
            246 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_4),
            247 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPOSITE_1),
            248 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPOSITE_2),
            249 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPONENT_1),
            250 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPONENT_2),
            251 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_VGA_1),
            252 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION),
            253 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP),
            254 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN),
            255 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_ZOOM_MODE),
            256 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_CONTENTS_MENU),
            257 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_MEDIA_CONTEXT_MENU),
            258 => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TIMER_PROGRAMMING),
            259 => ::std::option::Option::Some(KeyCode::KEYCODE_HELP),
            260 => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_PREVIOUS),
            261 => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_NEXT),
            262 => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_IN),
            263 => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_OUT),
            268 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_UP_LEFT),
            269 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_DOWN_LEFT),
            270 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_UP_RIGHT),
            271 => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_DOWN_RIGHT),
            65535 => ::std::option::Option::Some(KeyCode::KEYCODE_SENTINEL),
            65536 => ::std::option::Option::Some(KeyCode::KEYCODE_ROTARY_CONTROLLER),
            65537 => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA),
            65538 => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATION),
            65539 => ::std::option::Option::Some(KeyCode::KEYCODE_RADIO),
            65540 => ::std::option::Option::Some(KeyCode::KEYCODE_TEL),
            65541 => ::std::option::Option::Some(KeyCode::KEYCODE_PRIMARY_BUTTON),
            65542 => ::std::option::Option::Some(KeyCode::KEYCODE_SECONDARY_BUTTON),
            65543 => ::std::option::Option::Some(KeyCode::KEYCODE_TERTIARY_BUTTON),
            65544 => ::std::option::Option::Some(KeyCode::KEYCODE_TURN_CARD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<KeyCode> {
        match str {
            "KEYCODE_UNKNOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_UNKNOWN),
            "KEYCODE_SOFT_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_SOFT_LEFT),
            "KEYCODE_SOFT_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_SOFT_RIGHT),
            "KEYCODE_HOME" => ::std::option::Option::Some(KeyCode::KEYCODE_HOME),
            "KEYCODE_BACK" => ::std::option::Option::Some(KeyCode::KEYCODE_BACK),
            "KEYCODE_CALL" => ::std::option::Option::Some(KeyCode::KEYCODE_CALL),
            "KEYCODE_ENDCALL" => ::std::option::Option::Some(KeyCode::KEYCODE_ENDCALL),
            "KEYCODE_0" => ::std::option::Option::Some(KeyCode::KEYCODE_0),
            "KEYCODE_1" => ::std::option::Option::Some(KeyCode::KEYCODE_1),
            "KEYCODE_2" => ::std::option::Option::Some(KeyCode::KEYCODE_2),
            "KEYCODE_3" => ::std::option::Option::Some(KeyCode::KEYCODE_3),
            "KEYCODE_4" => ::std::option::Option::Some(KeyCode::KEYCODE_4),
            "KEYCODE_5" => ::std::option::Option::Some(KeyCode::KEYCODE_5),
            "KEYCODE_6" => ::std::option::Option::Some(KeyCode::KEYCODE_6),
            "KEYCODE_7" => ::std::option::Option::Some(KeyCode::KEYCODE_7),
            "KEYCODE_8" => ::std::option::Option::Some(KeyCode::KEYCODE_8),
            "KEYCODE_9" => ::std::option::Option::Some(KeyCode::KEYCODE_9),
            "KEYCODE_STAR" => ::std::option::Option::Some(KeyCode::KEYCODE_STAR),
            "KEYCODE_POUND" => ::std::option::Option::Some(KeyCode::KEYCODE_POUND),
            "KEYCODE_DPAD_UP" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_UP),
            "KEYCODE_DPAD_DOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_DOWN),
            "KEYCODE_DPAD_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_LEFT),
            "KEYCODE_DPAD_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_RIGHT),
            "KEYCODE_DPAD_CENTER" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_CENTER),
            "KEYCODE_VOLUME_UP" => ::std::option::Option::Some(KeyCode::KEYCODE_VOLUME_UP),
            "KEYCODE_VOLUME_DOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_VOLUME_DOWN),
            "KEYCODE_POWER" => ::std::option::Option::Some(KeyCode::KEYCODE_POWER),
            "KEYCODE_CAMERA" => ::std::option::Option::Some(KeyCode::KEYCODE_CAMERA),
            "KEYCODE_CLEAR" => ::std::option::Option::Some(KeyCode::KEYCODE_CLEAR),
            "KEYCODE_A" => ::std::option::Option::Some(KeyCode::KEYCODE_A),
            "KEYCODE_B" => ::std::option::Option::Some(KeyCode::KEYCODE_B),
            "KEYCODE_C" => ::std::option::Option::Some(KeyCode::KEYCODE_C),
            "KEYCODE_D" => ::std::option::Option::Some(KeyCode::KEYCODE_D),
            "KEYCODE_E" => ::std::option::Option::Some(KeyCode::KEYCODE_E),
            "KEYCODE_F" => ::std::option::Option::Some(KeyCode::KEYCODE_F),
            "KEYCODE_G" => ::std::option::Option::Some(KeyCode::KEYCODE_G),
            "KEYCODE_H" => ::std::option::Option::Some(KeyCode::KEYCODE_H),
            "KEYCODE_I" => ::std::option::Option::Some(KeyCode::KEYCODE_I),
            "KEYCODE_J" => ::std::option::Option::Some(KeyCode::KEYCODE_J),
            "KEYCODE_K" => ::std::option::Option::Some(KeyCode::KEYCODE_K),
            "KEYCODE_L" => ::std::option::Option::Some(KeyCode::KEYCODE_L),
            "KEYCODE_M" => ::std::option::Option::Some(KeyCode::KEYCODE_M),
            "KEYCODE_N" => ::std::option::Option::Some(KeyCode::KEYCODE_N),
            "KEYCODE_O" => ::std::option::Option::Some(KeyCode::KEYCODE_O),
            "KEYCODE_P" => ::std::option::Option::Some(KeyCode::KEYCODE_P),
            "KEYCODE_Q" => ::std::option::Option::Some(KeyCode::KEYCODE_Q),
            "KEYCODE_R" => ::std::option::Option::Some(KeyCode::KEYCODE_R),
            "KEYCODE_S" => ::std::option::Option::Some(KeyCode::KEYCODE_S),
            "KEYCODE_T" => ::std::option::Option::Some(KeyCode::KEYCODE_T),
            "KEYCODE_U" => ::std::option::Option::Some(KeyCode::KEYCODE_U),
            "KEYCODE_V" => ::std::option::Option::Some(KeyCode::KEYCODE_V),
            "KEYCODE_W" => ::std::option::Option::Some(KeyCode::KEYCODE_W),
            "KEYCODE_X" => ::std::option::Option::Some(KeyCode::KEYCODE_X),
            "KEYCODE_Y" => ::std::option::Option::Some(KeyCode::KEYCODE_Y),
            "KEYCODE_Z" => ::std::option::Option::Some(KeyCode::KEYCODE_Z),
            "KEYCODE_COMMA" => ::std::option::Option::Some(KeyCode::KEYCODE_COMMA),
            "KEYCODE_PERIOD" => ::std::option::Option::Some(KeyCode::KEYCODE_PERIOD),
            "KEYCODE_ALT_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_ALT_LEFT),
            "KEYCODE_ALT_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_ALT_RIGHT),
            "KEYCODE_SHIFT_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_SHIFT_LEFT),
            "KEYCODE_SHIFT_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_SHIFT_RIGHT),
            "KEYCODE_TAB" => ::std::option::Option::Some(KeyCode::KEYCODE_TAB),
            "KEYCODE_SPACE" => ::std::option::Option::Some(KeyCode::KEYCODE_SPACE),
            "KEYCODE_SYM" => ::std::option::Option::Some(KeyCode::KEYCODE_SYM),
            "KEYCODE_EXPLORER" => ::std::option::Option::Some(KeyCode::KEYCODE_EXPLORER),
            "KEYCODE_ENVELOPE" => ::std::option::Option::Some(KeyCode::KEYCODE_ENVELOPE),
            "KEYCODE_ENTER" => ::std::option::Option::Some(KeyCode::KEYCODE_ENTER),
            "KEYCODE_DEL" => ::std::option::Option::Some(KeyCode::KEYCODE_DEL),
            "KEYCODE_GRAVE" => ::std::option::Option::Some(KeyCode::KEYCODE_GRAVE),
            "KEYCODE_MINUS" => ::std::option::Option::Some(KeyCode::KEYCODE_MINUS),
            "KEYCODE_EQUALS" => ::std::option::Option::Some(KeyCode::KEYCODE_EQUALS),
            "KEYCODE_LEFT_BRACKET" => ::std::option::Option::Some(KeyCode::KEYCODE_LEFT_BRACKET),
            "KEYCODE_RIGHT_BRACKET" => ::std::option::Option::Some(KeyCode::KEYCODE_RIGHT_BRACKET),
            "KEYCODE_BACKSLASH" => ::std::option::Option::Some(KeyCode::KEYCODE_BACKSLASH),
            "KEYCODE_SEMICOLON" => ::std::option::Option::Some(KeyCode::KEYCODE_SEMICOLON),
            "KEYCODE_APOSTROPHE" => ::std::option::Option::Some(KeyCode::KEYCODE_APOSTROPHE),
            "KEYCODE_SLASH" => ::std::option::Option::Some(KeyCode::KEYCODE_SLASH),
            "KEYCODE_AT" => ::std::option::Option::Some(KeyCode::KEYCODE_AT),
            "KEYCODE_NUM" => ::std::option::Option::Some(KeyCode::KEYCODE_NUM),
            "KEYCODE_HEADSETHOOK" => ::std::option::Option::Some(KeyCode::KEYCODE_HEADSETHOOK),
            "KEYCODE_FOCUS" => ::std::option::Option::Some(KeyCode::KEYCODE_FOCUS),
            "KEYCODE_PLUS" => ::std::option::Option::Some(KeyCode::KEYCODE_PLUS),
            "KEYCODE_MENU" => ::std::option::Option::Some(KeyCode::KEYCODE_MENU),
            "KEYCODE_NOTIFICATION" => ::std::option::Option::Some(KeyCode::KEYCODE_NOTIFICATION),
            "KEYCODE_SEARCH" => ::std::option::Option::Some(KeyCode::KEYCODE_SEARCH),
            "KEYCODE_MEDIA_PLAY_PAUSE" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PLAY_PAUSE),
            "KEYCODE_MEDIA_STOP" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_STOP),
            "KEYCODE_MEDIA_NEXT" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_NEXT),
            "KEYCODE_MEDIA_PREVIOUS" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PREVIOUS),
            "KEYCODE_MEDIA_REWIND" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_REWIND),
            "KEYCODE_MEDIA_FAST_FORWARD" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_FAST_FORWARD),
            "KEYCODE_MUTE" => ::std::option::Option::Some(KeyCode::KEYCODE_MUTE),
            "KEYCODE_PAGE_UP" => ::std::option::Option::Some(KeyCode::KEYCODE_PAGE_UP),
            "KEYCODE_PAGE_DOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_PAGE_DOWN),
            "KEYCODE_PICTSYMBOLS" => ::std::option::Option::Some(KeyCode::KEYCODE_PICTSYMBOLS),
            "KEYCODE_SWITCH_CHARSET" => ::std::option::Option::Some(KeyCode::KEYCODE_SWITCH_CHARSET),
            "KEYCODE_BUTTON_A" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_A),
            "KEYCODE_BUTTON_B" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_B),
            "KEYCODE_BUTTON_C" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_C),
            "KEYCODE_BUTTON_X" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_X),
            "KEYCODE_BUTTON_Y" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_Y),
            "KEYCODE_BUTTON_Z" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_Z),
            "KEYCODE_BUTTON_L1" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_L1),
            "KEYCODE_BUTTON_R1" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_R1),
            "KEYCODE_BUTTON_L2" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_L2),
            "KEYCODE_BUTTON_R2" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_R2),
            "KEYCODE_BUTTON_THUMBL" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_THUMBL),
            "KEYCODE_BUTTON_THUMBR" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_THUMBR),
            "KEYCODE_BUTTON_START" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_START),
            "KEYCODE_BUTTON_SELECT" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_SELECT),
            "KEYCODE_BUTTON_MODE" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_MODE),
            "KEYCODE_ESCAPE" => ::std::option::Option::Some(KeyCode::KEYCODE_ESCAPE),
            "KEYCODE_FORWARD_DEL" => ::std::option::Option::Some(KeyCode::KEYCODE_FORWARD_DEL),
            "KEYCODE_CTRL_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_CTRL_LEFT),
            "KEYCODE_CTRL_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_CTRL_RIGHT),
            "KEYCODE_CAPS_LOCK" => ::std::option::Option::Some(KeyCode::KEYCODE_CAPS_LOCK),
            "KEYCODE_SCROLL_LOCK" => ::std::option::Option::Some(KeyCode::KEYCODE_SCROLL_LOCK),
            "KEYCODE_META_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_META_LEFT),
            "KEYCODE_META_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_META_RIGHT),
            "KEYCODE_FUNCTION" => ::std::option::Option::Some(KeyCode::KEYCODE_FUNCTION),
            "KEYCODE_SYSRQ" => ::std::option::Option::Some(KeyCode::KEYCODE_SYSRQ),
            "KEYCODE_BREAK" => ::std::option::Option::Some(KeyCode::KEYCODE_BREAK),
            "KEYCODE_MOVE_HOME" => ::std::option::Option::Some(KeyCode::KEYCODE_MOVE_HOME),
            "KEYCODE_MOVE_END" => ::std::option::Option::Some(KeyCode::KEYCODE_MOVE_END),
            "KEYCODE_INSERT" => ::std::option::Option::Some(KeyCode::KEYCODE_INSERT),
            "KEYCODE_FORWARD" => ::std::option::Option::Some(KeyCode::KEYCODE_FORWARD),
            "KEYCODE_MEDIA_PLAY" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PLAY),
            "KEYCODE_MEDIA_PAUSE" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_PAUSE),
            "KEYCODE_MEDIA_CLOSE" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_CLOSE),
            "KEYCODE_MEDIA_EJECT" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_EJECT),
            "KEYCODE_MEDIA_RECORD" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_RECORD),
            "KEYCODE_F1" => ::std::option::Option::Some(KeyCode::KEYCODE_F1),
            "KEYCODE_F2" => ::std::option::Option::Some(KeyCode::KEYCODE_F2),
            "KEYCODE_F3" => ::std::option::Option::Some(KeyCode::KEYCODE_F3),
            "KEYCODE_F4" => ::std::option::Option::Some(KeyCode::KEYCODE_F4),
            "KEYCODE_F5" => ::std::option::Option::Some(KeyCode::KEYCODE_F5),
            "KEYCODE_F6" => ::std::option::Option::Some(KeyCode::KEYCODE_F6),
            "KEYCODE_F7" => ::std::option::Option::Some(KeyCode::KEYCODE_F7),
            "KEYCODE_F8" => ::std::option::Option::Some(KeyCode::KEYCODE_F8),
            "KEYCODE_F9" => ::std::option::Option::Some(KeyCode::KEYCODE_F9),
            "KEYCODE_F10" => ::std::option::Option::Some(KeyCode::KEYCODE_F10),
            "KEYCODE_F11" => ::std::option::Option::Some(KeyCode::KEYCODE_F11),
            "KEYCODE_F12" => ::std::option::Option::Some(KeyCode::KEYCODE_F12),
            "KEYCODE_NUM_LOCK" => ::std::option::Option::Some(KeyCode::KEYCODE_NUM_LOCK),
            "KEYCODE_NUMPAD_0" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_0),
            "KEYCODE_NUMPAD_1" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_1),
            "KEYCODE_NUMPAD_2" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_2),
            "KEYCODE_NUMPAD_3" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_3),
            "KEYCODE_NUMPAD_4" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_4),
            "KEYCODE_NUMPAD_5" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_5),
            "KEYCODE_NUMPAD_6" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_6),
            "KEYCODE_NUMPAD_7" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_7),
            "KEYCODE_NUMPAD_8" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_8),
            "KEYCODE_NUMPAD_9" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_9),
            "KEYCODE_NUMPAD_DIVIDE" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_DIVIDE),
            "KEYCODE_NUMPAD_MULTIPLY" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_MULTIPLY),
            "KEYCODE_NUMPAD_SUBTRACT" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_SUBTRACT),
            "KEYCODE_NUMPAD_ADD" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_ADD),
            "KEYCODE_NUMPAD_DOT" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_DOT),
            "KEYCODE_NUMPAD_COMMA" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_COMMA),
            "KEYCODE_NUMPAD_ENTER" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_ENTER),
            "KEYCODE_NUMPAD_EQUALS" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_EQUALS),
            "KEYCODE_NUMPAD_LEFT_PAREN" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_LEFT_PAREN),
            "KEYCODE_NUMPAD_RIGHT_PAREN" => ::std::option::Option::Some(KeyCode::KEYCODE_NUMPAD_RIGHT_PAREN),
            "KEYCODE_VOLUME_MUTE" => ::std::option::Option::Some(KeyCode::KEYCODE_VOLUME_MUTE),
            "KEYCODE_INFO" => ::std::option::Option::Some(KeyCode::KEYCODE_INFO),
            "KEYCODE_CHANNEL_UP" => ::std::option::Option::Some(KeyCode::KEYCODE_CHANNEL_UP),
            "KEYCODE_CHANNEL_DOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_CHANNEL_DOWN),
            "KEYCODE_ZOOM_IN" => ::std::option::Option::Some(KeyCode::KEYCODE_ZOOM_IN),
            "KEYCODE_ZOOM_OUT" => ::std::option::Option::Some(KeyCode::KEYCODE_ZOOM_OUT),
            "KEYCODE_TV" => ::std::option::Option::Some(KeyCode::KEYCODE_TV),
            "KEYCODE_WINDOW" => ::std::option::Option::Some(KeyCode::KEYCODE_WINDOW),
            "KEYCODE_GUIDE" => ::std::option::Option::Some(KeyCode::KEYCODE_GUIDE),
            "KEYCODE_DVR" => ::std::option::Option::Some(KeyCode::KEYCODE_DVR),
            "KEYCODE_BOOKMARK" => ::std::option::Option::Some(KeyCode::KEYCODE_BOOKMARK),
            "KEYCODE_CAPTIONS" => ::std::option::Option::Some(KeyCode::KEYCODE_CAPTIONS),
            "KEYCODE_SETTINGS" => ::std::option::Option::Some(KeyCode::KEYCODE_SETTINGS),
            "KEYCODE_TV_POWER" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_POWER),
            "KEYCODE_TV_INPUT" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT),
            "KEYCODE_STB_POWER" => ::std::option::Option::Some(KeyCode::KEYCODE_STB_POWER),
            "KEYCODE_STB_INPUT" => ::std::option::Option::Some(KeyCode::KEYCODE_STB_INPUT),
            "KEYCODE_AVR_POWER" => ::std::option::Option::Some(KeyCode::KEYCODE_AVR_POWER),
            "KEYCODE_AVR_INPUT" => ::std::option::Option::Some(KeyCode::KEYCODE_AVR_INPUT),
            "KEYCODE_PROG_RED" => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_RED),
            "KEYCODE_PROG_GREEN" => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_GREEN),
            "KEYCODE_PROG_YELLOW" => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_YELLOW),
            "KEYCODE_PROG_BLUE" => ::std::option::Option::Some(KeyCode::KEYCODE_PROG_BLUE),
            "KEYCODE_APP_SWITCH" => ::std::option::Option::Some(KeyCode::KEYCODE_APP_SWITCH),
            "KEYCODE_BUTTON_1" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_1),
            "KEYCODE_BUTTON_2" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_2),
            "KEYCODE_BUTTON_3" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_3),
            "KEYCODE_BUTTON_4" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_4),
            "KEYCODE_BUTTON_5" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_5),
            "KEYCODE_BUTTON_6" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_6),
            "KEYCODE_BUTTON_7" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_7),
            "KEYCODE_BUTTON_8" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_8),
            "KEYCODE_BUTTON_9" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_9),
            "KEYCODE_BUTTON_10" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_10),
            "KEYCODE_BUTTON_11" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_11),
            "KEYCODE_BUTTON_12" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_12),
            "KEYCODE_BUTTON_13" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_13),
            "KEYCODE_BUTTON_14" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_14),
            "KEYCODE_BUTTON_15" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_15),
            "KEYCODE_BUTTON_16" => ::std::option::Option::Some(KeyCode::KEYCODE_BUTTON_16),
            "KEYCODE_LANGUAGE_SWITCH" => ::std::option::Option::Some(KeyCode::KEYCODE_LANGUAGE_SWITCH),
            "KEYCODE_MANNER_MODE" => ::std::option::Option::Some(KeyCode::KEYCODE_MANNER_MODE),
            "KEYCODE_3D_MODE" => ::std::option::Option::Some(KeyCode::KEYCODE_3D_MODE),
            "KEYCODE_CONTACTS" => ::std::option::Option::Some(KeyCode::KEYCODE_CONTACTS),
            "KEYCODE_CALENDAR" => ::std::option::Option::Some(KeyCode::KEYCODE_CALENDAR),
            "KEYCODE_MUSIC" => ::std::option::Option::Some(KeyCode::KEYCODE_MUSIC),
            "KEYCODE_CALCULATOR" => ::std::option::Option::Some(KeyCode::KEYCODE_CALCULATOR),
            "KEYCODE_ZENKAKU_HANKAKU" => ::std::option::Option::Some(KeyCode::KEYCODE_ZENKAKU_HANKAKU),
            "KEYCODE_EISU" => ::std::option::Option::Some(KeyCode::KEYCODE_EISU),
            "KEYCODE_MUHENKAN" => ::std::option::Option::Some(KeyCode::KEYCODE_MUHENKAN),
            "KEYCODE_HENKAN" => ::std::option::Option::Some(KeyCode::KEYCODE_HENKAN),
            "KEYCODE_KATAKANA_HIRAGANA" => ::std::option::Option::Some(KeyCode::KEYCODE_KATAKANA_HIRAGANA),
            "KEYCODE_YEN" => ::std::option::Option::Some(KeyCode::KEYCODE_YEN),
            "KEYCODE_RO" => ::std::option::Option::Some(KeyCode::KEYCODE_RO),
            "KEYCODE_KANA" => ::std::option::Option::Some(KeyCode::KEYCODE_KANA),
            "KEYCODE_ASSIST" => ::std::option::Option::Some(KeyCode::KEYCODE_ASSIST),
            "KEYCODE_BRIGHTNESS_DOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_BRIGHTNESS_DOWN),
            "KEYCODE_BRIGHTNESS_UP" => ::std::option::Option::Some(KeyCode::KEYCODE_BRIGHTNESS_UP),
            "KEYCODE_MEDIA_AUDIO_TRACK" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_AUDIO_TRACK),
            "KEYCODE_SLEEP" => ::std::option::Option::Some(KeyCode::KEYCODE_SLEEP),
            "KEYCODE_WAKEUP" => ::std::option::Option::Some(KeyCode::KEYCODE_WAKEUP),
            "KEYCODE_PAIRING" => ::std::option::Option::Some(KeyCode::KEYCODE_PAIRING),
            "KEYCODE_MEDIA_TOP_MENU" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA_TOP_MENU),
            "KEYCODE_11" => ::std::option::Option::Some(KeyCode::KEYCODE_11),
            "KEYCODE_12" => ::std::option::Option::Some(KeyCode::KEYCODE_12),
            "KEYCODE_LAST_CHANNEL" => ::std::option::Option::Some(KeyCode::KEYCODE_LAST_CHANNEL),
            "KEYCODE_TV_DATA_SERVICE" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_DATA_SERVICE),
            "KEYCODE_VOICE_ASSIST" => ::std::option::Option::Some(KeyCode::KEYCODE_VOICE_ASSIST),
            "KEYCODE_TV_RADIO_SERVICE" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_RADIO_SERVICE),
            "KEYCODE_TV_TELETEXT" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TELETEXT),
            "KEYCODE_TV_NUMBER_ENTRY" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_NUMBER_ENTRY),
            "KEYCODE_TV_TERRESTRIAL_ANALOG" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TERRESTRIAL_ANALOG),
            "KEYCODE_TV_TERRESTRIAL_DIGITAL" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TERRESTRIAL_DIGITAL),
            "KEYCODE_TV_SATELLITE" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE),
            "KEYCODE_TV_SATELLITE_BS" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE_BS),
            "KEYCODE_TV_SATELLITE_CS" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE_CS),
            "KEYCODE_TV_SATELLITE_SERVICE" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_SATELLITE_SERVICE),
            "KEYCODE_TV_NETWORK" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_NETWORK),
            "KEYCODE_TV_ANTENNA_CABLE" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_ANTENNA_CABLE),
            "KEYCODE_TV_INPUT_HDMI_1" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_1),
            "KEYCODE_TV_INPUT_HDMI_2" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_2),
            "KEYCODE_TV_INPUT_HDMI_3" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_3),
            "KEYCODE_TV_INPUT_HDMI_4" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_HDMI_4),
            "KEYCODE_TV_INPUT_COMPOSITE_1" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPOSITE_1),
            "KEYCODE_TV_INPUT_COMPOSITE_2" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPOSITE_2),
            "KEYCODE_TV_INPUT_COMPONENT_1" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPONENT_1),
            "KEYCODE_TV_INPUT_COMPONENT_2" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_COMPONENT_2),
            "KEYCODE_TV_INPUT_VGA_1" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_INPUT_VGA_1),
            "KEYCODE_TV_AUDIO_DESCRIPTION" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION),
            "KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP),
            "KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN),
            "KEYCODE_TV_ZOOM_MODE" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_ZOOM_MODE),
            "KEYCODE_TV_CONTENTS_MENU" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_CONTENTS_MENU),
            "KEYCODE_TV_MEDIA_CONTEXT_MENU" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_MEDIA_CONTEXT_MENU),
            "KEYCODE_TV_TIMER_PROGRAMMING" => ::std::option::Option::Some(KeyCode::KEYCODE_TV_TIMER_PROGRAMMING),
            "KEYCODE_HELP" => ::std::option::Option::Some(KeyCode::KEYCODE_HELP),
            "KEYCODE_NAVIGATE_PREVIOUS" => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_PREVIOUS),
            "KEYCODE_NAVIGATE_NEXT" => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_NEXT),
            "KEYCODE_NAVIGATE_IN" => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_IN),
            "KEYCODE_NAVIGATE_OUT" => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATE_OUT),
            "KEYCODE_DPAD_UP_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_UP_LEFT),
            "KEYCODE_DPAD_DOWN_LEFT" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_DOWN_LEFT),
            "KEYCODE_DPAD_UP_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_UP_RIGHT),
            "KEYCODE_DPAD_DOWN_RIGHT" => ::std::option::Option::Some(KeyCode::KEYCODE_DPAD_DOWN_RIGHT),
            "KEYCODE_SENTINEL" => ::std::option::Option::Some(KeyCode::KEYCODE_SENTINEL),
            "KEYCODE_ROTARY_CONTROLLER" => ::std::option::Option::Some(KeyCode::KEYCODE_ROTARY_CONTROLLER),
            "KEYCODE_MEDIA" => ::std::option::Option::Some(KeyCode::KEYCODE_MEDIA),
            "KEYCODE_NAVIGATION" => ::std::option::Option::Some(KeyCode::KEYCODE_NAVIGATION),
            "KEYCODE_RADIO" => ::std::option::Option::Some(KeyCode::KEYCODE_RADIO),
            "KEYCODE_TEL" => ::std::option::Option::Some(KeyCode::KEYCODE_TEL),
            "KEYCODE_PRIMARY_BUTTON" => ::std::option::Option::Some(KeyCode::KEYCODE_PRIMARY_BUTTON),
            "KEYCODE_SECONDARY_BUTTON" => ::std::option::Option::Some(KeyCode::KEYCODE_SECONDARY_BUTTON),
            "KEYCODE_TERTIARY_BUTTON" => ::std::option::Option::Some(KeyCode::KEYCODE_TERTIARY_BUTTON),
            "KEYCODE_TURN_CARD" => ::std::option::Option::Some(KeyCode::KEYCODE_TURN_CARD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyCode] = &[
        KeyCode::KEYCODE_UNKNOWN,
        KeyCode::KEYCODE_SOFT_LEFT,
        KeyCode::KEYCODE_SOFT_RIGHT,
        KeyCode::KEYCODE_HOME,
        KeyCode::KEYCODE_BACK,
        KeyCode::KEYCODE_CALL,
        KeyCode::KEYCODE_ENDCALL,
        KeyCode::KEYCODE_0,
        KeyCode::KEYCODE_1,
        KeyCode::KEYCODE_2,
        KeyCode::KEYCODE_3,
        KeyCode::KEYCODE_4,
        KeyCode::KEYCODE_5,
        KeyCode::KEYCODE_6,
        KeyCode::KEYCODE_7,
        KeyCode::KEYCODE_8,
        KeyCode::KEYCODE_9,
        KeyCode::KEYCODE_STAR,
        KeyCode::KEYCODE_POUND,
        KeyCode::KEYCODE_DPAD_UP,
        KeyCode::KEYCODE_DPAD_DOWN,
        KeyCode::KEYCODE_DPAD_LEFT,
        KeyCode::KEYCODE_DPAD_RIGHT,
        KeyCode::KEYCODE_DPAD_CENTER,
        KeyCode::KEYCODE_VOLUME_UP,
        KeyCode::KEYCODE_VOLUME_DOWN,
        KeyCode::KEYCODE_POWER,
        KeyCode::KEYCODE_CAMERA,
        KeyCode::KEYCODE_CLEAR,
        KeyCode::KEYCODE_A,
        KeyCode::KEYCODE_B,
        KeyCode::KEYCODE_C,
        KeyCode::KEYCODE_D,
        KeyCode::KEYCODE_E,
        KeyCode::KEYCODE_F,
        KeyCode::KEYCODE_G,
        KeyCode::KEYCODE_H,
        KeyCode::KEYCODE_I,
        KeyCode::KEYCODE_J,
        KeyCode::KEYCODE_K,
        KeyCode::KEYCODE_L,
        KeyCode::KEYCODE_M,
        KeyCode::KEYCODE_N,
        KeyCode::KEYCODE_O,
        KeyCode::KEYCODE_P,
        KeyCode::KEYCODE_Q,
        KeyCode::KEYCODE_R,
        KeyCode::KEYCODE_S,
        KeyCode::KEYCODE_T,
        KeyCode::KEYCODE_U,
        KeyCode::KEYCODE_V,
        KeyCode::KEYCODE_W,
        KeyCode::KEYCODE_X,
        KeyCode::KEYCODE_Y,
        KeyCode::KEYCODE_Z,
        KeyCode::KEYCODE_COMMA,
        KeyCode::KEYCODE_PERIOD,
        KeyCode::KEYCODE_ALT_LEFT,
        KeyCode::KEYCODE_ALT_RIGHT,
        KeyCode::KEYCODE_SHIFT_LEFT,
        KeyCode::KEYCODE_SHIFT_RIGHT,
        KeyCode::KEYCODE_TAB,
        KeyCode::KEYCODE_SPACE,
        KeyCode::KEYCODE_SYM,
        KeyCode::KEYCODE_EXPLORER,
        KeyCode::KEYCODE_ENVELOPE,
        KeyCode::KEYCODE_ENTER,
        KeyCode::KEYCODE_DEL,
        KeyCode::KEYCODE_GRAVE,
        KeyCode::KEYCODE_MINUS,
        KeyCode::KEYCODE_EQUALS,
        KeyCode::KEYCODE_LEFT_BRACKET,
        KeyCode::KEYCODE_RIGHT_BRACKET,
        KeyCode::KEYCODE_BACKSLASH,
        KeyCode::KEYCODE_SEMICOLON,
        KeyCode::KEYCODE_APOSTROPHE,
        KeyCode::KEYCODE_SLASH,
        KeyCode::KEYCODE_AT,
        KeyCode::KEYCODE_NUM,
        KeyCode::KEYCODE_HEADSETHOOK,
        KeyCode::KEYCODE_FOCUS,
        KeyCode::KEYCODE_PLUS,
        KeyCode::KEYCODE_MENU,
        KeyCode::KEYCODE_NOTIFICATION,
        KeyCode::KEYCODE_SEARCH,
        KeyCode::KEYCODE_MEDIA_PLAY_PAUSE,
        KeyCode::KEYCODE_MEDIA_STOP,
        KeyCode::KEYCODE_MEDIA_NEXT,
        KeyCode::KEYCODE_MEDIA_PREVIOUS,
        KeyCode::KEYCODE_MEDIA_REWIND,
        KeyCode::KEYCODE_MEDIA_FAST_FORWARD,
        KeyCode::KEYCODE_MUTE,
        KeyCode::KEYCODE_PAGE_UP,
        KeyCode::KEYCODE_PAGE_DOWN,
        KeyCode::KEYCODE_PICTSYMBOLS,
        KeyCode::KEYCODE_SWITCH_CHARSET,
        KeyCode::KEYCODE_BUTTON_A,
        KeyCode::KEYCODE_BUTTON_B,
        KeyCode::KEYCODE_BUTTON_C,
        KeyCode::KEYCODE_BUTTON_X,
        KeyCode::KEYCODE_BUTTON_Y,
        KeyCode::KEYCODE_BUTTON_Z,
        KeyCode::KEYCODE_BUTTON_L1,
        KeyCode::KEYCODE_BUTTON_R1,
        KeyCode::KEYCODE_BUTTON_L2,
        KeyCode::KEYCODE_BUTTON_R2,
        KeyCode::KEYCODE_BUTTON_THUMBL,
        KeyCode::KEYCODE_BUTTON_THUMBR,
        KeyCode::KEYCODE_BUTTON_START,
        KeyCode::KEYCODE_BUTTON_SELECT,
        KeyCode::KEYCODE_BUTTON_MODE,
        KeyCode::KEYCODE_ESCAPE,
        KeyCode::KEYCODE_FORWARD_DEL,
        KeyCode::KEYCODE_CTRL_LEFT,
        KeyCode::KEYCODE_CTRL_RIGHT,
        KeyCode::KEYCODE_CAPS_LOCK,
        KeyCode::KEYCODE_SCROLL_LOCK,
        KeyCode::KEYCODE_META_LEFT,
        KeyCode::KEYCODE_META_RIGHT,
        KeyCode::KEYCODE_FUNCTION,
        KeyCode::KEYCODE_SYSRQ,
        KeyCode::KEYCODE_BREAK,
        KeyCode::KEYCODE_MOVE_HOME,
        KeyCode::KEYCODE_MOVE_END,
        KeyCode::KEYCODE_INSERT,
        KeyCode::KEYCODE_FORWARD,
        KeyCode::KEYCODE_MEDIA_PLAY,
        KeyCode::KEYCODE_MEDIA_PAUSE,
        KeyCode::KEYCODE_MEDIA_CLOSE,
        KeyCode::KEYCODE_MEDIA_EJECT,
        KeyCode::KEYCODE_MEDIA_RECORD,
        KeyCode::KEYCODE_F1,
        KeyCode::KEYCODE_F2,
        KeyCode::KEYCODE_F3,
        KeyCode::KEYCODE_F4,
        KeyCode::KEYCODE_F5,
        KeyCode::KEYCODE_F6,
        KeyCode::KEYCODE_F7,
        KeyCode::KEYCODE_F8,
        KeyCode::KEYCODE_F9,
        KeyCode::KEYCODE_F10,
        KeyCode::KEYCODE_F11,
        KeyCode::KEYCODE_F12,
        KeyCode::KEYCODE_NUM_LOCK,
        KeyCode::KEYCODE_NUMPAD_0,
        KeyCode::KEYCODE_NUMPAD_1,
        KeyCode::KEYCODE_NUMPAD_2,
        KeyCode::KEYCODE_NUMPAD_3,
        KeyCode::KEYCODE_NUMPAD_4,
        KeyCode::KEYCODE_NUMPAD_5,
        KeyCode::KEYCODE_NUMPAD_6,
        KeyCode::KEYCODE_NUMPAD_7,
        KeyCode::KEYCODE_NUMPAD_8,
        KeyCode::KEYCODE_NUMPAD_9,
        KeyCode::KEYCODE_NUMPAD_DIVIDE,
        KeyCode::KEYCODE_NUMPAD_MULTIPLY,
        KeyCode::KEYCODE_NUMPAD_SUBTRACT,
        KeyCode::KEYCODE_NUMPAD_ADD,
        KeyCode::KEYCODE_NUMPAD_DOT,
        KeyCode::KEYCODE_NUMPAD_COMMA,
        KeyCode::KEYCODE_NUMPAD_ENTER,
        KeyCode::KEYCODE_NUMPAD_EQUALS,
        KeyCode::KEYCODE_NUMPAD_LEFT_PAREN,
        KeyCode::KEYCODE_NUMPAD_RIGHT_PAREN,
        KeyCode::KEYCODE_VOLUME_MUTE,
        KeyCode::KEYCODE_INFO,
        KeyCode::KEYCODE_CHANNEL_UP,
        KeyCode::KEYCODE_CHANNEL_DOWN,
        KeyCode::KEYCODE_ZOOM_IN,
        KeyCode::KEYCODE_ZOOM_OUT,
        KeyCode::KEYCODE_TV,
        KeyCode::KEYCODE_WINDOW,
        KeyCode::KEYCODE_GUIDE,
        KeyCode::KEYCODE_DVR,
        KeyCode::KEYCODE_BOOKMARK,
        KeyCode::KEYCODE_CAPTIONS,
        KeyCode::KEYCODE_SETTINGS,
        KeyCode::KEYCODE_TV_POWER,
        KeyCode::KEYCODE_TV_INPUT,
        KeyCode::KEYCODE_STB_POWER,
        KeyCode::KEYCODE_STB_INPUT,
        KeyCode::KEYCODE_AVR_POWER,
        KeyCode::KEYCODE_AVR_INPUT,
        KeyCode::KEYCODE_PROG_RED,
        KeyCode::KEYCODE_PROG_GREEN,
        KeyCode::KEYCODE_PROG_YELLOW,
        KeyCode::KEYCODE_PROG_BLUE,
        KeyCode::KEYCODE_APP_SWITCH,
        KeyCode::KEYCODE_BUTTON_1,
        KeyCode::KEYCODE_BUTTON_2,
        KeyCode::KEYCODE_BUTTON_3,
        KeyCode::KEYCODE_BUTTON_4,
        KeyCode::KEYCODE_BUTTON_5,
        KeyCode::KEYCODE_BUTTON_6,
        KeyCode::KEYCODE_BUTTON_7,
        KeyCode::KEYCODE_BUTTON_8,
        KeyCode::KEYCODE_BUTTON_9,
        KeyCode::KEYCODE_BUTTON_10,
        KeyCode::KEYCODE_BUTTON_11,
        KeyCode::KEYCODE_BUTTON_12,
        KeyCode::KEYCODE_BUTTON_13,
        KeyCode::KEYCODE_BUTTON_14,
        KeyCode::KEYCODE_BUTTON_15,
        KeyCode::KEYCODE_BUTTON_16,
        KeyCode::KEYCODE_LANGUAGE_SWITCH,
        KeyCode::KEYCODE_MANNER_MODE,
        KeyCode::KEYCODE_3D_MODE,
        KeyCode::KEYCODE_CONTACTS,
        KeyCode::KEYCODE_CALENDAR,
        KeyCode::KEYCODE_MUSIC,
        KeyCode::KEYCODE_CALCULATOR,
        KeyCode::KEYCODE_ZENKAKU_HANKAKU,
        KeyCode::KEYCODE_EISU,
        KeyCode::KEYCODE_MUHENKAN,
        KeyCode::KEYCODE_HENKAN,
        KeyCode::KEYCODE_KATAKANA_HIRAGANA,
        KeyCode::KEYCODE_YEN,
        KeyCode::KEYCODE_RO,
        KeyCode::KEYCODE_KANA,
        KeyCode::KEYCODE_ASSIST,
        KeyCode::KEYCODE_BRIGHTNESS_DOWN,
        KeyCode::KEYCODE_BRIGHTNESS_UP,
        KeyCode::KEYCODE_MEDIA_AUDIO_TRACK,
        KeyCode::KEYCODE_SLEEP,
        KeyCode::KEYCODE_WAKEUP,
        KeyCode::KEYCODE_PAIRING,
        KeyCode::KEYCODE_MEDIA_TOP_MENU,
        KeyCode::KEYCODE_11,
        KeyCode::KEYCODE_12,
        KeyCode::KEYCODE_LAST_CHANNEL,
        KeyCode::KEYCODE_TV_DATA_SERVICE,
        KeyCode::KEYCODE_VOICE_ASSIST,
        KeyCode::KEYCODE_TV_RADIO_SERVICE,
        KeyCode::KEYCODE_TV_TELETEXT,
        KeyCode::KEYCODE_TV_NUMBER_ENTRY,
        KeyCode::KEYCODE_TV_TERRESTRIAL_ANALOG,
        KeyCode::KEYCODE_TV_TERRESTRIAL_DIGITAL,
        KeyCode::KEYCODE_TV_SATELLITE,
        KeyCode::KEYCODE_TV_SATELLITE_BS,
        KeyCode::KEYCODE_TV_SATELLITE_CS,
        KeyCode::KEYCODE_TV_SATELLITE_SERVICE,
        KeyCode::KEYCODE_TV_NETWORK,
        KeyCode::KEYCODE_TV_ANTENNA_CABLE,
        KeyCode::KEYCODE_TV_INPUT_HDMI_1,
        KeyCode::KEYCODE_TV_INPUT_HDMI_2,
        KeyCode::KEYCODE_TV_INPUT_HDMI_3,
        KeyCode::KEYCODE_TV_INPUT_HDMI_4,
        KeyCode::KEYCODE_TV_INPUT_COMPOSITE_1,
        KeyCode::KEYCODE_TV_INPUT_COMPOSITE_2,
        KeyCode::KEYCODE_TV_INPUT_COMPONENT_1,
        KeyCode::KEYCODE_TV_INPUT_COMPONENT_2,
        KeyCode::KEYCODE_TV_INPUT_VGA_1,
        KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION,
        KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP,
        KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN,
        KeyCode::KEYCODE_TV_ZOOM_MODE,
        KeyCode::KEYCODE_TV_CONTENTS_MENU,
        KeyCode::KEYCODE_TV_MEDIA_CONTEXT_MENU,
        KeyCode::KEYCODE_TV_TIMER_PROGRAMMING,
        KeyCode::KEYCODE_HELP,
        KeyCode::KEYCODE_NAVIGATE_PREVIOUS,
        KeyCode::KEYCODE_NAVIGATE_NEXT,
        KeyCode::KEYCODE_NAVIGATE_IN,
        KeyCode::KEYCODE_NAVIGATE_OUT,
        KeyCode::KEYCODE_DPAD_UP_LEFT,
        KeyCode::KEYCODE_DPAD_DOWN_LEFT,
        KeyCode::KEYCODE_DPAD_UP_RIGHT,
        KeyCode::KEYCODE_DPAD_DOWN_RIGHT,
        KeyCode::KEYCODE_SENTINEL,
        KeyCode::KEYCODE_ROTARY_CONTROLLER,
        KeyCode::KEYCODE_MEDIA,
        KeyCode::KEYCODE_NAVIGATION,
        KeyCode::KEYCODE_RADIO,
        KeyCode::KEYCODE_TEL,
        KeyCode::KEYCODE_PRIMARY_BUTTON,
        KeyCode::KEYCODE_SECONDARY_BUTTON,
        KeyCode::KEYCODE_TERTIARY_BUTTON,
        KeyCode::KEYCODE_TURN_CARD,
    ];
}

impl ::protobuf::EnumFull for KeyCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            KeyCode::KEYCODE_UNKNOWN => 0,
            KeyCode::KEYCODE_SOFT_LEFT => 1,
            KeyCode::KEYCODE_SOFT_RIGHT => 2,
            KeyCode::KEYCODE_HOME => 3,
            KeyCode::KEYCODE_BACK => 4,
            KeyCode::KEYCODE_CALL => 5,
            KeyCode::KEYCODE_ENDCALL => 6,
            KeyCode::KEYCODE_0 => 7,
            KeyCode::KEYCODE_1 => 8,
            KeyCode::KEYCODE_2 => 9,
            KeyCode::KEYCODE_3 => 10,
            KeyCode::KEYCODE_4 => 11,
            KeyCode::KEYCODE_5 => 12,
            KeyCode::KEYCODE_6 => 13,
            KeyCode::KEYCODE_7 => 14,
            KeyCode::KEYCODE_8 => 15,
            KeyCode::KEYCODE_9 => 16,
            KeyCode::KEYCODE_STAR => 17,
            KeyCode::KEYCODE_POUND => 18,
            KeyCode::KEYCODE_DPAD_UP => 19,
            KeyCode::KEYCODE_DPAD_DOWN => 20,
            KeyCode::KEYCODE_DPAD_LEFT => 21,
            KeyCode::KEYCODE_DPAD_RIGHT => 22,
            KeyCode::KEYCODE_DPAD_CENTER => 23,
            KeyCode::KEYCODE_VOLUME_UP => 24,
            KeyCode::KEYCODE_VOLUME_DOWN => 25,
            KeyCode::KEYCODE_POWER => 26,
            KeyCode::KEYCODE_CAMERA => 27,
            KeyCode::KEYCODE_CLEAR => 28,
            KeyCode::KEYCODE_A => 29,
            KeyCode::KEYCODE_B => 30,
            KeyCode::KEYCODE_C => 31,
            KeyCode::KEYCODE_D => 32,
            KeyCode::KEYCODE_E => 33,
            KeyCode::KEYCODE_F => 34,
            KeyCode::KEYCODE_G => 35,
            KeyCode::KEYCODE_H => 36,
            KeyCode::KEYCODE_I => 37,
            KeyCode::KEYCODE_J => 38,
            KeyCode::KEYCODE_K => 39,
            KeyCode::KEYCODE_L => 40,
            KeyCode::KEYCODE_M => 41,
            KeyCode::KEYCODE_N => 42,
            KeyCode::KEYCODE_O => 43,
            KeyCode::KEYCODE_P => 44,
            KeyCode::KEYCODE_Q => 45,
            KeyCode::KEYCODE_R => 46,
            KeyCode::KEYCODE_S => 47,
            KeyCode::KEYCODE_T => 48,
            KeyCode::KEYCODE_U => 49,
            KeyCode::KEYCODE_V => 50,
            KeyCode::KEYCODE_W => 51,
            KeyCode::KEYCODE_X => 52,
            KeyCode::KEYCODE_Y => 53,
            KeyCode::KEYCODE_Z => 54,
            KeyCode::KEYCODE_COMMA => 55,
            KeyCode::KEYCODE_PERIOD => 56,
            KeyCode::KEYCODE_ALT_LEFT => 57,
            KeyCode::KEYCODE_ALT_RIGHT => 58,
            KeyCode::KEYCODE_SHIFT_LEFT => 59,
            KeyCode::KEYCODE_SHIFT_RIGHT => 60,
            KeyCode::KEYCODE_TAB => 61,
            KeyCode::KEYCODE_SPACE => 62,
            KeyCode::KEYCODE_SYM => 63,
            KeyCode::KEYCODE_EXPLORER => 64,
            KeyCode::KEYCODE_ENVELOPE => 65,
            KeyCode::KEYCODE_ENTER => 66,
            KeyCode::KEYCODE_DEL => 67,
            KeyCode::KEYCODE_GRAVE => 68,
            KeyCode::KEYCODE_MINUS => 69,
            KeyCode::KEYCODE_EQUALS => 70,
            KeyCode::KEYCODE_LEFT_BRACKET => 71,
            KeyCode::KEYCODE_RIGHT_BRACKET => 72,
            KeyCode::KEYCODE_BACKSLASH => 73,
            KeyCode::KEYCODE_SEMICOLON => 74,
            KeyCode::KEYCODE_APOSTROPHE => 75,
            KeyCode::KEYCODE_SLASH => 76,
            KeyCode::KEYCODE_AT => 77,
            KeyCode::KEYCODE_NUM => 78,
            KeyCode::KEYCODE_HEADSETHOOK => 79,
            KeyCode::KEYCODE_FOCUS => 80,
            KeyCode::KEYCODE_PLUS => 81,
            KeyCode::KEYCODE_MENU => 82,
            KeyCode::KEYCODE_NOTIFICATION => 83,
            KeyCode::KEYCODE_SEARCH => 84,
            KeyCode::KEYCODE_MEDIA_PLAY_PAUSE => 85,
            KeyCode::KEYCODE_MEDIA_STOP => 86,
            KeyCode::KEYCODE_MEDIA_NEXT => 87,
            KeyCode::KEYCODE_MEDIA_PREVIOUS => 88,
            KeyCode::KEYCODE_MEDIA_REWIND => 89,
            KeyCode::KEYCODE_MEDIA_FAST_FORWARD => 90,
            KeyCode::KEYCODE_MUTE => 91,
            KeyCode::KEYCODE_PAGE_UP => 92,
            KeyCode::KEYCODE_PAGE_DOWN => 93,
            KeyCode::KEYCODE_PICTSYMBOLS => 94,
            KeyCode::KEYCODE_SWITCH_CHARSET => 95,
            KeyCode::KEYCODE_BUTTON_A => 96,
            KeyCode::KEYCODE_BUTTON_B => 97,
            KeyCode::KEYCODE_BUTTON_C => 98,
            KeyCode::KEYCODE_BUTTON_X => 99,
            KeyCode::KEYCODE_BUTTON_Y => 100,
            KeyCode::KEYCODE_BUTTON_Z => 101,
            KeyCode::KEYCODE_BUTTON_L1 => 102,
            KeyCode::KEYCODE_BUTTON_R1 => 103,
            KeyCode::KEYCODE_BUTTON_L2 => 104,
            KeyCode::KEYCODE_BUTTON_R2 => 105,
            KeyCode::KEYCODE_BUTTON_THUMBL => 106,
            KeyCode::KEYCODE_BUTTON_THUMBR => 107,
            KeyCode::KEYCODE_BUTTON_START => 108,
            KeyCode::KEYCODE_BUTTON_SELECT => 109,
            KeyCode::KEYCODE_BUTTON_MODE => 110,
            KeyCode::KEYCODE_ESCAPE => 111,
            KeyCode::KEYCODE_FORWARD_DEL => 112,
            KeyCode::KEYCODE_CTRL_LEFT => 113,
            KeyCode::KEYCODE_CTRL_RIGHT => 114,
            KeyCode::KEYCODE_CAPS_LOCK => 115,
            KeyCode::KEYCODE_SCROLL_LOCK => 116,
            KeyCode::KEYCODE_META_LEFT => 117,
            KeyCode::KEYCODE_META_RIGHT => 118,
            KeyCode::KEYCODE_FUNCTION => 119,
            KeyCode::KEYCODE_SYSRQ => 120,
            KeyCode::KEYCODE_BREAK => 121,
            KeyCode::KEYCODE_MOVE_HOME => 122,
            KeyCode::KEYCODE_MOVE_END => 123,
            KeyCode::KEYCODE_INSERT => 124,
            KeyCode::KEYCODE_FORWARD => 125,
            KeyCode::KEYCODE_MEDIA_PLAY => 126,
            KeyCode::KEYCODE_MEDIA_PAUSE => 127,
            KeyCode::KEYCODE_MEDIA_CLOSE => 128,
            KeyCode::KEYCODE_MEDIA_EJECT => 129,
            KeyCode::KEYCODE_MEDIA_RECORD => 130,
            KeyCode::KEYCODE_F1 => 131,
            KeyCode::KEYCODE_F2 => 132,
            KeyCode::KEYCODE_F3 => 133,
            KeyCode::KEYCODE_F4 => 134,
            KeyCode::KEYCODE_F5 => 135,
            KeyCode::KEYCODE_F6 => 136,
            KeyCode::KEYCODE_F7 => 137,
            KeyCode::KEYCODE_F8 => 138,
            KeyCode::KEYCODE_F9 => 139,
            KeyCode::KEYCODE_F10 => 140,
            KeyCode::KEYCODE_F11 => 141,
            KeyCode::KEYCODE_F12 => 142,
            KeyCode::KEYCODE_NUM_LOCK => 143,
            KeyCode::KEYCODE_NUMPAD_0 => 144,
            KeyCode::KEYCODE_NUMPAD_1 => 145,
            KeyCode::KEYCODE_NUMPAD_2 => 146,
            KeyCode::KEYCODE_NUMPAD_3 => 147,
            KeyCode::KEYCODE_NUMPAD_4 => 148,
            KeyCode::KEYCODE_NUMPAD_5 => 149,
            KeyCode::KEYCODE_NUMPAD_6 => 150,
            KeyCode::KEYCODE_NUMPAD_7 => 151,
            KeyCode::KEYCODE_NUMPAD_8 => 152,
            KeyCode::KEYCODE_NUMPAD_9 => 153,
            KeyCode::KEYCODE_NUMPAD_DIVIDE => 154,
            KeyCode::KEYCODE_NUMPAD_MULTIPLY => 155,
            KeyCode::KEYCODE_NUMPAD_SUBTRACT => 156,
            KeyCode::KEYCODE_NUMPAD_ADD => 157,
            KeyCode::KEYCODE_NUMPAD_DOT => 158,
            KeyCode::KEYCODE_NUMPAD_COMMA => 159,
            KeyCode::KEYCODE_NUMPAD_ENTER => 160,
            KeyCode::KEYCODE_NUMPAD_EQUALS => 161,
            KeyCode::KEYCODE_NUMPAD_LEFT_PAREN => 162,
            KeyCode::KEYCODE_NUMPAD_RIGHT_PAREN => 163,
            KeyCode::KEYCODE_VOLUME_MUTE => 164,
            KeyCode::KEYCODE_INFO => 165,
            KeyCode::KEYCODE_CHANNEL_UP => 166,
            KeyCode::KEYCODE_CHANNEL_DOWN => 167,
            KeyCode::KEYCODE_ZOOM_IN => 168,
            KeyCode::KEYCODE_ZOOM_OUT => 169,
            KeyCode::KEYCODE_TV => 170,
            KeyCode::KEYCODE_WINDOW => 171,
            KeyCode::KEYCODE_GUIDE => 172,
            KeyCode::KEYCODE_DVR => 173,
            KeyCode::KEYCODE_BOOKMARK => 174,
            KeyCode::KEYCODE_CAPTIONS => 175,
            KeyCode::KEYCODE_SETTINGS => 176,
            KeyCode::KEYCODE_TV_POWER => 177,
            KeyCode::KEYCODE_TV_INPUT => 178,
            KeyCode::KEYCODE_STB_POWER => 179,
            KeyCode::KEYCODE_STB_INPUT => 180,
            KeyCode::KEYCODE_AVR_POWER => 181,
            KeyCode::KEYCODE_AVR_INPUT => 182,
            KeyCode::KEYCODE_PROG_RED => 183,
            KeyCode::KEYCODE_PROG_GREEN => 184,
            KeyCode::KEYCODE_PROG_YELLOW => 185,
            KeyCode::KEYCODE_PROG_BLUE => 186,
            KeyCode::KEYCODE_APP_SWITCH => 187,
            KeyCode::KEYCODE_BUTTON_1 => 188,
            KeyCode::KEYCODE_BUTTON_2 => 189,
            KeyCode::KEYCODE_BUTTON_3 => 190,
            KeyCode::KEYCODE_BUTTON_4 => 191,
            KeyCode::KEYCODE_BUTTON_5 => 192,
            KeyCode::KEYCODE_BUTTON_6 => 193,
            KeyCode::KEYCODE_BUTTON_7 => 194,
            KeyCode::KEYCODE_BUTTON_8 => 195,
            KeyCode::KEYCODE_BUTTON_9 => 196,
            KeyCode::KEYCODE_BUTTON_10 => 197,
            KeyCode::KEYCODE_BUTTON_11 => 198,
            KeyCode::KEYCODE_BUTTON_12 => 199,
            KeyCode::KEYCODE_BUTTON_13 => 200,
            KeyCode::KEYCODE_BUTTON_14 => 201,
            KeyCode::KEYCODE_BUTTON_15 => 202,
            KeyCode::KEYCODE_BUTTON_16 => 203,
            KeyCode::KEYCODE_LANGUAGE_SWITCH => 204,
            KeyCode::KEYCODE_MANNER_MODE => 205,
            KeyCode::KEYCODE_3D_MODE => 206,
            KeyCode::KEYCODE_CONTACTS => 207,
            KeyCode::KEYCODE_CALENDAR => 208,
            KeyCode::KEYCODE_MUSIC => 209,
            KeyCode::KEYCODE_CALCULATOR => 210,
            KeyCode::KEYCODE_ZENKAKU_HANKAKU => 211,
            KeyCode::KEYCODE_EISU => 212,
            KeyCode::KEYCODE_MUHENKAN => 213,
            KeyCode::KEYCODE_HENKAN => 214,
            KeyCode::KEYCODE_KATAKANA_HIRAGANA => 215,
            KeyCode::KEYCODE_YEN => 216,
            KeyCode::KEYCODE_RO => 217,
            KeyCode::KEYCODE_KANA => 218,
            KeyCode::KEYCODE_ASSIST => 219,
            KeyCode::KEYCODE_BRIGHTNESS_DOWN => 220,
            KeyCode::KEYCODE_BRIGHTNESS_UP => 221,
            KeyCode::KEYCODE_MEDIA_AUDIO_TRACK => 222,
            KeyCode::KEYCODE_SLEEP => 223,
            KeyCode::KEYCODE_WAKEUP => 224,
            KeyCode::KEYCODE_PAIRING => 225,
            KeyCode::KEYCODE_MEDIA_TOP_MENU => 226,
            KeyCode::KEYCODE_11 => 227,
            KeyCode::KEYCODE_12 => 228,
            KeyCode::KEYCODE_LAST_CHANNEL => 229,
            KeyCode::KEYCODE_TV_DATA_SERVICE => 230,
            KeyCode::KEYCODE_VOICE_ASSIST => 231,
            KeyCode::KEYCODE_TV_RADIO_SERVICE => 232,
            KeyCode::KEYCODE_TV_TELETEXT => 233,
            KeyCode::KEYCODE_TV_NUMBER_ENTRY => 234,
            KeyCode::KEYCODE_TV_TERRESTRIAL_ANALOG => 235,
            KeyCode::KEYCODE_TV_TERRESTRIAL_DIGITAL => 236,
            KeyCode::KEYCODE_TV_SATELLITE => 237,
            KeyCode::KEYCODE_TV_SATELLITE_BS => 238,
            KeyCode::KEYCODE_TV_SATELLITE_CS => 239,
            KeyCode::KEYCODE_TV_SATELLITE_SERVICE => 240,
            KeyCode::KEYCODE_TV_NETWORK => 241,
            KeyCode::KEYCODE_TV_ANTENNA_CABLE => 242,
            KeyCode::KEYCODE_TV_INPUT_HDMI_1 => 243,
            KeyCode::KEYCODE_TV_INPUT_HDMI_2 => 244,
            KeyCode::KEYCODE_TV_INPUT_HDMI_3 => 245,
            KeyCode::KEYCODE_TV_INPUT_HDMI_4 => 246,
            KeyCode::KEYCODE_TV_INPUT_COMPOSITE_1 => 247,
            KeyCode::KEYCODE_TV_INPUT_COMPOSITE_2 => 248,
            KeyCode::KEYCODE_TV_INPUT_COMPONENT_1 => 249,
            KeyCode::KEYCODE_TV_INPUT_COMPONENT_2 => 250,
            KeyCode::KEYCODE_TV_INPUT_VGA_1 => 251,
            KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION => 252,
            KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP => 253,
            KeyCode::KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN => 254,
            KeyCode::KEYCODE_TV_ZOOM_MODE => 255,
            KeyCode::KEYCODE_TV_CONTENTS_MENU => 256,
            KeyCode::KEYCODE_TV_MEDIA_CONTEXT_MENU => 257,
            KeyCode::KEYCODE_TV_TIMER_PROGRAMMING => 258,
            KeyCode::KEYCODE_HELP => 259,
            KeyCode::KEYCODE_NAVIGATE_PREVIOUS => 260,
            KeyCode::KEYCODE_NAVIGATE_NEXT => 261,
            KeyCode::KEYCODE_NAVIGATE_IN => 262,
            KeyCode::KEYCODE_NAVIGATE_OUT => 263,
            KeyCode::KEYCODE_DPAD_UP_LEFT => 264,
            KeyCode::KEYCODE_DPAD_DOWN_LEFT => 265,
            KeyCode::KEYCODE_DPAD_UP_RIGHT => 266,
            KeyCode::KEYCODE_DPAD_DOWN_RIGHT => 267,
            KeyCode::KEYCODE_SENTINEL => 268,
            KeyCode::KEYCODE_ROTARY_CONTROLLER => 269,
            KeyCode::KEYCODE_MEDIA => 270,
            KeyCode::KEYCODE_NAVIGATION => 271,
            KeyCode::KEYCODE_RADIO => 272,
            KeyCode::KEYCODE_TEL => 273,
            KeyCode::KEYCODE_PRIMARY_BUTTON => 274,
            KeyCode::KEYCODE_SECONDARY_BUTTON => 275,
            KeyCode::KEYCODE_TERTIARY_BUTTON => 276,
            KeyCode::KEYCODE_TURN_CARD => 277,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KeyCode {
    fn default() -> Self {
        KeyCode::KEYCODE_UNKNOWN
    }
}

impl KeyCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyCode>("KeyCode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GalConstants)
pub enum GalConstants {
    // @@protoc_insertion_point(enum_value:GalConstants.WIFI_PORT)
    WIFI_PORT = 30515,
    // @@protoc_insertion_point(enum_value:GalConstants.PROTOCOL_MAJOR_VERSION)
    PROTOCOL_MAJOR_VERSION = 1,
    // @@protoc_insertion_point(enum_value:GalConstants.PROTOCOL_MINOR_VERSION)
    PROTOCOL_MINOR_VERSION = 6,
}

impl ::protobuf::Enum for GalConstants {
    const NAME: &'static str = "GalConstants";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GalConstants> {
        match value {
            30515 => ::std::option::Option::Some(GalConstants::WIFI_PORT),
            1 => ::std::option::Option::Some(GalConstants::PROTOCOL_MAJOR_VERSION),
            6 => ::std::option::Option::Some(GalConstants::PROTOCOL_MINOR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GalConstants> {
        match str {
            "WIFI_PORT" => ::std::option::Option::Some(GalConstants::WIFI_PORT),
            "PROTOCOL_MAJOR_VERSION" => ::std::option::Option::Some(GalConstants::PROTOCOL_MAJOR_VERSION),
            "PROTOCOL_MINOR_VERSION" => ::std::option::Option::Some(GalConstants::PROTOCOL_MINOR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GalConstants] = &[
        GalConstants::WIFI_PORT,
        GalConstants::PROTOCOL_MAJOR_VERSION,
        GalConstants::PROTOCOL_MINOR_VERSION,
    ];
}

impl ::protobuf::EnumFull for GalConstants {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GalConstants").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GalConstants::WIFI_PORT => 0,
            GalConstants::PROTOCOL_MAJOR_VERSION => 1,
            GalConstants::PROTOCOL_MINOR_VERSION => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GalConstants {
    fn default() -> Self {
        GalConstants::WIFI_PORT
    }
}

impl GalConstants {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GalConstants>("GalConstants")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cprotos.proto\x1a\x0ccommon.proto\"B\n\x15VersionRequestOptions\x12\
    )\n\x10snapshot_version\x18\x01\x20\x01(\x03R\x0fsnapshotVersion\"m\n\
    \x16VersionResponseOptions\x12S\n\x18connection_configuration\x18\x01\
    \x20\x01(\x0b2\x18.ConnectionConfigurationR\x17connectionConfiguration\"\
    &\n\x0cAuthResponse\x12\x16\n\x06status\x18\x01\x20\x02(\x05R\x06status\
    \"\xea\x01\n\x17ServiceDiscoveryRequest\x12\x1d\n\nsmall_icon\x18\x01\
    \x20\x01(\x0cR\tsmallIcon\x12\x1f\n\x0bmedium_icon\x18\x02\x20\x01(\x0cR\
    \nmediumIcon\x12\x1d\n\nlarge_icon\x18\x03\x20\x01(\x0cR\tlargeIcon\x12\
    \x1d\n\nlabel_text\x18\x04\x20\x01(\tR\tlabelText\x12\x1f\n\x0bdevice_na\
    me\x18\x05\x20\x01(\tR\ndeviceName\x120\n\nphone_info\x18\x06\x20\x01(\
    \x0b2\x11.common.PhoneInfoR\tphoneInfo\"\x98\x06\n\x18ServiceDiscoveryRe\
    sponse\x12$\n\x08services\x18\x01\x20\x03(\x0b2\x08.ServiceR\x08services\
    \x12\x16\n\x04make\x18\x02\x20\x01(\tR\x04makeB\x02\x18\x01\x12\x18\n\
    \x05model\x18\x03\x20\x01(\tR\x05modelB\x02\x18\x01\x12\x16\n\x04year\
    \x18\x04\x20\x01(\tR\x04yearB\x02\x18\x01\x12!\n\nvehicle_id\x18\x05\x20\
    \x01(\tR\tvehicleIdB\x02\x18\x01\x128\n\x0fdriver_position\x18\x06\x20\
    \x01(\x0e2\x0f.DriverPositionR\x0edriverPosition\x12(\n\x0ehead_unit_mak\
    e\x18\x07\x20\x01(\tR\x0cheadUnitMakeB\x02\x18\x01\x12*\n\x0fhead_unit_m\
    odel\x18\x08\x20\x01(\tR\rheadUnitModelB\x02\x18\x01\x12;\n\x18head_unit\
    _software_build\x18\t\x20\x01(\tR\x15headUnitSoftwareBuildB\x02\x18\x01\
    \x12?\n\x1ahead_unit_software_version\x18\n\x20\x01(\tR\x17headUnitSoftw\
    areVersionB\x02\x18\x01\x12G\n\x1fcan_play_native_media_during_vr\x18\
    \x0b\x20\x01(\x08R\x1acanPlayNativeMediaDuringVrB\x02\x18\x01\x123\n\x15\
    session_configuration\x18\r\x20\x01(\x05R\x14sessionConfiguration\x12!\n\
    \x0cdisplay_name\x18\x0e\x20\x01(\tR\x0bdisplayName\x12*\n\x11probe_for_\
    support\x18\x0f\x20\x01(\x08R\x0fprobeForSupport\x12S\n\x18connection_co\
    nfiguration\x18\x10\x20\x01(\x0b2\x18.ConnectionConfigurationR\x17connec\
    tionConfiguration\x129\n\rheadunit_info\x18\x11\x20\x01(\x0b2\x14.common\
    .HeadUnitInfoR\x0cheadunitInfo\"<\n\x16ServiceDiscoveryUpdate\x12\"\n\
    \x07service\x18\x01\x20\x01(\x0b2\x08.ServiceR\x07service\"\xe2\x07\n\
    \x07Service\x12\x0e\n\x02id\x18\x01\x20\x02(\x05R\x02id\x12H\n\x15sensor\
    _source_service\x18\x02\x20\x01(\x0b2\x14.SensorSourceServiceR\x13sensor\
    SourceService\x12?\n\x12media_sink_service\x18\x03\x20\x01(\x0b2\x11.Med\
    iaSinkServiceR\x10mediaSinkService\x12E\n\x14input_source_service\x18\
    \x04\x20\x01(\x0b2\x13.InputSourceServiceR\x12inputSourceService\x12E\n\
    \x14media_source_service\x18\x05\x20\x01(\x0b2\x13.MediaSourceServiceR\
    \x12mediaSourceService\x12>\n\x11bluetooth_service\x18\x06\x20\x01(\x0b2\
    \x11.BluetoothServiceR\x10bluetoothService\x122\n\rradio_service\x18\x07\
    \x20\x01(\x0b2\r.RadioServiceR\x0cradioService\x12T\n\x19navigation_stat\
    us_service\x18\x08\x20\x01(\x0b2\x18.NavigationStatusServiceR\x17navigat\
    ionStatusService\x12Q\n\x16media_playback_service\x18\t\x20\x01(\x0b2\
    \x1b.MediaPlaybackStatusServiceR\x14mediaPlaybackService\x12E\n\x14phone\
    _status_service\x18\n\x20\x01(\x0b2\x13.PhoneStatusServiceR\x12phoneStat\
    usService\x12H\n\x15media_browser_service\x18\x0b\x20\x01(\x0b2\x14.Medi\
    aBrowserServiceR\x13mediaBrowserService\x12Q\n\x18vendor_extension_servi\
    ce\x18\x0c\x20\x01(\x0b2\x17.VendorExtensionServiceR\x16vendorExtensionS\
    ervice\x12]\n\x1cgeneric_notification_service\x18\r\x20\x01(\x0b2\x1b.Ge\
    nericNotificationServiceR\x1agenericNotificationService\x12N\n\x17wifi_p\
    rojection_service\x18\x0e\x20\x01(\x0b2\x16.WifiProjectionServiceR\x15wi\
    fiProjectionService\"\xb5\x01\n\x17ConnectionConfiguration\x12A\n\x12pin\
    g_configuration\x18\x01\x20\x01(\x0b2\x12.PingConfigurationR\x11pingConf\
    iguration\x12W\n\x1awireless_tcp_configuration\x18\x02\x20\x01(\x0b2\x19\
    .WirelessTcpConfigurationR\x18wirelessTcpConfiguration\"\xbc\x01\n\x11Pi\
    ngConfiguration\x12\x1d\n\ntimeout_ms\x18\x01\x20\x01(\rR\ttimeoutMs\x12\
    \x1f\n\x0binterval_ms\x18\x02\x20\x01(\rR\nintervalMs\x129\n\x19high_lat\
    ency_threshold_ms\x18\x03\x20\x01(\rR\x16highLatencyThresholdMs\x12,\n\
    \x12tracked_ping_count\x18\x04\x20\x01(\rR\x10trackedPingCount\"\xcd\x01\
    \n\x18WirelessTcpConfiguration\x12@\n\x1dsocket_receive_buffer_size_kb\
    \x18\x01\x20\x01(\rR\x19socketReceiveBufferSizeKb\x12:\n\x1asocket_send_\
    buffer_size_kb\x18\x02\x20\x01(\rR\x16socketSendBufferSizeKb\x123\n\x16s\
    ocket_read_timeout_ms\x18\x03\x20\x01(\rR\x13socketReadTimeoutMs\"\xd1\
    \x02\n\x13SensorSourceService\x125\n\x07sensors\x18\x01\x20\x03(\x0b2\
    \x1b.SensorSourceService.SensorR\x07sensors\x12;\n\x19location_character\
    ization\x18\x02\x20\x01(\rR\x18locationCharacterization\x12;\n\x14suppor\
    ted_fuel_types\x18\x03\x20\x03(\x0e2\t.FuelTypeR\x12supportedFuelTypes\
    \x12Q\n\x1csupported_ev_connector_types\x18\x04\x20\x03(\x0e2\x10.EvConn\
    ectorTypeR\x19supportedEvConnectorTypes\x1a6\n\x06Sensor\x12,\n\x0bsenso\
    r_type\x18\x01\x20\x02(\x0e2\x0b.SensorTypeR\nsensorType\"\xcf\x03\n\x10\
    MediaSinkService\x12M\n\x0eavailable_type\x18\x01\x20\x01(\x0e2\x0f.Medi\
    aCodecType:\x15MEDIA_CODEC_AUDIO_PCMR\ravailableType\x12/\n\naudio_type\
    \x18\x02\x20\x01(\x0e2\x10.AudioStreamTypeR\taudioType\x128\n\raudio_con\
    figs\x18\x03\x20\x03(\x0b2\x13.AudioConfigurationR\x0caudioConfigs\x128\
    \n\rvideo_configs\x18\x04\x20\x03(\x0b2\x13.VideoConfigurationR\x0cvideo\
    Configs\x125\n\x17available_while_in_call\x18\x05\x20\x01(\x08R\x14avail\
    ableWhileInCall\x12\x1d\n\ndisplay_id\x18\x06\x20\x01(\rR\tdisplayId\x12\
    /\n\x0cdisplay_type\x18\x07\x20\x01(\x0e2\x0c.DisplayTypeR\x0bdisplayTyp\
    e\x12@\n\x17initial_content_keycode\x18\x08\x20\x01(\x0e2\x08.KeyCodeR\
    \x15initialContentKeycode\"\x8e\x04\n\x12VideoConfiguration\x12D\n\x10co\
    dec_resolution\x18\x01\x20\x01(\x0e2\x19.VideoCodecResolutionTypeR\x0fco\
    decResolution\x122\n\nframe_rate\x18\x02\x20\x01(\x0e2\x13.VideoFrameRat\
    eTypeR\tframeRate\x12!\n\x0cwidth_margin\x18\x03\x20\x01(\rR\x0bwidthMar\
    gin\x12#\n\rheight_margin\x18\x04\x20\x01(\rR\x0cheightMargin\x12\x18\n\
    \x07density\x18\x05\x20\x01(\rR\x07density\x128\n\x18decoder_additional_\
    depth\x18\x06\x20\x01(\rR\x16decoderAdditionalDepth\x12)\n\x10viewing_di\
    stance\x18\x07\x20\x01(\rR\x0fviewingDistance\x121\n\x15pixel_aspect_rat\
    io_e4\x18\x08\x20\x01(\rR\x12pixelAspectRatioE4\x12!\n\x0creal_density\
    \x18\t\x20\x01(\rR\x0brealDensity\x129\n\x10video_codec_type\x18\n\x20\
    \x01(\x0e2\x0f.MediaCodecTypeR\x0evideoCodecType\x12&\n\tui_config\x18\
    \x0b\x20\x01(\x0b2\t.UiConfigR\x08uiConfig\"\xbf\x01\n\x08UiConfig\x12!\
    \n\x07margins\x18\x01\x20\x01(\x0b2\x07.InsetsR\x07margins\x12.\n\x0econ\
    tent_insets\x18\x02\x20\x01(\x0b2\x07.InsetsR\rcontentInsets\x12;\n\x15s\
    table_content_insets\x18\x03\x20\x01(\x0b2\x07.InsetsR\x13stableContentI\
    nsets\x12#\n\x08ui_theme\x18\x04\x20\x01(\x0e2\x08.UiThemeR\x07uiTheme\"\
    \\\n\x06Insets\x12\x10\n\x03top\x18\x01\x20\x01(\rR\x03top\x12\x16\n\x06\
    bottom\x18\x02\x20\x01(\rR\x06bottom\x12\x12\n\x04left\x18\x03\x20\x01(\
    \rR\x04left\x12\x14\n\x05right\x18\x04\x20\x01(\rR\x05right\"\xd2\x01\n\
    \x12MediaSourceService\x12M\n\x0eavailable_type\x18\x01\x20\x01(\x0e2\
    \x0f.MediaCodecType:\x15MEDIA_CODEC_AUDIO_PCMR\ravailableType\x126\n\x0c\
    audio_config\x18\x02\x20\x01(\x0b2\x13.AudioConfigurationR\x0baudioConfi\
    g\x125\n\x17available_while_in_call\x18\x03\x20\x01(\x08R\x14availableWh\
    ileInCall\"\x8d\x01\n\x12AudioConfiguration\x12#\n\rsampling_rate\x18\
    \x01\x20\x02(\rR\x0csamplingRate\x12$\n\x0enumber_of_bits\x18\x02\x20\
    \x02(\rR\x0cnumberOfBits\x12,\n\x12number_of_channels\x18\x03\x20\x02(\r\
    R\x10numberOfChannels\"\xcd\x05\n\x12InputSourceService\x121\n\x12keycod\
    es_supported\x18\x01\x20\x03(\x05R\x11keycodesSupportedB\x02\x10\x01\x12\
    A\n\x0btouchscreen\x18\x02\x20\x03(\x0b2\x1f.InputSourceService.TouchScr\
    eenR\x0btouchscreen\x128\n\x08touchpad\x18\x03\x20\x03(\x0b2\x1c.InputSo\
    urceService.TouchPadR\x08touchpad\x12J\n\x19feedback_events_supported\
    \x18\x04\x20\x03(\x0e2\x0e.FeedbackEventR\x17feedbackEventsSupported\x12\
    \x1d\n\ndisplay_id\x18\x05\x20\x01(\rR\tdisplayId\x1a\x84\x01\n\x0bTouch\
    Screen\x12\x14\n\x05width\x18\x01\x20\x02(\x05R\x05width\x12\x16\n\x06he\
    ight\x18\x02\x20\x02(\x05R\x06height\x12$\n\x04type\x18\x03\x20\x01(\x0e\
    2\x10.TouchScreenTypeR\x04type\x12!\n\x0cis_secondary\x18\x04\x20\x01(\
    \x08R\x0bisSecondary\x1a\x94\x02\n\x08TouchPad\x12\x14\n\x05width\x18\
    \x01\x20\x02(\x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x02(\x05R\
    \x06height\x12#\n\rui_navigation\x18\x03\x20\x01(\x08R\x0cuiNavigation\
    \x12%\n\x0ephysical_width\x18\x04\x20\x01(\x05R\rphysicalWidth\x12'\n\
    \x0fphysical_height\x18\x05\x20\x01(\x05R\x0ephysicalHeight\x12\x1f\n\
    \x0bui_absolute\x18\x06\x20\x01(\x08R\nuiAbsolute\x12\"\n\rtap_as_select\
    \x18\x07\x20\x01(\x08R\x0btapAsSelect\x12\x20\n\x0bsensitivity\x18\x08\
    \x20\x01(\x05R\x0bsensitivity\"\x8c\x01\n\x10BluetoothService\x12\x1f\n\
    \x0bcar_address\x18\x01\x20\x02(\tR\ncarAddress\x12W\n\x19supported_pair\
    ing_methods\x18\x02\x20\x03(\x0e2\x17.BluetoothPairingMethodR\x17support\
    edPairingMethodsB\x02\x10\x01\"K\n\x0cRadioService\x12;\n\x10radio_prope\
    rties\x18\x01\x20\x03(\x0b2\x10.RadioPropertiesR\x0fradioProperties\"\
    \xa9\x04\n\x0fRadioProperties\x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05\
    R\x07radioId\x12\x1e\n\x04type\x18\x02\x20\x02(\x0e2\n.RadioTypeR\x04typ\
    e\x12+\n\rchannel_range\x18\x03\x20\x03(\x0b2\x06.RangeR\x0cchannelRange\
    \x12)\n\x10channel_spacings\x18\x04\x20\x03(\x05R\x0fchannelSpacings\x12\
    '\n\x0fchannel_spacing\x18\x05\x20\x02(\x05R\x0echannelSpacing\x12)\n\
    \x10background_tuner\x18\x06\x20\x01(\x08R\x0fbackgroundTuner\x12\"\n\
    \x06region\x18\x07\x20\x01(\x0e2\n.ItuRegionR\x06region\x12\x1a\n\x03rds\
    \x18\x08\x20\x01(\x0e2\x08.RdsTypeR\x03rds\x12\x1b\n\taf_switch\x18\t\
    \x20\x01(\x08R\x08afSwitch\x12\x0e\n\x02ta\x18\n\x20\x01(\x08R\x02ta\x12\
    <\n\x0ftraffic_service\x18\x0b\x20\x01(\x0e2\x13.TrafficServiceTypeR\x0e\
    trafficService\x12%\n\x0eaudio_loopback\x18\x0c\x20\x01(\x08R\raudioLoop\
    back\x12'\n\x0fmute_capability\x18\r\x20\x01(\x08R\x0emuteCapability\x12\
    4\n\x16station_presets_access\x18\x0e\x20\x01(\x05R\x14stationPresetsAcc\
    ess\"+\n\x05Range\x12\x10\n\x03min\x18\x01\x20\x02(\x05R\x03min\x12\x10\
    \n\x03max\x18\x02\x20\x02(\x05R\x03max\"\xf1\x02\n\x17NavigationStatusSe\
    rvice\x12.\n\x13minimum_interval_ms\x18\x01\x20\x02(\x05R\x11minimumInte\
    rvalMs\x12B\n\x04type\x18\x02\x20\x02(\x0e2..NavigationStatusService.Ins\
    trumentClusterTypeR\x04type\x12J\n\rimage_options\x18\x03\x20\x01(\x0b2%\
    .NavigationStatusService.ImageOptionsR\x0cimageOptions\x1ah\n\x0cImageOp\
    tions\x12\x16\n\x06height\x18\x01\x20\x02(\x05R\x06height\x12\x14\n\x05w\
    idth\x18\x02\x20\x02(\x05R\x05width\x12*\n\x11colour_depth_bits\x18\x03\
    \x20\x02(\x05R\x0fcolourDepthBits\",\n\x15InstrumentClusterType\x12\t\n\
    \x05IMAGE\x10\x01\x12\x08\n\x04ENUM\x10\x02\"\x1c\n\x1aMediaPlaybackStat\
    usService\"\x14\n\x12PhoneStatusService\"\x15\n\x13MediaBrowserService\"\
    }\n\x16VendorExtensionService\x12!\n\x0cservice_name\x18\x01\x20\x02(\tR\
    \x0bserviceName\x12,\n\x12package_white_list\x18\x02\x20\x03(\tR\x10pack\
    ageWhiteList\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\x1c\n\x1a\
    GenericNotificationService\"O\n\x12ChannelOpenRequest\x12\x1a\n\x08prior\
    ity\x18\x01\x20\x02(\x11R\x08priority\x12\x1d\n\nservice_id\x18\x02\x20\
    \x02(\x05R\tserviceId\"=\n\x13ChannelOpenResponse\x12&\n\x06status\x18\
    \x01\x20\x02(\x0e2\x0e.MessageStatusR\x06status\"\x1a\n\x18ChannelCloseN\
    otification\"K\n\x1bNavFocusRequestNotification\x12,\n\nfocus_type\x18\
    \x01\x20\x01(\x0e2\r.NavFocusTypeR\tfocusType\"D\n\x14NavFocusNotificati\
    on\x12,\n\nfocus_type\x18\x01\x20\x02(\x0e2\r.NavFocusTypeR\tfocusType\"\
    ^\n\x0bPingRequest\x12\x1c\n\ttimestamp\x18\x01\x20\x02(\x03R\ttimestamp\
    \x12\x1d\n\nbug_report\x18\x02\x20\x01(\x08R\tbugReport\x12\x12\n\x04dat\
    a\x18\x03\x20\x01(\x0cR\x04data\"@\n\x0cPingResponse\x12\x1c\n\ttimestam\
    p\x18\x01\x20\x02(\x03R\ttimestamp\x12\x12\n\x04data\x18\x02\x20\x01(\
    \x0cR\x04data\"6\n\rByeByeRequest\x12%\n\x06reason\x18\x01\x20\x02(\x0e2\
    \r.ByeByeReasonR\x06reason\"\x10\n\x0eByeByeResponse\"G\n\x18VoiceSessio\
    nNotification\x12+\n\x06status\x18\x01\x20\x01(\x0e2\x13.VoiceSessionSta\
    tusR\x06status\"\x1c\n\x1aCarConnectedDevicesRequest\"\x9b\x01\n\x13CarC\
    onnectedDevices\x12=\n\x11connected_devices\x18\x01\x20\x03(\x0b2\x10.Co\
    nnectedDeviceR\x10connectedDevices\x12\x20\n\x0bunsolicited\x18\x02\x20\
    \x01(\x08R\x0bunsolicited\x12#\n\nfinal_list\x18\x03\x20\x01(\x08:\x04tr\
    ueR\tfinalList\"O\n\x0fConnectedDevice\x12\x1f\n\x0bdevice_name\x18\x01\
    \x20\x01(\tR\ndeviceName\x12\x1b\n\tdevice_id\x18\x02\x20\x01(\x05R\x08d\
    eviceId\"N\n\x11UserSwitchRequest\x129\n\x0fselected_device\x18\x01\x20\
    \x01(\x0b2\x10.ConnectedDeviceR\x0eselectedDevice\"z\n\x12UserSwitchResp\
    onse\x12)\n\x06status\x18\x01\x20\x01(\x0e2\x11.UserSwitchStatusR\x06sta\
    tus\x129\n\x0fselected_device\x18\x02\x20\x01(\x0b2\x10.ConnectedDeviceR\
    \x0eselectedDevice\"\x95\x01\n\x19BatteryStatusNotification\x12#\n\rbatt\
    ery_level\x18\x01\x20\x02(\rR\x0cbatteryLevel\x12(\n\x10time_remaining_s\
    \x18\x02\x20\x01(\rR\x0etimeRemainingS\x12)\n\x10critical_battery\x18\
    \x03\x20\x01(\x08R\x0fcriticalBattery\"?\n\x16CallAvailabilityStatus\x12\
    %\n\x0ecall_available\x18\x01\x20\x01(\x08R\rcallAvailable\"\\\n\rSensor\
    Request\x12\x1f\n\x04type\x18\x01\x20\x02(\x0e2\x0b.SensorTypeR\x04type\
    \x12*\n\x11min_update_period\x18\x02\x20\x02(\x03R\x0fminUpdatePeriod\"8\
    \n\x0eSensorResponse\x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.MessageS\
    tatusR\x06status\"\xa4\t\n\x0bSensorBatch\x122\n\rlocation_data\x18\x01\
    \x20\x03(\x0b2\r.LocationDataR\x0clocationData\x12/\n\x0ccompass_data\
    \x18\x02\x20\x03(\x0b2\x0c.CompassDataR\x0bcompassData\x12)\n\nspeed_dat\
    a\x18\x03\x20\x03(\x0b2\n.SpeedDataR\tspeedData\x12#\n\x08rpm_data\x18\
    \x04\x20\x03(\x0b2\x08.RpmDataR\x07rpmData\x122\n\rodometer_data\x18\x05\
    \x20\x03(\x0b2\r.OdometerDataR\x0codometerData\x12&\n\tfuel_data\x18\x06\
    \x20\x03(\x0b2\t.FuelDataR\x08fuelData\x12?\n\x12parking_brake_data\x18\
    \x07\x20\x03(\x0b2\x11.ParkingBrakeDataR\x10parkingBrakeData\x12&\n\tgea\
    r_data\x18\x08\x20\x03(\x0b2\t.GearDataR\x08gearData\x12;\n\x10diagnosti\
    cs_data\x18\t\x20\x03(\x0b2\x10.DiagnosticsDataR\x0fdiagnosticsData\x126\
    \n\x0fnight_mode_data\x18\n\x20\x03(\x0b2\x0e.NightModeDataR\rnightModeD\
    ata\x12;\n\x10environment_data\x18\x0b\x20\x03(\x0b2\x10.EnvironmentData\
    R\x0fenvironmentData\x12&\n\thvac_data\x18\x0c\x20\x03(\x0b2\t.HvacDataR\
    \x08hvacData\x12B\n\x13driving_status_data\x18\r\x20\x03(\x0b2\x12.Drivi\
    ngStatusDataR\x11drivingStatusData\x12B\n\x13dead_reckoning_data\x18\x0e\
    \x20\x03(\x0b2\x12.DeadReckoningDataR\x11deadReckoningData\x125\n\x0epas\
    senger_data\x18\x0f\x20\x03(\x0b2\x0e.PassengerDataR\rpassengerData\x12&\
    \n\tdoor_data\x18\x10\x20\x03(\x0b2\t.DoorDataR\x08doorData\x12)\n\nligh\
    t_data\x18\x11\x20\x03(\x0b2\n.LightDataR\tlightData\x12?\n\x12tire_pres\
    sure_data\x18\x12\x20\x03(\x0b2\x11.TirePressureDataR\x10tirePressureDat\
    a\x12A\n\x12accelerometer_data\x18\x13\x20\x03(\x0b2\x12.AccelerometerDa\
    taR\x11accelerometerData\x125\n\x0egyroscope_data\x18\x14\x20\x03(\x0b2\
    \x0e.GyroscopeDataR\rgyroscopeData\x12?\n\x12gps_satellite_data\x18\x15\
    \x20\x03(\x0b2\x11.GpsSatelliteDataR\x10gpsSatelliteData\x123\n\x0etoll_\
    card_data\x18\x16\x20\x03(\x0b2\r.TollCardDataR\x0ctollCardData\"y\n\x0b\
    SensorError\x12,\n\x0bsensor_type\x18\x01\x20\x02(\x0e2\x0b.SensorTypeR\
    \nsensorType\x12<\n\x11sensor_error_type\x18\x02\x20\x02(\x0e2\x10.Senso\
    rErrorTypeR\x0fsensorErrorType\"\xf0\x01\n\x0cLocationData\x12\x20\n\tti\
    mestamp\x18\x01\x20\x01(\x04R\ttimestampB\x02\x18\x01\x12\x1f\n\x0blatit\
    ude_e7\x18\x02\x20\x02(\x05R\nlatitudeE7\x12!\n\x0clongitude_e7\x18\x03\
    \x20\x02(\x05R\x0blongitudeE7\x12\x1f\n\x0baccuracy_e3\x18\x04\x20\x01(\
    \rR\naccuracyE3\x12\x1f\n\x0baltitude_e2\x18\x05\x20\x01(\x05R\naltitude\
    E2\x12\x19\n\x08speed_e3\x18\x06\x20\x01(\x05R\x07speedE3\x12\x1d\n\nbea\
    ring_e6\x18\x07\x20\x01(\x05R\tbearingE6\"`\n\x0bCompassData\x12\x1d\n\n\
    bearing_e6\x18\x01\x20\x02(\x05R\tbearingE6\x12\x19\n\x08pitch_e6\x18\
    \x02\x20\x01(\x05R\x07pitchE6\x12\x17\n\x07roll_e6\x18\x03\x20\x01(\x05R\
    \x06rollE6\"w\n\tSpeedData\x12\x19\n\x08speed_e3\x18\x01\x20\x02(\x05R\
    \x07speedE3\x12%\n\x0ecruise_engaged\x18\x02\x20\x01(\x08R\rcruiseEngage\
    d\x12(\n\x10cruise_set_speed\x18\x04\x20\x01(\x05R\x0ecruiseSetSpeed\"\
    \x20\n\x07RpmData\x12\x15\n\x06rpm_e3\x18\x01\x20\x02(\x05R\x05rpmE3\"E\
    \n\x0cOdometerData\x12\x15\n\x06kms_e1\x18\x01\x20\x02(\x05R\x05kmsE1\
    \x12\x1e\n\x0btrip_kms_e1\x18\x02\x20\x01(\x05R\ttripKmsE1\"i\n\x08FuelD\
    ata\x12\x1d\n\nfuel_level\x18\x01\x20\x01(\x05R\tfuelLevel\x12\x14\n\x05\
    range\x18\x02\x20\x01(\x05R\x05range\x12(\n\x10low_fuel_warning\x18\x03\
    \x20\x01(\x08R\x0elowFuelWarning\"7\n\x10ParkingBrakeData\x12#\n\rparkin\
    g_brake\x18\x01\x20\x02(\x08R\x0cparkingBrake\"%\n\x08GearData\x12\x19\n\
    \x04gear\x18\x01\x20\x02(\x0e2\x05.GearR\x04gear\"#\n\x0fDiagnosticsData\
    \x12\x10\n\x03dtc\x18\x01\x20\x01(\x0cR\x03dtc\".\n\rNightModeData\x12\
    \x1d\n\nnight_mode\x18\x01\x20\x01(\x08R\tnightMode\"m\n\x0fEnvironmentD\
    ata\x12%\n\x0etemperature_e3\x18\x01\x20\x01(\x05R\rtemperatureE3\x12\
    \x1f\n\x0bpressure_e3\x18\x02\x20\x01(\x05R\npressureE3\x12\x12\n\x04rai\
    n\x18\x03\x20\x01(\x05R\x04rain\"t\n\x08HvacData\x122\n\x15target_temper\
    ature_e3\x18\x01\x20\x01(\x05R\x13targetTemperatureE3\x124\n\x16current_\
    temperature_e3\x18\x02\x20\x01(\x05R\x14currentTemperatureE3\"+\n\x11Dri\
    vingStatusData\x12\x16\n\x06status\x18\x01\x20\x02(\x05R\x06status\"e\n\
    \x11DeadReckoningData\x12*\n\x11steering_angle_e1\x18\x01\x20\x01(\x05R\
    \x0fsteeringAngleE1\x12$\n\x0ewheel_speed_e3\x18\x02\x20\x03(\x05R\x0cwh\
    eelSpeedE3\"\xb7\x01\n\tLightData\x129\n\x10head_light_state\x18\x01\x20\
    \x01(\x0e2\x0f.HeadLightStateR\x0eheadLightState\x12E\n\x14turn_indicato\
    r_state\x18\x02\x20\x01(\x0e2\x13.TurnIndicatorStateR\x12turnIndicatorSt\
    ate\x12(\n\x10hazard_lights_on\x18\x03\x20\x01(\x08R\x0ehazardLightsOn\"\
    <\n\rPassengerData\x12+\n\x11passenger_present\x18\x01\x20\x01(\x08R\x10\
    passengerPresent\"c\n\x08DoorData\x12\x1b\n\thood_open\x18\x01\x20\x01(\
    \x08R\x08hoodOpen\x12\x1d\n\ntrunk_open\x18\x02\x20\x01(\x08R\ttrunkOpen\
    \x12\x1b\n\tdoor_open\x18\x03\x20\x03(\x08R\x08doorOpen\">\n\x10TirePres\
    sureData\x12*\n\x11tire_pressures_e2\x18\x01\x20\x03(\x05R\x0ftirePressu\
    resE2\"\x97\x01\n\x11AccelerometerData\x12*\n\x11acceleration_x_e3\x18\
    \x01\x20\x01(\x05R\x0faccelerationXE3\x12*\n\x11acceleration_y_e3\x18\
    \x02\x20\x01(\x05R\x0faccelerationYE3\x12*\n\x11acceleration_z_e3\x18\
    \x03\x20\x01(\x05R\x0faccelerationZE3\"\x9c\x01\n\rGyroscopeData\x12-\n\
    \x13rotation_speed_x_e3\x18\x01\x20\x01(\x05R\x10rotationSpeedXE3\x12-\n\
    \x13rotation_speed_y_e3\x18\x02\x20\x01(\x05R\x10rotationSpeedYE3\x12-\n\
    \x13rotation_speed_z_e3\x18\x03\x20\x01(\x05R\x10rotationSpeedZE3\"\x99\
    \x01\n\x0cGpsSatellite\x12\x10\n\x03prn\x18\x01\x20\x02(\x05R\x03prn\x12\
    \x15\n\x06snr_e3\x18\x02\x20\x02(\x05R\x05snrE3\x12\x1e\n\x0bused_in_fix\
    \x18\x03\x20\x02(\x08R\tusedInFix\x12\x1d\n\nazimuth_e3\x18\x04\x20\x01(\
    \x05R\tazimuthE3\x12!\n\x0celevation_e3\x18\x05\x20\x01(\x05R\x0belevati\
    onE3\"\x8b\x01\n\x10GpsSatelliteData\x12\"\n\rnumber_in_use\x18\x01\x20\
    \x02(\x05R\x0bnumberInUse\x12$\n\x0enumber_in_view\x18\x02\x20\x01(\x05R\
    \x0cnumberInView\x12-\n\nsatellites\x18\x03\x20\x03(\x0b2\r.GpsSatellite\
    R\nsatellites\"6\n\x0cTollCardData\x12&\n\x0fis_card_present\x18\x01\x20\
    \x02(\x08R\risCardPresent\",\n\x05Setup\x12#\n\x04type\x18\x01\x20\x02(\
    \x0e2\x0f.MediaCodecTypeR\x04type\"W\n\x05Start\x12\x1d\n\nsession_id\
    \x18\x01\x20\x02(\x05R\tsessionId\x12/\n\x13configuration_index\x18\x02\
    \x20\x02(\rR\x12configurationIndex\"\x06\n\x04Stop\"\xb3\x01\n\x06Config\
    \x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.Config.StatusR\x06status\x12\
    \x1f\n\x0bmax_unacked\x18\x02\x20\x01(\rR\nmaxUnacked\x123\n\x15configur\
    ation_indices\x18\x03\x20\x03(\rR\x14configurationIndices\"+\n\x06Status\
    \x12\x0f\n\x0bSTATUS_WAIT\x10\x01\x12\x10\n\x0cSTATUS_READY\x10\x02\"h\n\
    \x03Ack\x12\x1d\n\nsession_id\x18\x01\x20\x02(\x05R\tsessionId\x12\x10\n\
    \x03ack\x18\x02\x20\x01(\rR\x03ack\x120\n\x14receive_timestamp_ns\x18\
    \x03\x20\x03(\x04R\x12receiveTimestampNs\";\n\x1aAudioUnderflowNotificat\
    ion\x12\x1d\n\nsession_id\x18\x01\x20\x02(\x05R\tsessionId\"\x9b\x01\n\
    \x1dVideoFocusRequestNotification\x12*\n\x0fdisp_channel_id\x18\x01\x20\
    \x01(\x05R\rdispChannelIdB\x02\x18\x01\x12#\n\x04mode\x18\x02\x20\x01(\
    \x0e2\x0f.VideoFocusModeR\x04mode\x12)\n\x06reason\x18\x03\x20\x01(\x0e2\
    \x11.VideoFocusReasonR\x06reason\"a\n\x16VideoFocusNotification\x12%\n\
    \x05focus\x18\x01\x20\x01(\x0e2\x0f.VideoFocusModeR\x05focus\x12\x20\n\
    \x0bunsolicited\x18\x02\x20\x01(\x08R\x0bunsolicited\"?\n\x15UpdateUiCon\
    figRequest\x12&\n\tui_config\x18\x01\x20\x01(\x0b2\t.UiConfigR\x08uiConf\
    ig\"=\n\x13UpdateUiConfigReply\x12&\n\tui_config\x18\x01\x20\x01(\x0b2\t\
    .UiConfigR\x08uiConfig\"Q\n\x1dAudioFocusRequestNotification\x120\n\x07r\
    equest\x18\x01\x20\x02(\x0e2\x16.AudioFocusRequestTypeR\x07request\"q\n\
    \x16AudioFocusNotification\x125\n\x0bfocus_state\x18\x01\x20\x02(\x0e2\
    \x14.AudioFocusStateTypeR\nfocusState\x12\x20\n\x0bunsolicited\x18\x02\
    \x20\x01(\x08R\x0bunsolicited\"\x88\x01\n\x11MicrophoneRequest\x12\x12\n\
    \x04open\x18\x01\x20\x02(\x08R\x04open\x12\x1f\n\x0banc_enabled\x18\x02\
    \x20\x01(\x08R\nancEnabled\x12\x1d\n\nec_enabled\x18\x03\x20\x01(\x08R\t\
    ecEnabled\x12\x1f\n\x0bmax_unacked\x18\x04\x20\x01(\x05R\nmaxUnacked\"K\
    \n\x12MicrophoneResponse\x12\x16\n\x06status\x18\x01\x20\x02(\x05R\x06st\
    atus\x12\x1d\n\nsession_id\x18\x02\x20\x01(\x05R\tsessionId\"3\n\x11KeyB\
    indingRequest\x12\x1e\n\x08keycodes\x18\x01\x20\x03(\x05R\x08keycodesB\
    \x02\x10\x01\",\n\x12KeyBindingResponse\x12\x16\n\x06status\x18\x01\x20\
    \x02(\x05R\x06status\"\xcf\x02\n\x0bInputReport\x12\x1c\n\ttimestamp\x18\
    \x01\x20\x02(\x04R\ttimestamp\x12*\n\x0fdisp_channel_id\x18\x02\x20\x01(\
    \x05R\rdispChannelIdB\x02\x18\x01\x12,\n\x0btouch_event\x18\x03\x20\x01(\
    \x0b2\x0b.TouchEventR\ntouchEvent\x12&\n\tkey_event\x18\x04\x20\x01(\x0b\
    2\t.KeyEventR\x08keyEvent\x125\n\x0eabsolute_event\x18\x05\x20\x01(\x0b2\
    \x0e.AbsoluteEventR\rabsoluteEvent\x125\n\x0erelative_event\x18\x06\x20\
    \x01(\x0b2\x0e.RelativeEventR\rrelativeEvent\x122\n\x0etouchpad_event\
    \x18\x07\x20\x01(\x0b2\x0b.TouchEventR\rtouchpadEvent\"\x9e\x01\n\x08Key\
    Event\x12!\n\x04keys\x18\x01\x20\x03(\x0b2\r.KeyEvent.KeyR\x04keys\x1ao\
    \n\x03Key\x12\x18\n\x07keycode\x18\x01\x20\x02(\rR\x07keycode\x12\x12\n\
    \x04down\x18\x02\x20\x02(\x08R\x04down\x12\x1c\n\tmetastate\x18\x03\x20\
    \x02(\rR\tmetastate\x12\x1c\n\tlongpress\x18\x04\x20\x01(\x08R\tlongpres\
    s\"\xd5\x01\n\nTouchEvent\x126\n\x0cpointer_data\x18\x01\x20\x03(\x0b2\
    \x13.TouchEvent.PointerR\x0bpointerData\x12!\n\x0caction_index\x18\x02\
    \x20\x01(\rR\x0bactionIndex\x12&\n\x06action\x18\x03\x20\x01(\x0e2\x0e.P\
    ointerActionR\x06action\x1aD\n\x07Pointer\x12\x0c\n\x01x\x18\x01\x20\x02\
    (\rR\x01x\x12\x0c\n\x01y\x18\x02\x20\x02(\rR\x01y\x12\x1d\n\npointer_id\
    \x18\x03\x20\x02(\rR\tpointerId\"n\n\rAbsoluteEvent\x12&\n\x04data\x18\
    \x01\x20\x03(\x0b2\x12.AbsoluteEvent.AbsR\x04data\x1a5\n\x03Abs\x12\x18\
    \n\x07keycode\x18\x01\x20\x02(\rR\x07keycode\x12\x14\n\x05value\x18\x02\
    \x20\x02(\x05R\x05value\"n\n\rRelativeEvent\x12&\n\x04data\x18\x01\x20\
    \x03(\x0b2\x12.RelativeEvent.RelR\x04data\x1a5\n\x03Rel\x12\x18\n\x07key\
    code\x18\x01\x20\x02(\rR\x07keycode\x12\x14\n\x05delta\x18\x02\x20\x02(\
    \x05R\x05delta\"5\n\rInputFeedback\x12$\n\x05event\x18\x01\x20\x01(\x0e2\
    \x0e.FeedbackEventR\x05event\"~\n\x17BluetoothPairingRequest\x12#\n\rpho\
    ne_address\x18\x01\x20\x02(\tR\x0cphoneAddress\x12>\n\x0epairing_method\
    \x18\x02\x20\x02(\x0e2\x17.BluetoothPairingMethodR\rpairingMethod\"i\n\
    \x18BluetoothPairingResponse\x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.\
    MessageStatusR\x06status\x12%\n\x0ealready_paired\x18\x02\x20\x02(\x08R\
    \ralreadyPaired\"z\n\x1bBluetoothAuthenticationData\x12\x1b\n\tauth_data\
    \x18\x01\x20\x02(\tR\x08authData\x12>\n\x0epairing_method\x18\x02\x20\
    \x01(\x0e2\x17.BluetoothPairingMethodR\rpairingMethod\"G\n\x1dBluetoothA\
    uthenticationResult\x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.MessageSt\
    atusR\x06status\"=\n\x15WifiProjectionService\x12$\n\x0ecar_wifi_bssid\
    \x18\x01\x20\x01(\tR\x0ccarWifiBssid\"\x18\n\x16WifiCredentialsRequest\"\
    \xa7\x02\n\x17WifiCredentialsResponse\x12*\n\x11car_wifi_password\x18\
    \x01\x20\x01(\tR\x0fcarWifiPassword\x12F\n\x16car_wifi_security_mode\x18\
    \x02\x20\x01(\x0e2\x11.WifiSecurityModeR\x13carWifiSecurityMode\x12\"\n\
    \rcar_wifi_ssid\x18\x03\x20\x01(\tR\x0bcarWifiSsid\x126\n\x17supported_w\
    ifi_channels\x18\x04\x20\x03(\x05R\x15supportedWifiChannels\x12<\n\x11ac\
    cess_point_type\x18\x05\x20\x01(\x0e2\x10.AccessPointTypeR\x0faccessPoin\
    tType\"\xc5\x02\n\x16RadioStateNotification\x120\n\x14radio_source_enabl\
    ed\x18\x01\x20\x02(\x08R\x12radioSourceEnabled\x12\x1f\n\x0bradio_muted\
    \x18\x02\x20\x01(\x08R\nradioMuted\x12&\n\x0factive_radio_id\x18\x03\x20\
    \x02(\x05R\ractiveRadioId\x124\n\x0cstation_info\x18\x04\x20\x02(\x0b2\
    \x11.RadioStationInfoR\x0bstationInfo\x124\n\x0cprogram_list\x18\x05\x20\
    \x03(\x0b2\x11.RadioStationInfoR\x0bprogramList\x12D\n\x14station_preset\
    _lists\x18\x06\x20\x03(\x0b2\x12.StationPresetListR\x12stationPresetList\
    s\"\x14\n\x12RadioSourceRequest\"o\n\x13RadioSourceResponse\x12&\n\x06st\
    atus\x18\x01\x20\x01(\x0e2\x0e.MessageStatusR\x06status\x120\n\x14radio_\
    source_enabled\x18\x02\x20\x02(\x08R\x12radioSourceEnabled\"5\n\x18Selec\
    tActiveRadioRequest\x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05R\x07radio\
    Id\"\x92\x01\n\x17ActiveRadioNotification\x12&\n\x06status\x18\x01\x20\
    \x01(\x0e2\x0e.MessageStatusR\x06status\x12\x19\n\x08radio_id\x18\x02\
    \x20\x02(\x05R\x07radioId\x124\n\x0cstation_info\x18\x03\x20\x01(\x0b2\
    \x11.RadioStationInfoR\x0bstationInfo\"i\n\x12StepChannelRequest\x12\x19\
    \n\x08radio_id\x18\x01\x20\x02(\x05R\x07radioId\x12\x0e\n\x02up\x18\x02\
    \x20\x02(\x08R\x02up\x12(\n\x10skip_sub_channel\x18\x03\x20\x02(\x08R\
    \x0eskipSubChannel\"X\n\x13StepChannelResponse\x12&\n\x06status\x18\x01\
    \x20\x01(\x0e2\x0e.MessageStatusR\x06status\x12\x19\n\x08radio_id\x18\
    \x02\x20\x02(\x05R\x07radioId\"i\n\x12SeekStationRequest\x12\x19\n\x08ra\
    dio_id\x18\x01\x20\x02(\x05R\x07radioId\x12\x0e\n\x02up\x18\x02\x20\x02(\
    \x08R\x02up\x12(\n\x10skip_sub_channel\x18\x03\x20\x02(\x08R\x0eskipSubC\
    hannel\"X\n\x13SeekStationResponse\x12&\n\x06status\x18\x01\x20\x01(\x0e\
    2\x0e.MessageStatusR\x06status\x12\x19\n\x08radio_id\x18\x02\x20\x02(\
    \x05R\x07radioId\"\x80\x01\n\x13ScanStationsRequest\x12\x19\n\x08radio_i\
    d\x18\x01\x20\x02(\x05R\x07radioId\x12\x14\n\x05start\x18\x02\x20\x02(\
    \x08R\x05start\x12\x0e\n\x02up\x18\x03\x20\x02(\x08R\x02up\x12(\n\x10ski\
    p_sub_channel\x18\x04\x20\x02(\x08R\x0eskipSubChannel\"s\n\x14ScanStatio\
    nsResponse\x12&\n\x06status\x18\x01\x20\x01(\x0e2\x0e.MessageStatusR\x06\
    status\x12\x19\n\x08radio_id\x18\x02\x20\x02(\x05R\x07radioId\x12\x18\n\
    \x07started\x18\x03\x20\x01(\x08R\x07started\"l\n\x14TuneToStationReques\
    t\x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05R\x07radioId\x12\x18\n\x07ch\
    annel\x18\x02\x20\x02(\x05R\x07channel\x12\x1f\n\x0bsub_channel\x18\x03\
    \x20\x01(\x05R\nsubChannel\"Z\n\x15TuneToStationResponse\x12&\n\x06statu\
    s\x18\x01\x20\x02(\x0e2\x0e.MessageStatusR\x06status\x12\x19\n\x08radio_\
    id\x18\x02\x20\x02(\x05R\x07radioId\"o\n\x1cRadioStationInfoNotification\
    \x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05R\x07radioId\x124\n\x0cstatio\
    n_info\x18\x02\x20\x02(\x0b2\x11.RadioStationInfoR\x0bstationInfo\"\xa1\
    \x01\n\x10RadioStationInfo\x12\x1e\n\x04type\x18\x01\x20\x02(\x0e2\n.Rad\
    ioTypeR\x04type\x12\x18\n\x07channel\x18\x02\x20\x02(\x05R\x07channel\
    \x12\x1f\n\x0bsub_channel\x18\x03\x20\x01(\x05R\nsubChannel\x122\n\tmeta\
    _data\x18\x04\x20\x01(\x0b2\x15.RadioStationMetaDataR\x08metaData\"\xbd\
    \x01\n\x14RadioStationMetaData\x12%\n\x0eaudio_channels\x18\x01\x20\x01(\
    \x05R\raudioChannels\x12%\n\x0esignal_quality\x18\x02\x20\x01(\x05R\rsig\
    nalQuality\x12\x1a\n\x03rds\x18\x03\x20\x01(\x0b2\x08.RdsDataR\x03rds\
    \x12;\n\x0fhd_station_info\x18\x04\x20\x01(\x0b2\x13.HdRadioStationInfoR\
    \rhdStationInfo\"\x9f\x03\n\x07RdsData\x127\n\x17alternative_frequencies\
    \x18\x01\x20\x03(\x05R\x16alternativeFrequencies\x12\x1d\n\nprogram_id\
    \x18\x02\x20\x01(\x05R\tprogramId\x12.\n\x13music_speech_switch\x18\x03\
    \x20\x01(\x05R\x11musicSpeechSwitch\x120\n\x14program_service_name\x18\
    \x04\x20\x01(\tR\x12programServiceName\x12!\n\x0cprogram_type\x18\x05\
    \x20\x01(\x05R\x0bprogramType\x12*\n\x11program_type_name\x18\x06\x20\
    \x01(\tR\x0fprogramTypeName\x12\x1d\n\nradio_text\x18\x07\x20\x01(\tR\tr\
    adioText\x120\n\x14traffic_program_flag\x18\x08\x20\x01(\x08R\x12traffic\
    ProgramFlag\x12:\n\x19traffic_announcement_flag\x18\t\x20\x01(\x08R\x17t\
    rafficAnnouncementFlag\"\xd2\x01\n\x12HdRadioStationInfo\x12>\n\x11acqui\
    sition_state\x18\x01\x20\x01(\x0e2\x11.HdAcquisionStateR\x10acquisitionS\
    tate\x126\n\x17digital_signal_strength\x18\x02\x20\x01(\x05R\x15digitalS\
    ignalStrength\x12!\n\x03psd\x18\x03\x20\x01(\x0b2\x0f.HdRadioPsdDataR\
    \x03psd\x12!\n\x03sis\x18\x04\x20\x01(\x0b2\x0f.HdRadioSisDataR\x03sis\"\
    \x90\x02\n\x0eHdRadioPsdData\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05t\
    itle\x12\x16\n\x06artist\x18\x02\x20\x01(\tR\x06artist\x12\x14\n\x05albu\
    m\x18\x03\x20\x01(\tR\x05album\x12\x14\n\x05genre\x18\x04\x20\x01(\tR\
    \x05genre\x12)\n\x07comment\x18\x05\x20\x01(\x0b2\x0f.HdRadioCommentR\
    \x07comment\x122\n\ncommercial\x18\x06\x20\x01(\x0b2\x12.HdRadioCommerci\
    alR\ncommercial\x12E\n\x11artist_experience\x18\x07\x20\x01(\x0b2\x18.Hd\
    RadioArtistExperienceR\x10artistExperience\"F\n\x0eHdRadioComment\x12\
    \x20\n\x0bdescription\x18\x01\x20\x01(\tR\x0bdescription\x12\x12\n\x04te\
    xt\x18\x02\x20\x01(\tR\x04text\"\xc3\x01\n\x11HdRadioCommercial\x12\x1a\
    \n\x08encoding\x18\x01\x20\x01(\x05R\x08encoding\x12\x14\n\x05price\x18\
    \x02\x20\x01(\tR\x05price\x12\x14\n\x05valid\x18\x03\x20\x01(\tR\x05vali\
    d\x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12\x1a\n\x08received\x18\
    \x05\x20\x01(\x05R\x08received\x12\x16\n\x06seller\x18\x06\x20\x01(\tR\
    \x06seller\x12\x20\n\x0bdescription\x18\x07\x20\x01(\tR\x0bdescription\"\
    /\n\x17HdRadioArtistExperience\x12\x14\n\x05image\x18\x01\x20\x01(\x0cR\
    \x05image\"\xe8\x02\n\x0eHdRadioSisData\x12\x1d\n\nstation_id\x18\x01\
    \x20\x01(\x05R\tstationId\x12,\n\x12station_name_short\x18\x02\x20\x01(\
    \tR\x10stationNameShort\x12*\n\x11station_name_long\x18\x03\x20\x01(\tR\
    \x0fstationNameLong\x124\n\x10station_location\x18\x04\x20\x01(\x0b2\t.L\
    ocationR\x0fstationLocation\x12'\n\x0fstation_message\x18\x05\x20\x01(\t\
    R\x0estationMessage\x120\n\x14service_info_message\x18\x06\x20\x01(\tR\
    \x12serviceInfoMessage\x12L\n#universal_short_station_name_slogan\x18\
    \x07\x20\x01(\tR\x1funiversalShortStationNameSlogan\"D\n\x08Location\x12\
    \x1c\n\tlongitude\x18\x01\x20\x02(\x01R\tlongitude\x12\x1a\n\x08latitude\
    \x18\x02\x20\x02(\x01R\x08latitude\"2\n\x15GetProgramListRequest\x12\x19\
    \n\x08radio_id\x18\x01\x20\x02(\x05R\x07radioId\"\xaf\x01\n\x16GetProgra\
    mListResponse\x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.MessageStatusR\
    \x06status\x12\x19\n\x08radio_id\x18\x02\x20\x02(\x05R\x07radioId\x12\
    \x1c\n\tcompleted\x18\x03\x20\x02(\x08R\tcompleted\x124\n\x0cprogram_lis\
    t\x18\x04\x20\x03(\x0b2\x11.RadioStationInfoR\x0bprogramList\"9\n\x1cCan\
    celRadioOperationsRequest\x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05R\
    \x07radioId\"b\n\x1dCancelRadioOperationsResponse\x12&\n\x06status\x18\
    \x01\x20\x02(\x0e2\x0e.MessageStatusR\x06status\x12\x19\n\x08radio_id\
    \x18\x02\x20\x02(\x05R\x07radioId\"d\n\x1eConfigureChannelSpacingRequest\
    \x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05R\x07radioId\x12'\n\x0fchanne\
    l_spacing\x18\x02\x20\x02(\x05R\x0echannelSpacing\"\x8d\x01\n\x1fConfigu\
    reChannelSpacingResponse\x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.Mess\
    ageStatusR\x06status\x12\x19\n\x08radio_id\x18\x02\x20\x02(\x05R\x07radi\
    oId\x12'\n\x0fchannel_spacing\x18\x03\x20\x02(\x05R\x0echannelSpacing\"S\
    \n\x1aStationPresetsNotification\x125\n\x0cpreset_lists\x18\x02\x20\x03(\
    \x0b2\x12.StationPresetListR\x0bpresetLists\"\x8b\x01\n\x11StationPreset\
    List\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x128\n\x18restricted_\
    station_types\x18\x02\x20\x03(\x05R\x16restrictedStationTypes\x12(\n\x07\
    presets\x18\x03\x20\x03(\x0b2\x0e.StationPresetR\x07presets\"j\n\rStatio\
    nPreset\x12\x1e\n\x04type\x18\x01\x20\x02(\x0e2\n.RadioTypeR\x04type\x12\
    \x18\n\x07channel\x18\x02\x20\x02(\x05R\x07channel\x12\x1f\n\x0bsub_chan\
    nel\x18\x03\x20\x01(\x05R\nsubChannel\"4\n\x17GetTrafficUpdateRequest\
    \x12\x19\n\x08radio_id\x18\x01\x20\x02(\x05R\x07radioId\"\x8d\x01\n\x18G\
    etTrafficUpdateResponse\x12&\n\x06status\x18\x01\x20\x02(\x0e2\x0e.Messa\
    geStatusR\x06status\x12\x19\n\x08radio_id\x18\x02\x20\x02(\x05R\x07radio\
    Id\x12.\n\tincidents\x18\x03\x20\x03(\x0b2\x10.TrafficIncidentR\tinciden\
    ts\"\x95\x01\n\x0fTrafficIncident\x12\x1d\n\nevent_code\x18\x01\x20\x02(\
    \x05R\teventCode\x12%\n\x08location\x18\x02\x20\x02(\x0b2\t.LocationR\
    \x08location\x12<\n\x1aexpected_incident_duration\x18\x03\x20\x02(\x05R\
    \x18expectedIncidentDuration\"A\n\x10MuteRadioRequest\x12\x19\n\x08radio\
    _id\x18\x01\x20\x01(\x05R\x07radioId\x12\x12\n\x04mute\x18\x02\x20\x02(\
    \x08R\x04mute\"l\n\x11MuteRadioResponse\x12&\n\x06status\x18\x01\x20\x01\
    (\x0e2\x0e.MessageStatusR\x06status\x12\x19\n\x08radio_id\x18\x02\x20\
    \x01(\x05R\x07radioId\x12\x14\n\x05muted\x18\x03\x20\x01(\x08R\x05muted\
    \"\x17\n\x15NavigationStatusStart\"\x16\n\x14NavigationStatusStop\"\xa4\
    \x01\n\x10NavigationStatus\x12>\n\x06status\x18\x01\x20\x02(\x0e2&.Navig\
    ationStatus.NavigationStatusEnumR\x06status\"P\n\x14NavigationStatusEnum\
    \x12\x0f\n\x0bUNAVAILABLE\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\x08I\
    NACTIVE\x10\x02\x12\r\n\tREROUTING\x10\x03\"\xe2\x04\n\x17NavigationNext\
    TurnEvent\x12\x12\n\x04road\x18\x01\x20\x02(\tR\x04road\x12>\n\tturn_sid\
    e\x18\x02\x20\x01(\x0e2!.NavigationNextTurnEvent.TurnSideR\x08turnSide\
    \x12;\n\x05event\x18\x03\x20\x01(\x0e2%.NavigationNextTurnEvent.NextTurn\
    EnumR\x05event\x12\x14\n\x05image\x18\x04\x20\x01(\x0cR\x05image\x12\x1f\
    \n\x0bturn_number\x18\x05\x20\x01(\x05R\nturnNumber\x12\x1d\n\nturn_angl\
    e\x18\x06\x20\x01(\x05R\tturnAngle\"0\n\x08TurnSide\x12\x08\n\x04LEFT\
    \x10\x01\x12\t\n\x05RIGHT\x10\x02\x12\x0f\n\x0bUNSPECIFIED\x10\x03\"\xa9\
    \x02\n\x0cNextTurnEnum\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06DEPART\x10\
    \x01\x12\x0f\n\x0bNAME_CHANGE\x10\x02\x12\x0f\n\x0bSLIGHT_TURN\x10\x03\
    \x12\x08\n\x04TURN\x10\x04\x12\x0e\n\nSHARP_TURN\x10\x05\x12\n\n\x06U_TU\
    RN\x10\x06\x12\x0b\n\x07ON_RAMP\x10\x07\x12\x0c\n\x08OFF_RAMP\x10\x08\
    \x12\x08\n\x04FORK\x10\t\x12\t\n\x05MERGE\x10\n\x12\x14\n\x10ROUNDABOUT_\
    ENTER\x10\x0b\x12\x13\n\x0fROUNDABOUT_EXIT\x10\x0c\x12\x1d\n\x19ROUNDABO\
    UT_ENTER_AND_EXIT\x10\r\x12\x0c\n\x08STRAIGHT\x10\x0e\x12\x0e\n\nFERRY_B\
    OAT\x10\x10\x12\x0f\n\x0bFERRY_TRAIN\x10\x11\x12\x0f\n\x0bDESTINATION\
    \x10\x13:\x02\x18\x01\"\x9d\x03\n\x1fNavigationNextTurnDistanceEvent\x12\
    '\n\x0fdistance_meters\x18\x01\x20\x02(\x05R\x0edistanceMeters\x12/\n\
    \x14time_to_turn_seconds\x18\x02\x20\x02(\x05R\x11timeToTurnSeconds\x12.\
    \n\x13display_distance_e3\x18\x03\x20\x01(\x05R\x11displayDistanceE3\x12\
    b\n\x15display_distance_unit\x18\x04\x20\x01(\x0e2..NavigationNextTurnDi\
    stanceEvent.DistanceUnitsR\x13displayDistanceUnit\"\x87\x01\n\rDistanceU\
    nits\x12\x19\n\x15UNKNOWN_DISTANCE_UNIT\x10\0\x12\n\n\x06METERS\x10\x01\
    \x12\x0e\n\nKILOMETERS\x10\x02\x12\x11\n\rKILOMETERS_P1\x10\x03\x12\t\n\
    \x05MILES\x10\x04\x12\x0c\n\x08MILES_P1\x10\x05\x12\x08\n\x04FEET\x10\
    \x06\x12\t\n\x05YARDS\x10\x07:\x02\x18\x01\"t\n\x0fNavigationState\x12%\
    \n\x05steps\x18\x01\x20\x03(\x0b2\x0f.NavigationStepR\x05steps\x12:\n\
    \x0cdestinations\x18\x02\x20\x03(\x0b2\x16.NavigationDestinationR\x0cdes\
    tinations\"\xaf\x01\n\x0eNavigationStep\x12/\n\x08maneuver\x18\x01\x20\
    \x01(\x0b2\x13.NavigationManeuverR\x08maneuver\x12#\n\x04road\x18\x02\
    \x20\x01(\x0b2\x0f.NavigationRoadR\x04road\x12%\n\x05lanes\x18\x03\x20\
    \x03(\x0b2\x0f.NavigationLaneR\x05lanes\x12\x20\n\x03cue\x18\x04\x20\x01\
    (\x0b2\x0e.NavigationCueR\x03cue\"\x9c\t\n\x12NavigationManeuver\x126\n\
    \x04type\x18\x01\x20\x01(\x0e2\".NavigationManeuver.NavigationTypeR\x04t\
    ype\x124\n\x16roundabout_exit_number\x18\x02\x20\x01(\x05R\x14roundabout\
    ExitNumber\x122\n\x15roundabout_exit_angle\x18\x03\x20\x01(\x05R\x13roun\
    daboutExitAngle\"\xe3\x07\n\x0eNavigationType\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\n\n\x06DEPART\x10\x01\x12\x0f\n\x0bNAME_CHANGE\x10\x02\x12\r\n\tKEE\
    P_LEFT\x10\x03\x12\x0e\n\nKEEP_RIGHT\x10\x04\x12\x14\n\x10TURN_SLIGHT_LE\
    FT\x10\x05\x12\x15\n\x11TURN_SLIGHT_RIGHT\x10\x06\x12\x14\n\x10TURN_NORM\
    AL_LEFT\x10\x07\x12\x15\n\x11TURN_NORMAL_RIGHT\x10\x08\x12\x13\n\x0fTURN\
    _SHARP_LEFT\x10\t\x12\x14\n\x10TURN_SHARP_RIGHT\x10\n\x12\x0f\n\x0bU_TUR\
    N_LEFT\x10\x0b\x12\x10\n\x0cU_TURN_RIGHT\x10\x0c\x12\x17\n\x13ON_RAMP_SL\
    IGHT_LEFT\x10\r\x12\x18\n\x14ON_RAMP_SLIGHT_RIGHT\x10\x0e\x12\x17\n\x13O\
    N_RAMP_NORMAL_LEFT\x10\x0f\x12\x18\n\x14ON_RAMP_NORMAL_RIGHT\x10\x10\x12\
    \x16\n\x12ON_RAMP_SHARP_LEFT\x10\x11\x12\x17\n\x13ON_RAMP_SHARP_RIGHT\
    \x10\x12\x12\x17\n\x13ON_RAMP_U_TURN_LEFT\x10\x13\x12\x18\n\x14ON_RAMP_U\
    _TURN_RIGHT\x10\x14\x12\x18\n\x14OFF_RAMP_SLIGHT_LEFT\x10\x15\x12\x19\n\
    \x15OFF_RAMP_SLIGHT_RIGHT\x10\x16\x12\x18\n\x14OFF_RAMP_NORMAL_LEFT\x10\
    \x17\x12\x19\n\x15OFF_RAMP_NORMAL_RIGHT\x10\x18\x12\r\n\tFORK_LEFT\x10\
    \x19\x12\x0e\n\nFORK_RIGHT\x10\x1a\x12\x0e\n\nMERGE_LEFT\x10\x1b\x12\x0f\
    \n\x0bMERGE_RIGHT\x10\x1c\x12\x1a\n\x16MERGE_SIDE_UNSPECIFIED\x10\x1d\
    \x12\x14\n\x10ROUNDABOUT_ENTER\x10\x1e\x12\x13\n\x0fROUNDABOUT_EXIT\x10\
    \x1f\x12\x20\n\x1cROUNDABOUT_ENTER_AND_EXIT_CW\x10\x20\x12+\n'ROUNDABOUT\
    _ENTER_AND_EXIT_CW_WITH_ANGLE\x10!\x12!\n\x1dROUNDABOUT_ENTER_AND_EXIT_C\
    CW\x10\"\x12,\n(ROUNDABOUT_ENTER_AND_EXIT_CCW_WITH_ANGLE\x10#\x12\x0c\n\
    \x08STRAIGHT\x10$\x12\x0e\n\nFERRY_BOAT\x10%\x12\x0f\n\x0bFERRY_TRAIN\
    \x10&\x12\x0f\n\x0bDESTINATION\x10'\x12\x18\n\x14DESTINATION_STRAIGHT\
    \x10(\x12\x14\n\x10DESTINATION_LEFT\x10)\x12\x15\n\x11DESTINATION_RIGHT\
    \x10*\"6\n\rNavigationCue\x12%\n\x0ealternate_text\x18\x01\x20\x03(\tR\r\
    alternateText\"\xfb\x02\n\x0eNavigationLane\x12F\n\x0flane_directions\
    \x18\x01\x20\x03(\x0b2\x1d.NavigationLane.LaneDirectionR\x0elaneDirectio\
    ns\x1a\xa0\x02\n\rLaneDirection\x129\n\x05shape\x18\x01\x20\x01(\x0e2#.N\
    avigationLane.LaneDirection.ShapeR\x05shape\x12%\n\x0eis_highlighted\x18\
    \x02\x20\x01(\x08R\risHighlighted\"\xac\x01\n\x05Shape\x12\x0b\n\x07UNKN\
    OWN\x10\0\x12\x0c\n\x08STRAIGHT\x10\x01\x12\x0f\n\x0bSLIGHT_LEFT\x10\x02\
    \x12\x10\n\x0cSLIGHT_RIGHT\x10\x03\x12\x0f\n\x0bNORMAL_LEFT\x10\x04\x12\
    \x10\n\x0cNORMAL_RIGHT\x10\x05\x12\x0e\n\nSHARP_LEFT\x10\x06\x12\x0f\n\
    \x0bSHARP_RIGHT\x10\x07\x12\x0f\n\x0bU_TURN_LEFT\x10\x08\x12\x10\n\x0cU_\
    TURN_RIGHT\x10\t\"1\n\x15NavigationDestination\x12\x18\n\x07address\x18\
    \x01\x20\x01(\tR\x07address\"\xe2\x01\n\x19NavigationCurrentPosition\x12\
    <\n\rstep_distance\x18\x01\x20\x01(\x0b2\x17.NavigationStepDistanceR\x0c\
    stepDistance\x12S\n\x15destination_distances\x18\x02\x20\x03(\x0b2\x1e.N\
    avigationDestinationDistanceR\x14destinationDistances\x122\n\x0ccurrent_\
    road\x18\x03\x20\x01(\x0b2\x0f.NavigationRoadR\x0bcurrentRoad\"z\n\x16Na\
    vigationStepDistance\x12/\n\x08distance\x18\x01\x20\x01(\x0b2\x13.Naviga\
    tionDistanceR\x08distance\x12/\n\x14time_to_step_seconds\x18\x02\x20\x01\
    (\x03R\x11timeToStepSeconds\"\xc2\x01\n\x1dNavigationDestinationDistance\
    \x12/\n\x08distance\x18\x01\x20\x01(\x0b2\x13.NavigationDistanceR\x08dis\
    tance\x129\n\x19estimated_time_at_arrival\x18\x02\x20\x01(\tR\x16estimat\
    edTimeAtArrival\x125\n\x17time_to_arrival_seconds\x18\x03\x20\x01(\x03R\
    \x14timeToArrivalSeconds\"$\n\x0eNavigationRoad\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"\xa3\x02\n\x12NavigationDistance\x12\x16\n\x06\
    meters\x18\x01\x20\x01(\x05R\x06meters\x12#\n\rdisplay_value\x18\x02\x20\
    \x01(\tR\x0cdisplayValue\x12F\n\rdisplay_units\x18\x03\x20\x01(\x0e2!.Na\
    vigationDistance.DistanceUnitsR\x0cdisplayUnits\"\x87\x01\n\rDistanceUni\
    ts\x12\x19\n\x15UNKNOWN_DISTANCE_UNIT\x10\0\x12\n\n\x06METERS\x10\x01\
    \x12\x0e\n\nKILOMETERS\x10\x02\x12\x11\n\rKILOMETERS_P1\x10\x03\x12\t\n\
    \x05MILES\x10\x04\x12\x0c\n\x08MILES_P1\x10\x05\x12\x08\n\x04FEET\x10\
    \x06\x12\t\n\x05YARDS\x10\x07\"\xcf\x01\n\x16InstrumentClusterInput\x12G\
    \n\x06action\x18\x01\x20\x02(\x0e2/.InstrumentClusterInput.InstrumentClu\
    sterActionR\x06action\"l\n\x17InstrumentClusterAction\x12\x0b\n\x07UNKNO\
    WN\x10\0\x12\x06\n\x02UP\x10\x01\x12\x08\n\x04DOWN\x10\x02\x12\x08\n\x04\
    LEFT\x10\x03\x12\t\n\x05RIGHT\x10\x04\x12\t\n\x05ENTER\x10\x05\x12\x08\n\
    \x04BACK\x10\x06\x12\x08\n\x04CALL\x10\x07\"\x95\x02\n\x13MediaPlaybackS\
    tatus\x120\n\x05state\x18\x01\x20\x01(\x0e2\x1a.MediaPlaybackStatus.Stat\
    eR\x05state\x12!\n\x0cmedia_source\x18\x02\x20\x01(\tR\x0bmediaSource\
    \x12)\n\x10playback_seconds\x18\x03\x20\x01(\rR\x0fplaybackSeconds\x12\
    \x18\n\x07shuffle\x18\x04\x20\x01(\x08R\x07shuffle\x12\x16\n\x06repeat\
    \x18\x05\x20\x01(\x08R\x06repeat\x12\x1d\n\nrepeat_one\x18\x06\x20\x01(\
    \x08R\trepeatOne\"-\n\x05State\x12\x0b\n\x07STOPPED\x10\x01\x12\x0b\n\
    \x07PLAYING\x10\x02\x12\n\n\x06PAUSED\x10\x03\"\xd5\x01\n\x15MediaPlayba\
    ckMetadata\x12\x12\n\x04song\x18\x01\x20\x01(\tR\x04song\x12\x16\n\x06ar\
    tist\x18\x02\x20\x01(\tR\x06artist\x12\x14\n\x05album\x18\x03\x20\x01(\t\
    R\x05album\x12\x1b\n\talbum_art\x18\x04\x20\x01(\x0cR\x08albumArt\x12\
    \x1a\n\x08playlist\x18\x05\x20\x01(\tR\x08playlist\x12)\n\x10duration_se\
    conds\x18\x06\x20\x01(\rR\x0fdurationSeconds\x12\x16\n\x06rating\x18\x07\
    \x20\x01(\x05R\x06rating\"\xd4\x03\n\x0bPhoneStatus\x12'\n\x05calls\x18\
    \x01\x20\x03(\x0b2\x11.PhoneStatus.CallR\x05calls\x12'\n\x0fsignal_stren\
    gth\x18\x02\x20\x01(\rR\x0esignalStrength\x1a\x8a\x02\n\x04Call\x123\n\
    \x0bphone_state\x18\x01\x20\x02(\x0e2\x12.PhoneStatus.StateR\nphoneState\
    \x122\n\x15call_duration_seconds\x18\x02\x20\x02(\rR\x13callDurationSeco\
    nds\x12#\n\rcaller_number\x18\x03\x20\x01(\tR\x0ccallerNumber\x12\x1b\n\
    \tcaller_id\x18\x04\x20\x01(\tR\x08callerId\x12,\n\x12caller_number_type\
    \x18\x05\x20\x01(\tR\x10callerNumberType\x12)\n\x10caller_thumbnail\x18\
    \x06\x20\x01(\x0cR\x0fcallerThumbnail\"f\n\x05State\x12\x0b\n\x07UNKNOWN\
    \x10\0\x12\x0b\n\x07IN_CALL\x10\x01\x12\x0b\n\x07ON_HOLD\x10\x02\x12\x0c\
    \n\x08INACTIVE\x10\x03\x12\x0c\n\x08INCOMING\x10\x04\x12\x0f\n\x0bCONFER\
    ENCED\x10\x05\x12\t\n\x05MUTED\x10\x06\"\x83\x01\n\x10PhoneStatusInput\
    \x12-\n\x05input\x18\x01\x20\x02(\x0b2\x17.InstrumentClusterInputR\x05in\
    put\x12#\n\rcaller_number\x18\x02\x20\x01(\tR\x0ccallerNumber\x12\x1b\n\
    \tcaller_id\x18\x03\x20\x01(\tR\x08callerId\"V\n\rMediaRootNode\x12\x12\
    \n\x04path\x18\x01\x20\x02(\tR\x04path\x121\n\rmedia_sources\x18\x02\x20\
    \x03(\x0b2\x0c.MediaSourceR\x0cmediaSources\"R\n\x0bMediaSource\x12\x12\
    \n\x04path\x18\x01\x20\x02(\tR\x04path\x12\x12\n\x04name\x18\x02\x20\x02\
    (\tR\x04name\x12\x1b\n\talbum_art\x18\x03\x20\x01(\x0cR\x08albumArt\"\
    \x85\x01\n\x0fMediaSourceNode\x12$\n\x06source\x18\x01\x20\x02(\x0b2\x0c\
    .MediaSourceR\x06source\x12\x14\n\x05start\x18\x02\x20\x01(\x05R\x05star\
    t\x12\x14\n\x05total\x18\x03\x20\x01(\x05R\x05total\x12\x20\n\x05lists\
    \x18\x04\x20\x03(\x0b2\n.MediaListR\x05lists\"\xc7\x01\n\tMediaList\x12\
    \x12\n\x04path\x18\x01\x20\x02(\tR\x04path\x12#\n\x04type\x18\x02\x20\
    \x02(\x0e2\x0f.MediaList.TypeR\x04type\x12\x12\n\x04name\x18\x03\x20\x01\
    (\tR\x04name\x12\x1b\n\talbum_art\x18\x04\x20\x01(\x0cR\x08albumArt\"P\n\
    \x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0c\n\x08PLAYLIST\x10\x01\x12\t\
    \n\x05ALBUM\x10\x02\x12\n\n\x06ARTIST\x10\x03\x12\x0b\n\x07STATION\x10\
    \x04\x12\t\n\x05GENRE\x10\x05\"}\n\rMediaListNode\x12\x1e\n\x04list\x18\
    \x01\x20\x02(\x0b2\n.MediaListR\x04list\x12\x14\n\x05start\x18\x02\x20\
    \x01(\x05R\x05start\x12\x14\n\x05total\x18\x03\x20\x01(\x05R\x05total\
    \x12\x20\n\x05songs\x18\x04\x20\x03(\x0b2\n.MediaSongR\x05songs\"a\n\tMe\
    diaSong\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\x12\x12\n\x04name\
    \x18\x02\x20\x02(\tR\x04name\x12\x16\n\x06artist\x18\x03\x20\x01(\tR\x06\
    artist\x12\x14\n\x05album\x18\x04\x20\x01(\tR\x05album\"w\n\rMediaSongNo\
    de\x12\x1e\n\x04song\x18\x01\x20\x02(\x0b2\n.MediaSongR\x04song\x12\x1b\
    \n\talbum_art\x18\x02\x20\x01(\x0cR\x08albumArt\x12)\n\x10duration_secon\
    ds\x18\x03\x20\x01(\rR\x0fdurationSeconds\"b\n\x0cMediaGetNode\x12\x12\n\
    \x04path\x18\x01\x20\x02(\tR\x04path\x12\x14\n\x05start\x18\x02\x20\x01(\
    \x05R\x05start\x12(\n\rget_album_art\x18\x03\x20\x01(\x08:\x04trueR\x0bg\
    etAlbumArt\"V\n\x11MediaBrowserInput\x12-\n\x05input\x18\x01\x20\x02(\
    \x0b2\x17.InstrumentClusterInputR\x05input\x12\x12\n\x04path\x18\x02\x20\
    \x02(\tR\x04path\"B\n\x18GalVerificationSetSensor\x12&\n\x07sensors\x18\
    \x01\x20\x01(\x0b2\x0c.SensorBatchR\x07sensors\"b\n\x1eGalVerificationMe\
    diaSinkStatus\x12\x18\n\x07channel\x18\x01\x20\x02(\x05R\x07channel\x12&\
    \n\x06status\x18\x02\x20\x02(\x0e2\x0e.Config.StatusR\x06status\"\x8c\
    \x01\n\x19GalVerificationVideoFocus\x129\n\x10video_focus_mode\x18\x01\
    \x20\x02(\x0e2\x0f.VideoFocusModeR\x0evideoFocusMode\x12\x12\n\x04deny\
    \x18\x02\x20\x01(\x08R\x04deny\x12\x20\n\x0bunsolicited\x18\x03\x20\x01(\
    \x08R\x0bunsolicited\"\x99\x01\n\x19GalVerificationAudioFocus\x12@\n\x11\
    audio_focus_state\x18\x01\x20\x02(\x0e2\x14.AudioFocusStateTypeR\x0faudi\
    oFocusState\x12\x18\n\x07channel\x18\x02\x20\x02(\x05R\x07channel\x12\
    \x20\n\x0bunsolicited\x18\x03\x20\x01(\x08R\x0bunsolicited\"@\n\x1aGalVe\
    rificationInjectInput\x12\"\n\x05input\x18\x01\x20\x02(\x0b2\x0c.InputRe\
    portR\x05input\"!\n\x1fGalVerificationBugReportRequest\"A\n\x20GalVerifi\
    cationBugReportResponse\x12\x1d\n\nbug_report\x18\x01\x20\x02(\tR\tbugRe\
    port\"%\n#GalVerificationScreenCaptureRequest\"M\n$GalVerificationScreen\
    CaptureResponse\x12%\n\x0escreen_capture\x18\x01\x20\x02(\x0cR\rscreenCa\
    pture\"*\n(GalVerificationDisplayInformationRequest\"s\n)GalVerification\
    DisplayInformationResponse\x12!\n\x0cnative_width\x18\x01\x20\x02(\x05R\
    \x0bnativeWidth\x12#\n\rnative_height\x18\x02\x20\x02(\x05R\x0cnativeHei\
    ght\"\x1e\n\x1cGenericNotificationSubscribe\"\x20\n\x1eGenericNotificati\
    onUnsubscribe\"T\n\x1aGenericNotificationMessage\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\x12\x12\
    \n\x04icon\x18\x03\x20\x01(\x0cR\x04icon\"B\n\x16GenericNotificationAck\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x18\n\x07handled\x18\x02\
    \x20\x01(\x08R\x07handled\"9\n!GoogleDiagnosticsBugReportRequest\x12\x14\
    \n\x05token\x18\x01\x20\x02(\x05R\x05token\"[\n\"GoogleDiagnosticsBugRep\
    ortResponse\x12\x1d\n\nbug_report\x18\x01\x20\x01(\tR\tbugReport\x12\x16\
    \n\x06tokens\x18\x02\x20\x03(\x05R\x06tokens*\xb1\x07\n\x12ControlMessag\
    eType\x12\x1b\n\x17MESSAGE_VERSION_REQUEST\x10\x01\x12\x1c\n\x18MESSAGE_\
    VERSION_RESPONSE\x10\x02\x12\x1c\n\x18MESSAGE_ENCAPSULATED_SSL\x10\x03\
    \x12\x19\n\x15MESSAGE_AUTH_COMPLETE\x10\x04\x12%\n!MESSAGE_SERVICE_DISCO\
    VERY_REQUEST\x10\x05\x12&\n\"MESSAGE_SERVICE_DISCOVERY_RESPONSE\x10\x06\
    \x12\x20\n\x1cMESSAGE_CHANNEL_OPEN_REQUEST\x10\x07\x12!\n\x1dMESSAGE_CHA\
    NNEL_OPEN_RESPONSE\x10\x08\x12&\n\"MESSAGE_CHANNEL_CLOSE_NOTIFICATION\
    \x10\t\x12\x18\n\x14MESSAGE_PING_REQUEST\x10\x0b\x12\x19\n\x15MESSAGE_PI\
    NG_RESPONSE\x10\x0c\x12\x1d\n\x19MESSAGE_NAV_FOCUS_REQUEST\x10\r\x12\"\n\
    \x1eMESSAGE_NAV_FOCUS_NOTIFICATION\x10\x0e\x12\x1a\n\x16MESSAGE_BYEBYE_R\
    EQUEST\x10\x0f\x12\x1b\n\x17MESSAGE_BYEBYE_RESPONSE\x10\x10\x12&\n\"MESS\
    AGE_VOICE_SESSION_NOTIFICATION\x10\x11\x12\x1f\n\x1bMESSAGE_AUDIO_FOCUS_\
    REQUEST\x10\x12\x12$\n\x20MESSAGE_AUDIO_FOCUS_NOTIFICATION\x10\x13\x12)\
    \n%MESSAGE_CAR_CONNECTED_DEVICES_REQUEST\x10\x14\x12*\n&MESSAGE_CAR_CONN\
    ECTED_DEVICES_RESPONSE\x10\x15\x12\x1f\n\x1bMESSAGE_USER_SWITCH_REQUEST\
    \x10\x16\x12'\n#MESSAGE_BATTERY_STATUS_NOTIFICATION\x10\x17\x12$\n\x20ME\
    SSAGE_CALL_AVAILABILITY_STATUS\x10\x18\x12\x20\n\x1cMESSAGE_USER_SWITCH_\
    RESPONSE\x10\x19\x12$\n\x20MESSAGE_SERVICE_DISCOVERY_UPDATE\x10\x1a\x12\
    \x1f\n\x1aMESSAGE_UNEXPECTED_MESSAGE\x10\xff\x01\x12\x1b\n\x15MESSAGE_FR\
    AMING_ERROR\x10\xff\xff\x03*W\n\x08FragInfo\x12\x15\n\x11FRAG_CONTINUATI\
    ON\x10\0\x12\x0e\n\nFRAG_FIRST\x10\x01\x12\r\n\tFRAG_LAST\x10\x02\x12\
    \x15\n\x11FRAG_UNFRAGMENTED\x10\x03*~\n\x0eDriverPosition\x12\x18\n\x14D\
    RIVER_POSITION_LEFT\x10\0\x12\x19\n\x15DRIVER_POSITION_RIGHT\x10\x01\x12\
    \x1a\n\x16DRIVER_POSITION_CENTER\x10\x02\x12\x1b\n\x17DRIVER_POSITION_UN\
    KNOWN\x10\x03*\x98\x01\n\x14SessionConfiguration\x12\x18\n\x14UI_CONFIG_\
    HIDE_CLOCK\x10\x01\x12\x1f\n\x1bUI_CONFIG_HIDE_PHONE_SIGNAL\x10\x02\x12\
    \x20\n\x1cUI_CONFIG_HIDE_BATTERY_LEVEL\x10\x04\x12#\n\x1fCAN_PLAY_NATIVE\
    _MEDIA_DURING_VR\x10\x08*\xe3\x01\n\x18LocationCharacterization\x12\x13\
    \n\x0fPRIOR_LOCATIONS\x10\x01\x12\x14\n\x10GYROSCOPE_FUSION\x10\x02\x12\
    \x18\n\x14ACCELEROMETER_FUSION\x10\x04\x12\x12\n\x0eCOMPASS_FUSION\x10\
    \x08\x12\x16\n\x12WHEEL_SPEED_FUSION\x10\x10\x12\x19\n\x15STEERING_ANGLE\
    _FUSION\x10\x20\x12\x14\n\x10CAR_SPEED_FUSION\x10@\x12\x12\n\rDEAD_RECKO\
    NED\x10\x80\x01\x12\x11\n\x0cRAW_GPS_ONLY\x10\x80\x02*\xaa\x04\n\nSensor\
    Type\x12\x13\n\x0fSENSOR_LOCATION\x10\x01\x12\x12\n\x0eSENSOR_COMPASS\
    \x10\x02\x12\x10\n\x0cSENSOR_SPEED\x10\x03\x12\x0e\n\nSENSOR_RPM\x10\x04\
    \x12\x13\n\x0fSENSOR_ODOMETER\x10\x05\x12\x0f\n\x0bSENSOR_FUEL\x10\x06\
    \x12\x18\n\x14SENSOR_PARKING_BRAKE\x10\x07\x12\x0f\n\x0bSENSOR_GEAR\x10\
    \x08\x12\x20\n\x1cSENSOR_OBDII_DIAGNOSTIC_CODE\x10\t\x12\x15\n\x11SENSOR\
    _NIGHT_MODE\x10\n\x12\x1b\n\x17SENSOR_ENVIRONMENT_DATA\x10\x0b\x12\x14\n\
    \x10SENSOR_HVAC_DATA\x10\x0c\x12\x1e\n\x1aSENSOR_DRIVING_STATUS_DATA\x10\
    \r\x12\x1e\n\x1aSENSOR_DEAD_RECKONING_DATA\x10\x0e\x12\x19\n\x15SENSOR_P\
    ASSENGER_DATA\x10\x0f\x12\x14\n\x10SENSOR_DOOR_DATA\x10\x10\x12\x15\n\
    \x11SENSOR_LIGHT_DATA\x10\x11\x12\x1d\n\x19SENSOR_TIRE_PRESSURE_DATA\x10\
    \x12\x12\x1d\n\x19SENSOR_ACCELEROMETER_DATA\x10\x13\x12\x19\n\x15SENSOR_\
    GYROSCOPE_DATA\x10\x14\x12\x1d\n\x19SENSOR_GPS_SATELLITE_DATA\x10\x15\
    \x12\x14\n\x10SENSOR_TOLL_CARD\x10\x16*\xa9\x02\n\x08FuelType\x12\x15\n\
    \x11FUEL_TYPE_UNKNOWN\x10\0\x12\x16\n\x12FUEL_TYPE_UNLEADED\x10\x01\x12\
    \x14\n\x10FUEL_TYPE_LEADED\x10\x02\x12\x16\n\x12FUEL_TYPE_DIESEL_1\x10\
    \x03\x12\x16\n\x12FUEL_TYPE_DIESEL_2\x10\x04\x12\x17\n\x13FUEL_TYPE_BIOD\
    IESEL\x10\x05\x12\x11\n\rFUEL_TYPE_E85\x10\x06\x12\x11\n\rFUEL_TYPE_LPG\
    \x10\x07\x12\x11\n\rFUEL_TYPE_CNG\x10\x08\x12\x11\n\rFUEL_TYPE_LNG\x10\t\
    \x12\x16\n\x12FUEL_TYPE_ELECTRIC\x10\n\x12\x16\n\x12FUEL_TYPE_HYDROGEN\
    \x10\x0b\x12\x13\n\x0fFUEL_TYPE_OTHER\x10\x0c*\xfc\x02\n\x0fEvConnectorT\
    ype\x12\x1d\n\x19EV_CONNECTOR_TYPE_UNKNOWN\x10\0\x12\x1b\n\x17EV_CONNECT\
    OR_TYPE_J1772\x10\x01\x12\x1e\n\x1aEV_CONNECTOR_TYPE_MENNEKES\x10\x02\
    \x12\x1d\n\x19EV_CONNECTOR_TYPE_CHADEMO\x10\x03\x12\x1d\n\x19EV_CONNECTO\
    R_TYPE_COMBO_1\x10\x04\x12\x1d\n\x19EV_CONNECTOR_TYPE_COMBO_2\x10\x05\
    \x12(\n\x20EV_CONNECTOR_TYPE_TESLA_ROADSTER\x10\x06\x1a\x02\x08\x01\x12$\
    \n\x1cEV_CONNECTOR_TYPE_TESLA_HPWC\x10\x07\x1a\x02\x08\x01\x12(\n$EV_CON\
    NECTOR_TYPE_TESLA_SUPERCHARGER\x10\x08\x12\x19\n\x15EV_CONNECTOR_TYPE_GB\
    T\x10\t\x12\x1b\n\x17EV_CONNECTOR_TYPE_OTHER\x10e*\xd3\x01\n\x18VideoCod\
    ecResolutionType\x12\x11\n\rVIDEO_800x480\x10\x01\x12\x12\n\x0eVIDEO_128\
    0x720\x10\x02\x12\x13\n\x0fVIDEO_1920x1080\x10\x03\x12\x13\n\x0fVIDEO_25\
    60x1440\x10\x04\x12\x13\n\x0fVIDEO_3840x2160\x10\x05\x12\x12\n\x0eVIDEO_\
    720x1280\x10\x06\x12\x13\n\x0fVIDEO_1080x1920\x10\x07\x12\x13\n\x0fVIDEO\
    _1440x2560\x10\x08\x12\x13\n\x0fVIDEO_2160x3840\x10\t*8\n\x12VideoFrameR\
    ateType\x12\x10\n\x0cVIDEO_FPS_60\x10\x01\x12\x10\n\x0cVIDEO_FPS_30\x10\
    \x02*\xdd\x01\n\x0eMediaCodecType\x12\x19\n\x15MEDIA_CODEC_AUDIO_PCM\x10\
    \x01\x12\x1c\n\x18MEDIA_CODEC_AUDIO_AAC_LC\x10\x02\x12\x1d\n\x19MEDIA_CO\
    DEC_VIDEO_H264_BP\x10\x03\x12!\n\x1dMEDIA_CODEC_AUDIO_AAC_LC_ADTS\x10\
    \x04\x12\x19\n\x15MEDIA_CODEC_VIDEO_VP9\x10\x05\x12\x19\n\x15MEDIA_CODEC\
    _VIDEO_AV1\x10\x06\x12\x1a\n\x16MEDIA_CODEC_VIDEO_H265\x10\x07*\x7f\n\
    \x0fAudioStreamType\x12\x19\n\x15AUDIO_STREAM_GUIDANCE\x10\x01\x12\x1d\n\
    \x19AUDIO_STREAM_SYSTEM_AUDIO\x10\x02\x12\x16\n\x12AUDIO_STREAM_MEDIA\
    \x10\x03\x12\x1a\n\x16AUDIO_STREAM_TELEPHONY\x10\x04*Z\n\x0bDisplayType\
    \x12\x15\n\x11DISPLAY_TYPE_MAIN\x10\0\x12\x18\n\x14DISPLAY_TYPE_CLUSTER\
    \x10\x01\x12\x1a\n\x16DISPLAY_TYPE_AUXILIARY\x10\x02*H\n\x07UiTheme\x12\
    \x16\n\x12UI_THEME_AUTOMATIC\x10\0\x12\x12\n\x0eUI_THEME_LIGHT\x10\x01\
    \x12\x11\n\rUI_THEME_DARK\x10\x02*>\n\x0fTouchScreenType\x12\x0e\n\nCAPA\
    CITIVE\x10\x01\x12\r\n\tRESISTIVE\x10\x02\x12\x0c\n\x08INFRARED\x10\x03*\
    \xc9\x01\n\x16BluetoothPairingMethod\x12*\n\x1dBLUETOOTH_PAIRING_UNAVAIL\
    ABLE\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x19\n\x15BLUETOOTH_\
    PAIRING_OOB\x10\x01\x12(\n$BLUETOOTH_PAIRING_NUMERIC_COMPARISON\x10\x02\
    \x12#\n\x1fBLUETOOTH_PAIRING_PASSKEY_ENTRY\x10\x03\x12\x19\n\x15BLUETOOT\
    H_PAIRING_PIN\x10\x04*E\n\x12TrafficServiceType\x12\x16\n\x12NO_TRAFFIC_\
    SERVICE\x10\0\x12\x17\n\x13TMC_TRAFFIC_SERVICE\x10\x01*(\n\x07RdsType\
    \x12\n\n\x06NO_RDS\x10\0\x12\x07\n\x03RDS\x10\x01\x12\x08\n\x04RBDS\x10\
    \x02*f\n\tRadioType\x12\x0c\n\x08AM_RADIO\x10\0\x12\x0c\n\x08FM_RADIO\
    \x10\x01\x12\x0f\n\x0bAM_HD_RADIO\x10\x02\x12\x0f\n\x0bFM_HD_RADIO\x10\
    \x03\x12\r\n\tDAB_RADIO\x10\x04\x12\x0c\n\x08XM_RADIO\x10\x05*\x99\x01\n\
    \tItuRegion\x12\x15\n\x11RADIO_REGION_NONE\x10\0\x12\x16\n\x12RADIO_REGI\
    ON_ITU_1\x10\x01\x12\x16\n\x12RADIO_REGION_ITU_2\x10\x02\x12\x15\n\x11RA\
    DIO_REGION_OIRT\x10\x03\x12\x16\n\x12RADIO_REGION_JAPAN\x10\x04\x12\x16\
    \n\x12RADIO_REGION_KOREA\x10\x05*=\n\x0cNavFocusType\x12\x14\n\x10NAV_FO\
    CUS_NATIVE\x10\x01\x12\x17\n\x13NAV_FOCUS_PROJECTED\x10\x02*z\n\x0cByeBy\
    eReason\x12\x12\n\x0eUSER_SELECTION\x10\x01\x12\x11\n\rDEVICE_SWITCH\x10\
    \x02\x12\x11\n\rNOT_SUPPORTED\x10\x03\x12\x1b\n\x17NOT_CURRENTLY_SUPPORT\
    ED\x10\x04\x12\x13\n\x0fPROBE_SUPPORTED\x10\x05*D\n\x12VoiceSessionStatu\
    s\x12\x17\n\x13VOICE_SESSION_START\x10\x01\x12\x15\n\x11VOICE_SESSION_EN\
    D\x10\x02*\xa1\x03\n\x10UserSwitchStatus\x12\r\n\tSTATUS_OK\x10\0\x12'\n\
    \x1aERROR_NO_RFCOMM_CONNECTION\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\
    \x01\x12)\n\x1cERROR_BT_CLOSED_BEFORE_START\x10\xfe\xff\xff\xff\xff\xff\
    \xff\xff\xff\x01\x12(\n\x1bERROR_BT_CLOSED_AFTER_START\x10\xfd\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01\x126\n)ERROR_INCOMPATIBLE_PHONE_PROTOCOL_VE\
    RSION\x10\xfc\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12/\n\"ERROR_PHONE_UN\
    ABLE_TO_CONNECT_WIFI\x10\xfb\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12/\n\
    \"ERROR_MULTIPLE_USER_SWITCH_REQUEST\x10\xfa\xff\xff\xff\xff\xff\xff\xff\
    \xff\x01\x12\x1e\n\x11ERROR_HU_INTERNAL\x10\xf9\xff\xff\xff\xff\xff\xff\
    \xff\xff\x01\x12\"\n\x15ERROR_INVALID_REQUEST\x10\xf8\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12\"\n\x15ERROR_REQUEST_TIMEOUT\x10\xf7\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01*X\n\x0fSensorErrorType\x12\r\n\tSENSOR_OK\
    \x10\x01\x12\x1a\n\x16SENSOR_ERROR_TRANSIENT\x10\x02\x12\x1a\n\x16SENSOR\
    _ERROR_PERMANENT\x10\x03*\xc2\x01\n\x04Gear\x12\x10\n\x0cGEAR_NEUTRAL\
    \x10\0\x12\n\n\x06GEAR_1\x10\x01\x12\n\n\x06GEAR_2\x10\x02\x12\n\n\x06GE\
    AR_3\x10\x03\x12\n\n\x06GEAR_4\x10\x04\x12\n\n\x06GEAR_5\x10\x05\x12\n\n\
    \x06GEAR_6\x10\x06\x12\n\n\x06GEAR_7\x10\x07\x12\n\n\x06GEAR_8\x10\x08\
    \x12\n\n\x06GEAR_9\x10\t\x12\x0b\n\x07GEAR_10\x10\n\x12\x0e\n\nGEAR_DRIV\
    E\x10d\x12\r\n\tGEAR_PARK\x10e\x12\x10\n\x0cGEAR_REVERSE\x10f*\xce\x01\n\
    \rDrivingStatus\x12\x1d\n\x19DRIVE_STATUS_UNRESTRICTED\x10\0\x12\x19\n\
    \x15DRIVE_STATUS_NO_VIDEO\x10\x01\x12\"\n\x1eDRIVE_STATUS_NO_KEYBOARD_IN\
    PUT\x10\x02\x12\x1f\n\x1bDRIVE_STATUS_NO_VOICE_INPUT\x10\x04\x12\x1a\n\
    \x16DRIVE_STATUS_NO_CONFIG\x10\x08\x12\"\n\x1eDRIVE_STATUS_LIMIT_MESSAGE\
    _LEN\x10\x10*^\n\x0eHeadLightState\x12\x18\n\x14HEAD_LIGHT_STATE_OFF\x10\
    \x01\x12\x17\n\x13HEAD_LIGHT_STATE_ON\x10\x02\x12\x19\n\x15HEAD_LIGHT_ST\
    ATE_HIGH\x10\x03*`\n\x12TurnIndicatorState\x12\x17\n\x13TURN_INDICATOR_N\
    ONE\x10\x01\x12\x17\n\x13TURN_INDICATOR_LEFT\x10\x02\x12\x18\n\x14TURN_I\
    NDICATOR_RIGHT\x10\x03*\x86\x01\n\x0fSensorMessageId\x12\x1c\n\x16SENSOR\
    _MESSAGE_REQUEST\x10\x81\x80\x02\x12\x1d\n\x17SENSOR_MESSAGE_RESPONSE\
    \x10\x82\x80\x02\x12\x1a\n\x14SENSOR_MESSAGE_BATCH\x10\x83\x80\x02\x12\
    \x1a\n\x14SENSOR_MESSAGE_ERROR\x10\x84\x80\x02*H\n\x10VideoFocusReason\
    \x12\x0b\n\x07UNKNOWN\x10\0\x12\x14\n\x10PHONE_SCREEN_OFF\x10\x01\x12\
    \x11\n\rLAUNCH_NATIVE\x10\x02*\x8f\x01\n\x0eVideoFocusMode\x12\x19\n\x15\
    VIDEO_FOCUS_PROJECTED\x10\x01\x12\x16\n\x12VIDEO_FOCUS_NATIVE\x10\x02\
    \x12\x20\n\x1cVIDEO_FOCUS_NATIVE_TRANSIENT\x10\x03\x12(\n$VIDEO_FOCUS_PR\
    OJECTED_NO_INPUT_FOCUS\x10\x04*\x8f\x01\n\x15AudioFocusRequestType\x12\
    \x14\n\x10AUDIO_FOCUS_GAIN\x10\x01\x12\x1e\n\x1aAUDIO_FOCUS_GAIN_TRANSIE\
    NT\x10\x02\x12'\n#AUDIO_FOCUS_GAIN_TRANSIENT_MAY_DUCK\x10\x03\x12\x17\n\
    \x13AUDIO_FOCUS_RELEASE\x10\x04*\xc2\x02\n\x13AudioFocusStateType\x12\
    \x1d\n\x19AUDIO_FOCUS_STATE_INVALID\x10\0\x12\x1a\n\x16AUDIO_FOCUS_STATE\
    _GAIN\x10\x01\x12$\n\x20AUDIO_FOCUS_STATE_GAIN_TRANSIENT\x10\x02\x12\x1a\
    \n\x16AUDIO_FOCUS_STATE_LOSS\x10\x03\x12-\n)AUDIO_FOCUS_STATE_LOSS_TRANS\
    IENT_CAN_DUCK\x10\x04\x12$\n\x20AUDIO_FOCUS_STATE_LOSS_TRANSIENT\x10\x05\
    \x12%\n!AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY\x10\x06\x122\n.AUDIO_FOCUS_STA\
    TE_GAIN_TRANSIENT_GUIDANCE_ONLY\x10\x07*\x81\x04\n\x0eMediaMessageId\x12\
    \x16\n\x12MEDIA_MESSAGE_DATA\x10\0\x12\x1e\n\x1aMEDIA_MESSAGE_CODEC_CONF\
    IG\x10\x01\x12\x19\n\x13MEDIA_MESSAGE_SETUP\x10\x80\x80\x02\x12\x19\n\
    \x13MEDIA_MESSAGE_START\x10\x81\x80\x02\x12\x18\n\x12MEDIA_MESSAGE_STOP\
    \x10\x82\x80\x02\x12\x1a\n\x14MEDIA_MESSAGE_CONFIG\x10\x83\x80\x02\x12\
    \x17\n\x11MEDIA_MESSAGE_ACK\x10\x84\x80\x02\x12&\n\x20MEDIA_MESSAGE_MICR\
    OPHONE_REQUEST\x10\x85\x80\x02\x12'\n!MEDIA_MESSAGE_MICROPHONE_RESPONSE\
    \x10\x86\x80\x02\x12'\n!MEDIA_MESSAGE_VIDEO_FOCUS_REQUEST\x10\x87\x80\
    \x02\x12,\n&MEDIA_MESSAGE_VIDEO_FOCUS_NOTIFICATION\x10\x88\x80\x02\x12,\
    \n&MEDIA_MESSAGE_UPDATE_UI_CONFIG_REQUEST\x10\x89\x80\x02\x12*\n$MEDIA_M\
    ESSAGE_UPDATE_UI_CONFIG_REPLY\x10\x8a\x80\x02\x120\n*MEDIA_MESSAGE_AUDIO\
    _UNDERFLOW_NOTIFICATION\x10\x8b\x80\x02*q\n\rPointerAction\x12\x0f\n\x0b\
    ACTION_DOWN\x10\0\x12\r\n\tACTION_UP\x10\x01\x12\x10\n\x0cACTION_MOVED\
    \x10\x02\x12\x17\n\x13ACTION_POINTER_DOWN\x10\x05\x12\x15\n\x11ACTION_PO\
    INTER_UP\x10\x06*\x89\x01\n\rFeedbackEvent\x12\x13\n\x0fFEEDBACK_SELECT\
    \x10\x01\x12\x19\n\x15FEEDBACK_FOCUS_CHANGE\x10\x02\x12\x18\n\x14FEEDBAC\
    K_DRAG_SELECT\x10\x03\x12\x17\n\x13FEEDBACK_DRAG_START\x10\x04\x12\x15\n\
    \x11FEEDBACK_DRAG_END\x10\x05*\xa9\x01\n\x0eInputMessageId\x12\x20\n\x1a\
    INPUT_MESSAGE_INPUT_REPORT\x10\x81\x80\x02\x12'\n!INPUT_MESSAGE_KEY_BIND\
    ING_REQUEST\x10\x82\x80\x02\x12(\n\"INPUT_MESSAGE_KEY_BINDING_RESPONSE\
    \x10\x83\x80\x02\x12\"\n\x1cINPUT_MESSAGE_INPUT_FEEDBACK\x10\x84\x80\x02\
    *\xc3\x01\n\x12BluetoothMessageId\x12'\n!BLUETOOTH_MESSAGE_PAIRING_REQUE\
    ST\x10\x81\x80\x02\x12(\n\"BLUETOOTH_MESSAGE_PAIRING_RESPONSE\x10\x82\
    \x80\x02\x12+\n%BLUETOOTH_MESSAGE_AUTHENTICATION_DATA\x10\x83\x80\x02\
    \x12-\n'BLUETOOTH_MESSAGE_AUTHENTICATION_RESULT\x10\x84\x80\x02*\xce\x01\
    \n\x10WifiSecurityMode\x12\x19\n\x15UNKNOWN_SECURITY_MODE\x10\0\x12\x08\
    \n\x04OPEN\x10\x01\x12\n\n\x06WEP_64\x10\x02\x12\x0b\n\x07WEP_128\x10\
    \x03\x12\x10\n\x0cWPA_PERSONAL\x10\x04\x12\x11\n\rWPA2_PERSONAL\x10\x05\
    \x12\x15\n\x11WPA_WPA2_PERSONAL\x10\x06\x12\x12\n\x0eWPA_ENTERPRISE\x10\
    \x07\x12\x13\n\x0fWPA2_ENTERPRISE\x10\x08\x12\x17\n\x13WPA_WPA2_ENTERPRI\
    SE\x10\t**\n\x0fAccessPointType\x12\n\n\x06STATIC\x10\0\x12\x0b\n\x07DYN\
    AMIC\x10\x01*j\n\x17WifiProjectionMessageId\x12&\n\x20WIFI_MESSAGE_CREDE\
    NTIALS_REQUEST\x10\x81\x80\x02\x12'\n!WIFI_MESSAGE_CREDENTIALS_RESPONSE\
    \x10\x82\x80\x02*\x8d\t\n\x0eRadioMessageId\x12-\n'RADIO_MESSAGE_ACTIVE_\
    RADIO_NOTIFICATION\x10\x81\x80\x02\x12/\n)RADIO_MESSAGE_SELECT_ACTIVE_RA\
    DIO_REQUEST\x10\x82\x80\x02\x12(\n\"RADIO_MESSAGE_STEP_CHANNEL_REQUEST\
    \x10\x83\x80\x02\x12)\n#RADIO_MESSAGE_STEP_CHANNEL_RESPONSE\x10\x84\x80\
    \x02\x12(\n\"RADIO_MESSAGE_SEEK_STATION_REQUEST\x10\x85\x80\x02\x12)\n#R\
    ADIO_MESSAGE_SEEK_STATION_RESPONSE\x10\x86\x80\x02\x12)\n#RADIO_MESSAGE_\
    SCAN_STATIONS_REQUEST\x10\x87\x80\x02\x12*\n$RADIO_MESSAGE_SCAN_STATIONS\
    _RESPONSE\x10\x88\x80\x02\x12+\n%RADIO_MESSAGE_TUNE_TO_STATION_REQUEST\
    \x10\x89\x80\x02\x12,\n&RADIO_MESSAGE_TUNE_TO_STATION_RESPONSE\x10\x8a\
    \x80\x02\x12,\n&RADIO_MESSAGE_GET_PROGRAM_LIST_REQUEST\x10\x8b\x80\x02\
    \x12-\n'RADIO_MESSAGE_GET_PROGRAM_LIST_RESPONSE\x10\x8c\x80\x02\x120\n*R\
    ADIO_MESSAGE_STATION_PRESETS_NOTIFICATION\x10\x8d\x80\x02\x12-\n'RADIO_M\
    ESSAGE_CANCEL_OPERATIONS_REQUEST\x10\x8e\x80\x02\x12.\n(RADIO_MESSAGE_CA\
    NCEL_OPERATIONS_RESPONSE\x10\x8f\x80\x02\x125\n/RADIO_MESSAGE_CONFIGURE_\
    CHANNEL_SPACING_REQUEST\x10\x90\x80\x02\x126\n0RADIO_MESSAGE_CONFIGURE_C\
    HANNEL_SPACING_RESPONSE\x10\x91\x80\x02\x123\n-RADIO_MESSAGE_RADIO_STATI\
    ON_INFO_NOTIFICATION\x10\x92\x80\x02\x12&\n\x20RADIO_MESSAGE_MUTE_RADIO_\
    REQUEST\x10\x93\x80\x02\x12'\n!RADIO_MESSAGE_MUTE_RADIO_RESPONSE\x10\x94\
    \x80\x02\x12.\n(RADIO_MESSAGE_GET_TRAFFIC_UPDATE_REQUEST\x10\x95\x80\x02\
    \x12/\n)RADIO_MESSAGE_GET_TRAFFIC_UPDATE_RESPONSE\x10\x96\x80\x02\x12(\n\
    \"RADIO_MESSAGE_RADIO_SOURCE_REQUEST\x10\x97\x80\x02\x12)\n#RADIO_MESSAG\
    E_RADIO_SOURCE_RESPONSE\x10\x98\x80\x02\x12&\n\x20RADIO_MESSAGE_STATE_NO\
    TIFICATION\x10\x99\x80\x02*A\n\x10HdAcquisionState\x12\n\n\x06ANALOG\x10\
    \0\x12\x10\n\x0cACQUIRING_HD\x10\x01\x12\x0f\n\x0bACQUIRED_HD\x10\x02*\
    \xd3\x02\n\x19NavigationStatusMessageId\x12\x1e\n\x18INSTRUMENT_CLUSTER_\
    START\x10\x81\x80\x02\x12\x1d\n\x17INSTRUMENT_CLUSTER_STOP\x10\x82\x80\
    \x02\x12*\n$INSTRUMENT_CLUSTER_NAVIGATION_STATUS\x10\x83\x80\x02\x122\n(\
    INSTRUMENT_CLUSTER_NAVIGATION_TURN_EVENT\x10\x84\x80\x02\x1a\x02\x08\x01\
    \x126\n,INSTRUMENT_CLUSTER_NAVIGATION_DISTANCE_EVENT\x10\x85\x80\x02\x1a\
    \x02\x08\x01\x12)\n#INSTRUMENT_CLUSTER_NAVIGATION_STATE\x10\x86\x80\x02\
    \x124\n.INSTRUMENT_CLUSTER_NAVIGATION_CURRENT_POSITION\x10\x87\x80\x02*v\
    \n\x1cMediaPlaybackStatusMessageId\x12\x1b\n\x15MEDIA_PLAYBACK_STATUS\
    \x10\x81\x80\x02\x12\x1a\n\x14MEDIA_PLAYBACK_INPUT\x10\x82\x80\x02\x12\
    \x1d\n\x17MEDIA_PLAYBACK_METADATA\x10\x83\x80\x02*D\n\x14PhoneStatusMess\
    ageId\x12\x12\n\x0cPHONE_STATUS\x10\x81\x80\x02\x12\x18\n\x12PHONE_STATU\
    S_INPUT\x10\x82\x80\x02*\xa5\x01\n\x15MediaBrowserMessageId\x12\x15\n\
    \x0fMEDIA_ROOT_NODE\x10\x81\x80\x02\x12\x17\n\x11MEDIA_SOURCE_NODE\x10\
    \x82\x80\x02\x12\x15\n\x0fMEDIA_LIST_NODE\x10\x83\x80\x02\x12\x15\n\x0fM\
    EDIA_SONG_NODE\x10\x84\x80\x02\x12\x14\n\x0eMEDIA_GET_NODE\x10\x85\x80\
    \x02\x12\x18\n\x12MEDIA_BROWSE_INPUT\x10\x86\x80\x02*\x82\x04\n'GalVerif\
    icationVendorExtensionMessageId\x12!\n\x1bGAL_VERIFICATION_SET_SENSOR\
    \x10\x81\x80\x02\x12(\n\"GAL_VERIFICATION_MEDIA_SINK_STATUS\x10\x82\x80\
    \x02\x12\"\n\x1cGAL_VERIFICATION_VIDEO_FOCUS\x10\x83\x80\x02\x12\"\n\x1c\
    GAL_VERIFICATION_AUDIO_FOCUS\x10\x84\x80\x02\x12#\n\x1dGAL_VERIFICATION_\
    INJECT_INPUT\x10\x85\x80\x02\x12)\n#GAL_VERIFICATION_BUG_REPORT_REQUEST\
    \x10\x86\x80\x02\x12*\n$GAL_VERIFICATION_BUG_REPORT_RESPONSE\x10\x87\x80\
    \x02\x12-\n'GAL_VERIFICATION_SCREEN_CAPTURE_REQUEST\x10\x88\x80\x02\x12.\
    \n(GAL_VERIFICATION_SCREEN_CAPTURE_RESPONSE\x10\x89\x80\x02\x122\n,GAL_V\
    ERIFICATION_DISPLAY_INFORMATION_REQUEST\x10\x8a\x80\x02\x123\n-GAL_VERIF\
    ICATION_DISPLAY_INFORMATION_RESPONSE\x10\x8b\x80\x02*\xb0\x01\n\x1cGener\
    icNotificationMessageId\x12$\n\x1eGENERIC_NOTIFICATION_SUBSCRIBE\x10\x81\
    \x80\x02\x12&\n\x20GENERIC_NOTIFICATION_UNSUBSCRIBE\x10\x82\x80\x02\x12\
    \"\n\x1cGENERIC_NOTIFICATION_MESSAGE\x10\x83\x80\x02\x12\x1e\n\x18GENERI\
    C_NOTIFICATION_ACK\x10\x84\x80\x02*t\n)GoogleDiagnosticsVendorExtensionM\
    essageId\x12\"\n\x1eDIAGNOSTICS_BUG_REPORT_REQUEST\x10\x01\x12#\n\x1fDIA\
    GNOSTICS_BUG_REPORT_RESPONSE\x10\x02*\xd3\n\n\rMessageStatus\x12\x1e\n\
    \x1aSTATUS_UNSOLICITED_MESSAGE\x10\x01\x12\x12\n\x0eSTATUS_SUCCESS\x10\0\
    \x12)\n\x1cSTATUS_NO_COMPATIBLE_VERSION\x10\xff\xff\xff\xff\xff\xff\xff\
    \xff\xff\x01\x12%\n\x18STATUS_CERTIFICATE_ERROR\x10\xfe\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12*\n\x1dSTATUS_AUTHENTICATION_FAILURE\x10\xfd\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12#\n\x16STATUS_INVALID_SERVICE\x10\
    \xfc\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12#\n\x16STATUS_INVALID_CHANNE\
    L\x10\xfb\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12$\n\x17STATUS_INVALID_P\
    RIORITY\x10\xfa\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\"\n\x15STATUS_IN\
    TERNAL_ERROR\x10\xf9\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12)\n\x1cSTATU\
    S_MEDIA_CONFIG_MISMATCH\x10\xf8\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\
    \"\n\x15STATUS_INVALID_SENSOR\x10\xf7\xff\xff\xff\xff\xff\xff\xff\xff\
    \x01\x12-\n\x20STATUS_BLUETOOTH_PAIRING_DELAYED\x10\xf6\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12)\n\x1cSTATUS_BLUETOOTH_UNAVAILABLE\x10\xf5\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12-\n\x20STATUS_BLUETOOTH_INVALID_ADDR\
    ESS\x10\xf4\xff\xff\xff\xff\xff\xff\xff\xff\x01\x124\n'STATUS_BLUETOOTH_\
    INVALID_PAIRING_METHOD\x10\xf3\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12/\
    \n\"STATUS_BLUETOOTH_INVALID_AUTH_DATA\x10\xf2\xff\xff\xff\xff\xff\xff\
    \xff\xff\x01\x120\n#STATUS_BLUETOOTH_AUTH_DATA_MISMATCH\x10\xf1\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01\x124\n'STATUS_BLUETOOTH_HFP_ANOTHER_CONNECT\
    ION\x10\xf0\xff\xff\xff\xff\xff\xff\xff\xff\x01\x124\n'STATUS_BLUETOOTH_\
    HFP_CONNECTION_FAILURE\x10\xef\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12%\
    \n\x18STATUS_KEYCODE_NOT_BOUND\x10\xee\xff\xff\xff\xff\xff\xff\xff\xff\
    \x01\x12)\n\x1cSTATUS_RADIO_INVALID_STATION\x10\xed\xff\xff\xff\xff\xff\
    \xff\xff\xff\x01\x12!\n\x14STATUS_INVALID_INPUT\x10\xec\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x127\n*STATUS_RADIO_STATION_PRESETS_NOT_SUPPORTED\
    \x10\xeb\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12$\n\x17STATUS_RADIO_COMM\
    _ERROR\x10\xea\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12=\n0STATUS_AUTHENT\
    ICATION_FAILURE_CERT_NOT_YET_VALID\x10\xe9\xff\xff\xff\xff\xff\xff\xff\
    \xff\x01\x127\n*STATUS_AUTHENTICATION_FAILURE_CERT_EXPIRED\x10\xe8\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12\x20\n\x13STATUS_PING_TIMEOUT\x10\
    \xe7\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12)\n\x1cSTATUS_COMMAND_NOT_SU\
    PPORTED\x10\x86\xfe\xff\xff\xff\xff\xff\xff\xff\x01\x12!\n\x14STATUS_FRA\
    MING_ERROR\x10\x85\xfe\xff\xff\xff\xff\xff\xff\xff\x01\x12&\n\x19STATUS_\
    UNEXPECTED_MESSAGE\x10\x83\xfe\xff\xff\xff\xff\xff\xff\xff\x01\x12\x18\n\
    \x0bSTATUS_BUSY\x10\x82\xfe\xff\xff\xff\xff\xff\xff\xff\x01\x12!\n\x14ST\
    ATUS_OUT_OF_MEMORY\x10\x81\xfe\xff\xff\xff\xff\xff\xff\xff\x01*\xfe1\n\
    \x07KeyCode\x12\x13\n\x0fKEYCODE_UNKNOWN\x10\0\x12\x15\n\x11KEYCODE_SOFT\
    _LEFT\x10\x01\x12\x16\n\x12KEYCODE_SOFT_RIGHT\x10\x02\x12\x10\n\x0cKEYCO\
    DE_HOME\x10\x03\x12\x10\n\x0cKEYCODE_BACK\x10\x04\x12\x10\n\x0cKEYCODE_C\
    ALL\x10\x05\x12\x13\n\x0fKEYCODE_ENDCALL\x10\x06\x12\r\n\tKEYCODE_0\x10\
    \x07\x12\r\n\tKEYCODE_1\x10\x08\x12\r\n\tKEYCODE_2\x10\t\x12\r\n\tKEYCOD\
    E_3\x10\n\x12\r\n\tKEYCODE_4\x10\x0b\x12\r\n\tKEYCODE_5\x10\x0c\x12\r\n\
    \tKEYCODE_6\x10\r\x12\r\n\tKEYCODE_7\x10\x0e\x12\r\n\tKEYCODE_8\x10\x0f\
    \x12\r\n\tKEYCODE_9\x10\x10\x12\x10\n\x0cKEYCODE_STAR\x10\x11\x12\x11\n\
    \rKEYCODE_POUND\x10\x12\x12\x13\n\x0fKEYCODE_DPAD_UP\x10\x13\x12\x15\n\
    \x11KEYCODE_DPAD_DOWN\x10\x14\x12\x15\n\x11KEYCODE_DPAD_LEFT\x10\x15\x12\
    \x16\n\x12KEYCODE_DPAD_RIGHT\x10\x16\x12\x17\n\x13KEYCODE_DPAD_CENTER\
    \x10\x17\x12\x15\n\x11KEYCODE_VOLUME_UP\x10\x18\x12\x17\n\x13KEYCODE_VOL\
    UME_DOWN\x10\x19\x12\x11\n\rKEYCODE_POWER\x10\x1a\x12\x12\n\x0eKEYCODE_C\
    AMERA\x10\x1b\x12\x11\n\rKEYCODE_CLEAR\x10\x1c\x12\r\n\tKEYCODE_A\x10\
    \x1d\x12\r\n\tKEYCODE_B\x10\x1e\x12\r\n\tKEYCODE_C\x10\x1f\x12\r\n\tKEYC\
    ODE_D\x10\x20\x12\r\n\tKEYCODE_E\x10!\x12\r\n\tKEYCODE_F\x10\"\x12\r\n\t\
    KEYCODE_G\x10#\x12\r\n\tKEYCODE_H\x10$\x12\r\n\tKEYCODE_I\x10%\x12\r\n\t\
    KEYCODE_J\x10&\x12\r\n\tKEYCODE_K\x10'\x12\r\n\tKEYCODE_L\x10(\x12\r\n\t\
    KEYCODE_M\x10)\x12\r\n\tKEYCODE_N\x10*\x12\r\n\tKEYCODE_O\x10+\x12\r\n\t\
    KEYCODE_P\x10,\x12\r\n\tKEYCODE_Q\x10-\x12\r\n\tKEYCODE_R\x10.\x12\r\n\t\
    KEYCODE_S\x10/\x12\r\n\tKEYCODE_T\x100\x12\r\n\tKEYCODE_U\x101\x12\r\n\t\
    KEYCODE_V\x102\x12\r\n\tKEYCODE_W\x103\x12\r\n\tKEYCODE_X\x104\x12\r\n\t\
    KEYCODE_Y\x105\x12\r\n\tKEYCODE_Z\x106\x12\x11\n\rKEYCODE_COMMA\x107\x12\
    \x12\n\x0eKEYCODE_PERIOD\x108\x12\x14\n\x10KEYCODE_ALT_LEFT\x109\x12\x15\
    \n\x11KEYCODE_ALT_RIGHT\x10:\x12\x16\n\x12KEYCODE_SHIFT_LEFT\x10;\x12\
    \x17\n\x13KEYCODE_SHIFT_RIGHT\x10<\x12\x0f\n\x0bKEYCODE_TAB\x10=\x12\x11\
    \n\rKEYCODE_SPACE\x10>\x12\x0f\n\x0bKEYCODE_SYM\x10?\x12\x14\n\x10KEYCOD\
    E_EXPLORER\x10@\x12\x14\n\x10KEYCODE_ENVELOPE\x10A\x12\x11\n\rKEYCODE_EN\
    TER\x10B\x12\x0f\n\x0bKEYCODE_DEL\x10C\x12\x11\n\rKEYCODE_GRAVE\x10D\x12\
    \x11\n\rKEYCODE_MINUS\x10E\x12\x12\n\x0eKEYCODE_EQUALS\x10F\x12\x18\n\
    \x14KEYCODE_LEFT_BRACKET\x10G\x12\x19\n\x15KEYCODE_RIGHT_BRACKET\x10H\
    \x12\x15\n\x11KEYCODE_BACKSLASH\x10I\x12\x15\n\x11KEYCODE_SEMICOLON\x10J\
    \x12\x16\n\x12KEYCODE_APOSTROPHE\x10K\x12\x11\n\rKEYCODE_SLASH\x10L\x12\
    \x0e\n\nKEYCODE_AT\x10M\x12\x0f\n\x0bKEYCODE_NUM\x10N\x12\x17\n\x13KEYCO\
    DE_HEADSETHOOK\x10O\x12\x11\n\rKEYCODE_FOCUS\x10P\x12\x10\n\x0cKEYCODE_P\
    LUS\x10Q\x12\x10\n\x0cKEYCODE_MENU\x10R\x12\x18\n\x14KEYCODE_NOTIFICATIO\
    N\x10S\x12\x12\n\x0eKEYCODE_SEARCH\x10T\x12\x1c\n\x18KEYCODE_MEDIA_PLAY_\
    PAUSE\x10U\x12\x16\n\x12KEYCODE_MEDIA_STOP\x10V\x12\x16\n\x12KEYCODE_MED\
    IA_NEXT\x10W\x12\x1a\n\x16KEYCODE_MEDIA_PREVIOUS\x10X\x12\x18\n\x14KEYCO\
    DE_MEDIA_REWIND\x10Y\x12\x1e\n\x1aKEYCODE_MEDIA_FAST_FORWARD\x10Z\x12\
    \x10\n\x0cKEYCODE_MUTE\x10[\x12\x13\n\x0fKEYCODE_PAGE_UP\x10\\\x12\x15\n\
    \x11KEYCODE_PAGE_DOWN\x10]\x12\x17\n\x13KEYCODE_PICTSYMBOLS\x10^\x12\x1a\
    \n\x16KEYCODE_SWITCH_CHARSET\x10_\x12\x14\n\x10KEYCODE_BUTTON_A\x10`\x12\
    \x14\n\x10KEYCODE_BUTTON_B\x10a\x12\x14\n\x10KEYCODE_BUTTON_C\x10b\x12\
    \x14\n\x10KEYCODE_BUTTON_X\x10c\x12\x14\n\x10KEYCODE_BUTTON_Y\x10d\x12\
    \x14\n\x10KEYCODE_BUTTON_Z\x10e\x12\x15\n\x11KEYCODE_BUTTON_L1\x10f\x12\
    \x15\n\x11KEYCODE_BUTTON_R1\x10g\x12\x15\n\x11KEYCODE_BUTTON_L2\x10h\x12\
    \x15\n\x11KEYCODE_BUTTON_R2\x10i\x12\x19\n\x15KEYCODE_BUTTON_THUMBL\x10j\
    \x12\x19\n\x15KEYCODE_BUTTON_THUMBR\x10k\x12\x18\n\x14KEYCODE_BUTTON_STA\
    RT\x10l\x12\x19\n\x15KEYCODE_BUTTON_SELECT\x10m\x12\x17\n\x13KEYCODE_BUT\
    TON_MODE\x10n\x12\x12\n\x0eKEYCODE_ESCAPE\x10o\x12\x17\n\x13KEYCODE_FORW\
    ARD_DEL\x10p\x12\x15\n\x11KEYCODE_CTRL_LEFT\x10q\x12\x16\n\x12KEYCODE_CT\
    RL_RIGHT\x10r\x12\x15\n\x11KEYCODE_CAPS_LOCK\x10s\x12\x17\n\x13KEYCODE_S\
    CROLL_LOCK\x10t\x12\x15\n\x11KEYCODE_META_LEFT\x10u\x12\x16\n\x12KEYCODE\
    _META_RIGHT\x10v\x12\x14\n\x10KEYCODE_FUNCTION\x10w\x12\x11\n\rKEYCODE_S\
    YSRQ\x10x\x12\x11\n\rKEYCODE_BREAK\x10y\x12\x15\n\x11KEYCODE_MOVE_HOME\
    \x10z\x12\x14\n\x10KEYCODE_MOVE_END\x10{\x12\x12\n\x0eKEYCODE_INSERT\x10\
    |\x12\x13\n\x0fKEYCODE_FORWARD\x10}\x12\x16\n\x12KEYCODE_MEDIA_PLAY\x10~\
    \x12\x17\n\x13KEYCODE_MEDIA_PAUSE\x10\x7f\x12\x18\n\x13KEYCODE_MEDIA_CLO\
    SE\x10\x80\x01\x12\x18\n\x13KEYCODE_MEDIA_EJECT\x10\x81\x01\x12\x19\n\
    \x14KEYCODE_MEDIA_RECORD\x10\x82\x01\x12\x0f\n\nKEYCODE_F1\x10\x83\x01\
    \x12\x0f\n\nKEYCODE_F2\x10\x84\x01\x12\x0f\n\nKEYCODE_F3\x10\x85\x01\x12\
    \x0f\n\nKEYCODE_F4\x10\x86\x01\x12\x0f\n\nKEYCODE_F5\x10\x87\x01\x12\x0f\
    \n\nKEYCODE_F6\x10\x88\x01\x12\x0f\n\nKEYCODE_F7\x10\x89\x01\x12\x0f\n\n\
    KEYCODE_F8\x10\x8a\x01\x12\x0f\n\nKEYCODE_F9\x10\x8b\x01\x12\x10\n\x0bKE\
    YCODE_F10\x10\x8c\x01\x12\x10\n\x0bKEYCODE_F11\x10\x8d\x01\x12\x10\n\x0b\
    KEYCODE_F12\x10\x8e\x01\x12\x15\n\x10KEYCODE_NUM_LOCK\x10\x8f\x01\x12\
    \x15\n\x10KEYCODE_NUMPAD_0\x10\x90\x01\x12\x15\n\x10KEYCODE_NUMPAD_1\x10\
    \x91\x01\x12\x15\n\x10KEYCODE_NUMPAD_2\x10\x92\x01\x12\x15\n\x10KEYCODE_\
    NUMPAD_3\x10\x93\x01\x12\x15\n\x10KEYCODE_NUMPAD_4\x10\x94\x01\x12\x15\n\
    \x10KEYCODE_NUMPAD_5\x10\x95\x01\x12\x15\n\x10KEYCODE_NUMPAD_6\x10\x96\
    \x01\x12\x15\n\x10KEYCODE_NUMPAD_7\x10\x97\x01\x12\x15\n\x10KEYCODE_NUMP\
    AD_8\x10\x98\x01\x12\x15\n\x10KEYCODE_NUMPAD_9\x10\x99\x01\x12\x1a\n\x15\
    KEYCODE_NUMPAD_DIVIDE\x10\x9a\x01\x12\x1c\n\x17KEYCODE_NUMPAD_MULTIPLY\
    \x10\x9b\x01\x12\x1c\n\x17KEYCODE_NUMPAD_SUBTRACT\x10\x9c\x01\x12\x17\n\
    \x12KEYCODE_NUMPAD_ADD\x10\x9d\x01\x12\x17\n\x12KEYCODE_NUMPAD_DOT\x10\
    \x9e\x01\x12\x19\n\x14KEYCODE_NUMPAD_COMMA\x10\x9f\x01\x12\x19\n\x14KEYC\
    ODE_NUMPAD_ENTER\x10\xa0\x01\x12\x1a\n\x15KEYCODE_NUMPAD_EQUALS\x10\xa1\
    \x01\x12\x1e\n\x19KEYCODE_NUMPAD_LEFT_PAREN\x10\xa2\x01\x12\x1f\n\x1aKEY\
    CODE_NUMPAD_RIGHT_PAREN\x10\xa3\x01\x12\x18\n\x13KEYCODE_VOLUME_MUTE\x10\
    \xa4\x01\x12\x11\n\x0cKEYCODE_INFO\x10\xa5\x01\x12\x17\n\x12KEYCODE_CHAN\
    NEL_UP\x10\xa6\x01\x12\x19\n\x14KEYCODE_CHANNEL_DOWN\x10\xa7\x01\x12\x14\
    \n\x0fKEYCODE_ZOOM_IN\x10\xa8\x01\x12\x15\n\x10KEYCODE_ZOOM_OUT\x10\xa9\
    \x01\x12\x0f\n\nKEYCODE_TV\x10\xaa\x01\x12\x13\n\x0eKEYCODE_WINDOW\x10\
    \xab\x01\x12\x12\n\rKEYCODE_GUIDE\x10\xac\x01\x12\x10\n\x0bKEYCODE_DVR\
    \x10\xad\x01\x12\x15\n\x10KEYCODE_BOOKMARK\x10\xae\x01\x12\x15\n\x10KEYC\
    ODE_CAPTIONS\x10\xaf\x01\x12\x15\n\x10KEYCODE_SETTINGS\x10\xb0\x01\x12\
    \x15\n\x10KEYCODE_TV_POWER\x10\xb1\x01\x12\x15\n\x10KEYCODE_TV_INPUT\x10\
    \xb2\x01\x12\x16\n\x11KEYCODE_STB_POWER\x10\xb3\x01\x12\x16\n\x11KEYCODE\
    _STB_INPUT\x10\xb4\x01\x12\x16\n\x11KEYCODE_AVR_POWER\x10\xb5\x01\x12\
    \x16\n\x11KEYCODE_AVR_INPUT\x10\xb6\x01\x12\x15\n\x10KEYCODE_PROG_RED\
    \x10\xb7\x01\x12\x17\n\x12KEYCODE_PROG_GREEN\x10\xb8\x01\x12\x18\n\x13KE\
    YCODE_PROG_YELLOW\x10\xb9\x01\x12\x16\n\x11KEYCODE_PROG_BLUE\x10\xba\x01\
    \x12\x17\n\x12KEYCODE_APP_SWITCH\x10\xbb\x01\x12\x15\n\x10KEYCODE_BUTTON\
    _1\x10\xbc\x01\x12\x15\n\x10KEYCODE_BUTTON_2\x10\xbd\x01\x12\x15\n\x10KE\
    YCODE_BUTTON_3\x10\xbe\x01\x12\x15\n\x10KEYCODE_BUTTON_4\x10\xbf\x01\x12\
    \x15\n\x10KEYCODE_BUTTON_5\x10\xc0\x01\x12\x15\n\x10KEYCODE_BUTTON_6\x10\
    \xc1\x01\x12\x15\n\x10KEYCODE_BUTTON_7\x10\xc2\x01\x12\x15\n\x10KEYCODE_\
    BUTTON_8\x10\xc3\x01\x12\x15\n\x10KEYCODE_BUTTON_9\x10\xc4\x01\x12\x16\n\
    \x11KEYCODE_BUTTON_10\x10\xc5\x01\x12\x16\n\x11KEYCODE_BUTTON_11\x10\xc6\
    \x01\x12\x16\n\x11KEYCODE_BUTTON_12\x10\xc7\x01\x12\x16\n\x11KEYCODE_BUT\
    TON_13\x10\xc8\x01\x12\x16\n\x11KEYCODE_BUTTON_14\x10\xc9\x01\x12\x16\n\
    \x11KEYCODE_BUTTON_15\x10\xca\x01\x12\x16\n\x11KEYCODE_BUTTON_16\x10\xcb\
    \x01\x12\x1c\n\x17KEYCODE_LANGUAGE_SWITCH\x10\xcc\x01\x12\x18\n\x13KEYCO\
    DE_MANNER_MODE\x10\xcd\x01\x12\x14\n\x0fKEYCODE_3D_MODE\x10\xce\x01\x12\
    \x15\n\x10KEYCODE_CONTACTS\x10\xcf\x01\x12\x15\n\x10KEYCODE_CALENDAR\x10\
    \xd0\x01\x12\x12\n\rKEYCODE_MUSIC\x10\xd1\x01\x12\x17\n\x12KEYCODE_CALCU\
    LATOR\x10\xd2\x01\x12\x1c\n\x17KEYCODE_ZENKAKU_HANKAKU\x10\xd3\x01\x12\
    \x11\n\x0cKEYCODE_EISU\x10\xd4\x01\x12\x15\n\x10KEYCODE_MUHENKAN\x10\xd5\
    \x01\x12\x13\n\x0eKEYCODE_HENKAN\x10\xd6\x01\x12\x1e\n\x19KEYCODE_KATAKA\
    NA_HIRAGANA\x10\xd7\x01\x12\x10\n\x0bKEYCODE_YEN\x10\xd8\x01\x12\x0f\n\n\
    KEYCODE_RO\x10\xd9\x01\x12\x11\n\x0cKEYCODE_KANA\x10\xda\x01\x12\x13\n\
    \x0eKEYCODE_ASSIST\x10\xdb\x01\x12\x1c\n\x17KEYCODE_BRIGHTNESS_DOWN\x10\
    \xdc\x01\x12\x1a\n\x15KEYCODE_BRIGHTNESS_UP\x10\xdd\x01\x12\x1e\n\x19KEY\
    CODE_MEDIA_AUDIO_TRACK\x10\xde\x01\x12\x12\n\rKEYCODE_SLEEP\x10\xdf\x01\
    \x12\x13\n\x0eKEYCODE_WAKEUP\x10\xe0\x01\x12\x14\n\x0fKEYCODE_PAIRING\
    \x10\xe1\x01\x12\x1b\n\x16KEYCODE_MEDIA_TOP_MENU\x10\xe2\x01\x12\x0f\n\n\
    KEYCODE_11\x10\xe3\x01\x12\x0f\n\nKEYCODE_12\x10\xe4\x01\x12\x19\n\x14KE\
    YCODE_LAST_CHANNEL\x10\xe5\x01\x12\x1c\n\x17KEYCODE_TV_DATA_SERVICE\x10\
    \xe6\x01\x12\x19\n\x14KEYCODE_VOICE_ASSIST\x10\xe7\x01\x12\x1d\n\x18KEYC\
    ODE_TV_RADIO_SERVICE\x10\xe8\x01\x12\x18\n\x13KEYCODE_TV_TELETEXT\x10\
    \xe9\x01\x12\x1c\n\x17KEYCODE_TV_NUMBER_ENTRY\x10\xea\x01\x12\"\n\x1dKEY\
    CODE_TV_TERRESTRIAL_ANALOG\x10\xeb\x01\x12#\n\x1eKEYCODE_TV_TERRESTRIAL_\
    DIGITAL\x10\xec\x01\x12\x19\n\x14KEYCODE_TV_SATELLITE\x10\xed\x01\x12\
    \x1c\n\x17KEYCODE_TV_SATELLITE_BS\x10\xee\x01\x12\x1c\n\x17KEYCODE_TV_SA\
    TELLITE_CS\x10\xef\x01\x12!\n\x1cKEYCODE_TV_SATELLITE_SERVICE\x10\xf0\
    \x01\x12\x17\n\x12KEYCODE_TV_NETWORK\x10\xf1\x01\x12\x1d\n\x18KEYCODE_TV\
    _ANTENNA_CABLE\x10\xf2\x01\x12\x1c\n\x17KEYCODE_TV_INPUT_HDMI_1\x10\xf3\
    \x01\x12\x1c\n\x17KEYCODE_TV_INPUT_HDMI_2\x10\xf4\x01\x12\x1c\n\x17KEYCO\
    DE_TV_INPUT_HDMI_3\x10\xf5\x01\x12\x1c\n\x17KEYCODE_TV_INPUT_HDMI_4\x10\
    \xf6\x01\x12!\n\x1cKEYCODE_TV_INPUT_COMPOSITE_1\x10\xf7\x01\x12!\n\x1cKE\
    YCODE_TV_INPUT_COMPOSITE_2\x10\xf8\x01\x12!\n\x1cKEYCODE_TV_INPUT_COMPON\
    ENT_1\x10\xf9\x01\x12!\n\x1cKEYCODE_TV_INPUT_COMPONENT_2\x10\xfa\x01\x12\
    \x1b\n\x16KEYCODE_TV_INPUT_VGA_1\x10\xfb\x01\x12!\n\x1cKEYCODE_TV_AUDIO_\
    DESCRIPTION\x10\xfc\x01\x12(\n#KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP\x10\
    \xfd\x01\x12*\n%KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN\x10\xfe\x01\x12\
    \x19\n\x14KEYCODE_TV_ZOOM_MODE\x10\xff\x01\x12\x1d\n\x18KEYCODE_TV_CONTE\
    NTS_MENU\x10\x80\x02\x12\"\n\x1dKEYCODE_TV_MEDIA_CONTEXT_MENU\x10\x81\
    \x02\x12!\n\x1cKEYCODE_TV_TIMER_PROGRAMMING\x10\x82\x02\x12\x11\n\x0cKEY\
    CODE_HELP\x10\x83\x02\x12\x1e\n\x19KEYCODE_NAVIGATE_PREVIOUS\x10\x84\x02\
    \x12\x1a\n\x15KEYCODE_NAVIGATE_NEXT\x10\x85\x02\x12\x18\n\x13KEYCODE_NAV\
    IGATE_IN\x10\x86\x02\x12\x19\n\x14KEYCODE_NAVIGATE_OUT\x10\x87\x02\x12\
    \x19\n\x14KEYCODE_DPAD_UP_LEFT\x10\x8c\x02\x12\x1b\n\x16KEYCODE_DPAD_DOW\
    N_LEFT\x10\x8d\x02\x12\x1a\n\x15KEYCODE_DPAD_UP_RIGHT\x10\x8e\x02\x12\
    \x1c\n\x17KEYCODE_DPAD_DOWN_RIGHT\x10\x8f\x02\x12\x16\n\x10KEYCODE_SENTI\
    NEL\x10\xff\xff\x03\x12\x1f\n\x19KEYCODE_ROTARY_CONTROLLER\x10\x80\x80\
    \x04\x12\x13\n\rKEYCODE_MEDIA\x10\x81\x80\x04\x12\x18\n\x12KEYCODE_NAVIG\
    ATION\x10\x82\x80\x04\x12\x13\n\rKEYCODE_RADIO\x10\x83\x80\x04\x12\x11\n\
    \x0bKEYCODE_TEL\x10\x84\x80\x04\x12\x1c\n\x16KEYCODE_PRIMARY_BUTTON\x10\
    \x85\x80\x04\x12\x1e\n\x18KEYCODE_SECONDARY_BUTTON\x10\x86\x80\x04\x12\
    \x1d\n\x17KEYCODE_TERTIARY_BUTTON\x10\x87\x80\x04\x12\x17\n\x11KEYCODE_T\
    URN_CARD\x10\x88\x80\x04*W\n\x0cGalConstants\x12\x0f\n\tWIFI_PORT\x10\
    \xb3\xee\x01\x12\x1a\n\x16PROTOCOL_MAJOR_VERSION\x10\x01\x12\x1a\n\x16PR\
    OTOCOL_MINOR_VERSION\x10\x06B-\n#com.google.android.projection.protoB\
    \x06Protos\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(196);
            messages.push(VersionRequestOptions::generated_message_descriptor_data());
            messages.push(VersionResponseOptions::generated_message_descriptor_data());
            messages.push(AuthResponse::generated_message_descriptor_data());
            messages.push(ServiceDiscoveryRequest::generated_message_descriptor_data());
            messages.push(ServiceDiscoveryResponse::generated_message_descriptor_data());
            messages.push(ServiceDiscoveryUpdate::generated_message_descriptor_data());
            messages.push(Service::generated_message_descriptor_data());
            messages.push(ConnectionConfiguration::generated_message_descriptor_data());
            messages.push(PingConfiguration::generated_message_descriptor_data());
            messages.push(WirelessTcpConfiguration::generated_message_descriptor_data());
            messages.push(SensorSourceService::generated_message_descriptor_data());
            messages.push(MediaSinkService::generated_message_descriptor_data());
            messages.push(VideoConfiguration::generated_message_descriptor_data());
            messages.push(UiConfig::generated_message_descriptor_data());
            messages.push(Insets::generated_message_descriptor_data());
            messages.push(MediaSourceService::generated_message_descriptor_data());
            messages.push(AudioConfiguration::generated_message_descriptor_data());
            messages.push(InputSourceService::generated_message_descriptor_data());
            messages.push(BluetoothService::generated_message_descriptor_data());
            messages.push(RadioService::generated_message_descriptor_data());
            messages.push(RadioProperties::generated_message_descriptor_data());
            messages.push(Range::generated_message_descriptor_data());
            messages.push(NavigationStatusService::generated_message_descriptor_data());
            messages.push(MediaPlaybackStatusService::generated_message_descriptor_data());
            messages.push(PhoneStatusService::generated_message_descriptor_data());
            messages.push(MediaBrowserService::generated_message_descriptor_data());
            messages.push(VendorExtensionService::generated_message_descriptor_data());
            messages.push(GenericNotificationService::generated_message_descriptor_data());
            messages.push(ChannelOpenRequest::generated_message_descriptor_data());
            messages.push(ChannelOpenResponse::generated_message_descriptor_data());
            messages.push(ChannelCloseNotification::generated_message_descriptor_data());
            messages.push(NavFocusRequestNotification::generated_message_descriptor_data());
            messages.push(NavFocusNotification::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(ByeByeRequest::generated_message_descriptor_data());
            messages.push(ByeByeResponse::generated_message_descriptor_data());
            messages.push(VoiceSessionNotification::generated_message_descriptor_data());
            messages.push(CarConnectedDevicesRequest::generated_message_descriptor_data());
            messages.push(CarConnectedDevices::generated_message_descriptor_data());
            messages.push(ConnectedDevice::generated_message_descriptor_data());
            messages.push(UserSwitchRequest::generated_message_descriptor_data());
            messages.push(UserSwitchResponse::generated_message_descriptor_data());
            messages.push(BatteryStatusNotification::generated_message_descriptor_data());
            messages.push(CallAvailabilityStatus::generated_message_descriptor_data());
            messages.push(SensorRequest::generated_message_descriptor_data());
            messages.push(SensorResponse::generated_message_descriptor_data());
            messages.push(SensorBatch::generated_message_descriptor_data());
            messages.push(SensorError::generated_message_descriptor_data());
            messages.push(LocationData::generated_message_descriptor_data());
            messages.push(CompassData::generated_message_descriptor_data());
            messages.push(SpeedData::generated_message_descriptor_data());
            messages.push(RpmData::generated_message_descriptor_data());
            messages.push(OdometerData::generated_message_descriptor_data());
            messages.push(FuelData::generated_message_descriptor_data());
            messages.push(ParkingBrakeData::generated_message_descriptor_data());
            messages.push(GearData::generated_message_descriptor_data());
            messages.push(DiagnosticsData::generated_message_descriptor_data());
            messages.push(NightModeData::generated_message_descriptor_data());
            messages.push(EnvironmentData::generated_message_descriptor_data());
            messages.push(HvacData::generated_message_descriptor_data());
            messages.push(DrivingStatusData::generated_message_descriptor_data());
            messages.push(DeadReckoningData::generated_message_descriptor_data());
            messages.push(LightData::generated_message_descriptor_data());
            messages.push(PassengerData::generated_message_descriptor_data());
            messages.push(DoorData::generated_message_descriptor_data());
            messages.push(TirePressureData::generated_message_descriptor_data());
            messages.push(AccelerometerData::generated_message_descriptor_data());
            messages.push(GyroscopeData::generated_message_descriptor_data());
            messages.push(GpsSatellite::generated_message_descriptor_data());
            messages.push(GpsSatelliteData::generated_message_descriptor_data());
            messages.push(TollCardData::generated_message_descriptor_data());
            messages.push(Setup::generated_message_descriptor_data());
            messages.push(Start::generated_message_descriptor_data());
            messages.push(Stop::generated_message_descriptor_data());
            messages.push(Config::generated_message_descriptor_data());
            messages.push(Ack::generated_message_descriptor_data());
            messages.push(AudioUnderflowNotification::generated_message_descriptor_data());
            messages.push(VideoFocusRequestNotification::generated_message_descriptor_data());
            messages.push(VideoFocusNotification::generated_message_descriptor_data());
            messages.push(UpdateUiConfigRequest::generated_message_descriptor_data());
            messages.push(UpdateUiConfigReply::generated_message_descriptor_data());
            messages.push(AudioFocusRequestNotification::generated_message_descriptor_data());
            messages.push(AudioFocusNotification::generated_message_descriptor_data());
            messages.push(MicrophoneRequest::generated_message_descriptor_data());
            messages.push(MicrophoneResponse::generated_message_descriptor_data());
            messages.push(KeyBindingRequest::generated_message_descriptor_data());
            messages.push(KeyBindingResponse::generated_message_descriptor_data());
            messages.push(InputReport::generated_message_descriptor_data());
            messages.push(KeyEvent::generated_message_descriptor_data());
            messages.push(TouchEvent::generated_message_descriptor_data());
            messages.push(AbsoluteEvent::generated_message_descriptor_data());
            messages.push(RelativeEvent::generated_message_descriptor_data());
            messages.push(InputFeedback::generated_message_descriptor_data());
            messages.push(BluetoothPairingRequest::generated_message_descriptor_data());
            messages.push(BluetoothPairingResponse::generated_message_descriptor_data());
            messages.push(BluetoothAuthenticationData::generated_message_descriptor_data());
            messages.push(BluetoothAuthenticationResult::generated_message_descriptor_data());
            messages.push(WifiProjectionService::generated_message_descriptor_data());
            messages.push(WifiCredentialsRequest::generated_message_descriptor_data());
            messages.push(WifiCredentialsResponse::generated_message_descriptor_data());
            messages.push(RadioStateNotification::generated_message_descriptor_data());
            messages.push(RadioSourceRequest::generated_message_descriptor_data());
            messages.push(RadioSourceResponse::generated_message_descriptor_data());
            messages.push(SelectActiveRadioRequest::generated_message_descriptor_data());
            messages.push(ActiveRadioNotification::generated_message_descriptor_data());
            messages.push(StepChannelRequest::generated_message_descriptor_data());
            messages.push(StepChannelResponse::generated_message_descriptor_data());
            messages.push(SeekStationRequest::generated_message_descriptor_data());
            messages.push(SeekStationResponse::generated_message_descriptor_data());
            messages.push(ScanStationsRequest::generated_message_descriptor_data());
            messages.push(ScanStationsResponse::generated_message_descriptor_data());
            messages.push(TuneToStationRequest::generated_message_descriptor_data());
            messages.push(TuneToStationResponse::generated_message_descriptor_data());
            messages.push(RadioStationInfoNotification::generated_message_descriptor_data());
            messages.push(RadioStationInfo::generated_message_descriptor_data());
            messages.push(RadioStationMetaData::generated_message_descriptor_data());
            messages.push(RdsData::generated_message_descriptor_data());
            messages.push(HdRadioStationInfo::generated_message_descriptor_data());
            messages.push(HdRadioPsdData::generated_message_descriptor_data());
            messages.push(HdRadioComment::generated_message_descriptor_data());
            messages.push(HdRadioCommercial::generated_message_descriptor_data());
            messages.push(HdRadioArtistExperience::generated_message_descriptor_data());
            messages.push(HdRadioSisData::generated_message_descriptor_data());
            messages.push(Location::generated_message_descriptor_data());
            messages.push(GetProgramListRequest::generated_message_descriptor_data());
            messages.push(GetProgramListResponse::generated_message_descriptor_data());
            messages.push(CancelRadioOperationsRequest::generated_message_descriptor_data());
            messages.push(CancelRadioOperationsResponse::generated_message_descriptor_data());
            messages.push(ConfigureChannelSpacingRequest::generated_message_descriptor_data());
            messages.push(ConfigureChannelSpacingResponse::generated_message_descriptor_data());
            messages.push(StationPresetsNotification::generated_message_descriptor_data());
            messages.push(StationPresetList::generated_message_descriptor_data());
            messages.push(StationPreset::generated_message_descriptor_data());
            messages.push(GetTrafficUpdateRequest::generated_message_descriptor_data());
            messages.push(GetTrafficUpdateResponse::generated_message_descriptor_data());
            messages.push(TrafficIncident::generated_message_descriptor_data());
            messages.push(MuteRadioRequest::generated_message_descriptor_data());
            messages.push(MuteRadioResponse::generated_message_descriptor_data());
            messages.push(NavigationStatusStart::generated_message_descriptor_data());
            messages.push(NavigationStatusStop::generated_message_descriptor_data());
            messages.push(NavigationStatus::generated_message_descriptor_data());
            messages.push(NavigationNextTurnEvent::generated_message_descriptor_data());
            messages.push(NavigationNextTurnDistanceEvent::generated_message_descriptor_data());
            messages.push(NavigationState::generated_message_descriptor_data());
            messages.push(NavigationStep::generated_message_descriptor_data());
            messages.push(NavigationManeuver::generated_message_descriptor_data());
            messages.push(NavigationCue::generated_message_descriptor_data());
            messages.push(NavigationLane::generated_message_descriptor_data());
            messages.push(NavigationDestination::generated_message_descriptor_data());
            messages.push(NavigationCurrentPosition::generated_message_descriptor_data());
            messages.push(NavigationStepDistance::generated_message_descriptor_data());
            messages.push(NavigationDestinationDistance::generated_message_descriptor_data());
            messages.push(NavigationRoad::generated_message_descriptor_data());
            messages.push(NavigationDistance::generated_message_descriptor_data());
            messages.push(InstrumentClusterInput::generated_message_descriptor_data());
            messages.push(MediaPlaybackStatus::generated_message_descriptor_data());
            messages.push(MediaPlaybackMetadata::generated_message_descriptor_data());
            messages.push(PhoneStatus::generated_message_descriptor_data());
            messages.push(PhoneStatusInput::generated_message_descriptor_data());
            messages.push(MediaRootNode::generated_message_descriptor_data());
            messages.push(MediaSource::generated_message_descriptor_data());
            messages.push(MediaSourceNode::generated_message_descriptor_data());
            messages.push(MediaList::generated_message_descriptor_data());
            messages.push(MediaListNode::generated_message_descriptor_data());
            messages.push(MediaSong::generated_message_descriptor_data());
            messages.push(MediaSongNode::generated_message_descriptor_data());
            messages.push(MediaGetNode::generated_message_descriptor_data());
            messages.push(MediaBrowserInput::generated_message_descriptor_data());
            messages.push(GalVerificationSetSensor::generated_message_descriptor_data());
            messages.push(GalVerificationMediaSinkStatus::generated_message_descriptor_data());
            messages.push(GalVerificationVideoFocus::generated_message_descriptor_data());
            messages.push(GalVerificationAudioFocus::generated_message_descriptor_data());
            messages.push(GalVerificationInjectInput::generated_message_descriptor_data());
            messages.push(GalVerificationBugReportRequest::generated_message_descriptor_data());
            messages.push(GalVerificationBugReportResponse::generated_message_descriptor_data());
            messages.push(GalVerificationScreenCaptureRequest::generated_message_descriptor_data());
            messages.push(GalVerificationScreenCaptureResponse::generated_message_descriptor_data());
            messages.push(GalVerificationDisplayInformationRequest::generated_message_descriptor_data());
            messages.push(GalVerificationDisplayInformationResponse::generated_message_descriptor_data());
            messages.push(GenericNotificationSubscribe::generated_message_descriptor_data());
            messages.push(GenericNotificationUnsubscribe::generated_message_descriptor_data());
            messages.push(GenericNotificationMessage::generated_message_descriptor_data());
            messages.push(GenericNotificationAck::generated_message_descriptor_data());
            messages.push(GoogleDiagnosticsBugReportRequest::generated_message_descriptor_data());
            messages.push(GoogleDiagnosticsBugReportResponse::generated_message_descriptor_data());
            messages.push(sensor_source_service::Sensor::generated_message_descriptor_data());
            messages.push(input_source_service::TouchScreen::generated_message_descriptor_data());
            messages.push(input_source_service::TouchPad::generated_message_descriptor_data());
            messages.push(navigation_status_service::ImageOptions::generated_message_descriptor_data());
            messages.push(key_event::Key::generated_message_descriptor_data());
            messages.push(touch_event::Pointer::generated_message_descriptor_data());
            messages.push(absolute_event::Abs::generated_message_descriptor_data());
            messages.push(relative_event::Rel::generated_message_descriptor_data());
            messages.push(navigation_lane::LaneDirection::generated_message_descriptor_data());
            messages.push(phone_status::Call::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(67);
            enums.push(ControlMessageType::generated_enum_descriptor_data());
            enums.push(FragInfo::generated_enum_descriptor_data());
            enums.push(DriverPosition::generated_enum_descriptor_data());
            enums.push(SessionConfiguration::generated_enum_descriptor_data());
            enums.push(LocationCharacterization::generated_enum_descriptor_data());
            enums.push(SensorType::generated_enum_descriptor_data());
            enums.push(FuelType::generated_enum_descriptor_data());
            enums.push(EvConnectorType::generated_enum_descriptor_data());
            enums.push(VideoCodecResolutionType::generated_enum_descriptor_data());
            enums.push(VideoFrameRateType::generated_enum_descriptor_data());
            enums.push(MediaCodecType::generated_enum_descriptor_data());
            enums.push(AudioStreamType::generated_enum_descriptor_data());
            enums.push(DisplayType::generated_enum_descriptor_data());
            enums.push(UiTheme::generated_enum_descriptor_data());
            enums.push(TouchScreenType::generated_enum_descriptor_data());
            enums.push(BluetoothPairingMethod::generated_enum_descriptor_data());
            enums.push(TrafficServiceType::generated_enum_descriptor_data());
            enums.push(RdsType::generated_enum_descriptor_data());
            enums.push(RadioType::generated_enum_descriptor_data());
            enums.push(ItuRegion::generated_enum_descriptor_data());
            enums.push(NavFocusType::generated_enum_descriptor_data());
            enums.push(ByeByeReason::generated_enum_descriptor_data());
            enums.push(VoiceSessionStatus::generated_enum_descriptor_data());
            enums.push(UserSwitchStatus::generated_enum_descriptor_data());
            enums.push(SensorErrorType::generated_enum_descriptor_data());
            enums.push(Gear::generated_enum_descriptor_data());
            enums.push(DrivingStatus::generated_enum_descriptor_data());
            enums.push(HeadLightState::generated_enum_descriptor_data());
            enums.push(TurnIndicatorState::generated_enum_descriptor_data());
            enums.push(SensorMessageId::generated_enum_descriptor_data());
            enums.push(VideoFocusReason::generated_enum_descriptor_data());
            enums.push(VideoFocusMode::generated_enum_descriptor_data());
            enums.push(AudioFocusRequestType::generated_enum_descriptor_data());
            enums.push(AudioFocusStateType::generated_enum_descriptor_data());
            enums.push(MediaMessageId::generated_enum_descriptor_data());
            enums.push(PointerAction::generated_enum_descriptor_data());
            enums.push(FeedbackEvent::generated_enum_descriptor_data());
            enums.push(InputMessageId::generated_enum_descriptor_data());
            enums.push(BluetoothMessageId::generated_enum_descriptor_data());
            enums.push(WifiSecurityMode::generated_enum_descriptor_data());
            enums.push(AccessPointType::generated_enum_descriptor_data());
            enums.push(WifiProjectionMessageId::generated_enum_descriptor_data());
            enums.push(RadioMessageId::generated_enum_descriptor_data());
            enums.push(HdAcquisionState::generated_enum_descriptor_data());
            enums.push(NavigationStatusMessageId::generated_enum_descriptor_data());
            enums.push(MediaPlaybackStatusMessageId::generated_enum_descriptor_data());
            enums.push(PhoneStatusMessageId::generated_enum_descriptor_data());
            enums.push(MediaBrowserMessageId::generated_enum_descriptor_data());
            enums.push(GalVerificationVendorExtensionMessageId::generated_enum_descriptor_data());
            enums.push(GenericNotificationMessageId::generated_enum_descriptor_data());
            enums.push(GoogleDiagnosticsVendorExtensionMessageId::generated_enum_descriptor_data());
            enums.push(MessageStatus::generated_enum_descriptor_data());
            enums.push(KeyCode::generated_enum_descriptor_data());
            enums.push(GalConstants::generated_enum_descriptor_data());
            enums.push(navigation_status_service::InstrumentClusterType::generated_enum_descriptor_data());
            enums.push(config::Status::generated_enum_descriptor_data());
            enums.push(navigation_status::NavigationStatusEnum::generated_enum_descriptor_data());
            enums.push(navigation_next_turn_event::TurnSide::generated_enum_descriptor_data());
            enums.push(navigation_next_turn_event::NextTurnEnum::generated_enum_descriptor_data());
            enums.push(navigation_next_turn_distance_event::DistanceUnits::generated_enum_descriptor_data());
            enums.push(navigation_maneuver::NavigationType::generated_enum_descriptor_data());
            enums.push(navigation_lane::lane_direction::Shape::generated_enum_descriptor_data());
            enums.push(navigation_distance::DistanceUnits::generated_enum_descriptor_data());
            enums.push(instrument_cluster_input::InstrumentClusterAction::generated_enum_descriptor_data());
            enums.push(media_playback_status::State::generated_enum_descriptor_data());
            enums.push(phone_status::State::generated_enum_descriptor_data());
            enums.push(media_list::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
